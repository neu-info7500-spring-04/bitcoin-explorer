/* eslint-disable */
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /** Represents non-fractional signed whole numeric values. Since the value may exceed the size of a 32-bit integer, it's encoded as a string. */
  BitqueryBigInt: { input: any; output: any; }
  /**
   * Represents fractional signed whole numeric values.
   * Since the value may exceed the size of a 32-bit integer, it's encoded as a string.
   */
  BitqueryDecimalNumber: { input: any; output: any; }
  /**
   * Represents fractional signed whole numeric values.
   * Since the value may exceed the size of a 32-bit integer, it's encoded as a string.
   */
  BitqueryDecimalNumberAsDiv: { input: any; output: any; }
  /** An ISO 8601-encoded date */
  BitqueryISO8601Date: { input: any; output: any; }
  /** An ISO 8601-encoded datetime */
  BitqueryISO8601DateTime: { input: any; output: any; }
  /** A JSON Value */
  JSON: { input: any; output: any; }
};

/** Account */
export type BitqueryAccount = {
  __typename?: 'BitqueryAccount';
  /** Account ID */
  id: Scalars['String']['output'];
  /** Account number, the equivalent of a human-friendly public key */
  num: Scalars['Int']['output'];
  /** Realm number  */
  realmId: Scalars['Int']['output'];
  /** Shard number */
  shardId: Scalars['Int']['output'];
};

/** Solana Action */
export type BitqueryAction = {
  __typename?: 'BitqueryAction';
  name: Scalars['String']['output'];
  type: Scalars['String']['output'];
};

export enum BitqueryActionEnum {
  /** Add Quantity */
  AddQuantity = 'addQuantity',
  /** Burn */
  Burn = 'burn',
  /** Mint */
  Create = 'create',
  /** Fee */
  Fee = 'fee',
  /** Mint */
  LocalMint = 'localMint',
  /** Transaction */
  Transaction = 'transaction',
  /** Transfer */
  Transfer = 'transfer'
}

/** Select by action */
export type BitqueryActionSelector = {
  /** Action in the list */
  in?: InputMaybe<Array<BitqueryActionEnum>>;
  /** Action is */
  is?: InputMaybe<BitqueryActionEnum>;
  /** Action not */
  not?: InputMaybe<BitqueryActionEnum>;
  /** Action not in the list */
  notIn?: InputMaybe<Array<BitqueryActionEnum>>;
};

export enum BitqueryActiveAddress {
  /** Address */
  Address = 'address'
}

export enum BitqueryActiveAddressUniq {
  /** Address */
  Address = 'address'
}

/** ActivePeriod */
export type BitqueryActivePeriod = {
  __typename?: 'BitqueryActivePeriod';
  /** Billing day */
  billingDay: Scalars['Int']['output'];
  /** Period ends at */
  ends: BitqueryUtilitiesDate;
  /** Is blocked */
  isBlocked: Scalars['Boolean']['output'];
  /** Is paid */
  isPaid: Scalars['Boolean']['output'];
  /** Is points consumed */
  isPointsConsumed: Scalars['Boolean']['output'];
  /** Is spent */
  isSpent: Scalars['Boolean']['output'];
  /** Total available points */
  points: Scalars['BitqueryBigInt']['output'];
  /** Remaining points */
  pointsRemaining: Scalars['BitqueryBigInt']['output'];
  /** Period starts at */
  starts: BitqueryUtilitiesDate;
};

/** Blockchain address */
export type BitqueryAddress = {
  __typename?: 'BitqueryAddress';
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
};

/** Address selector */
export type BitqueryAddressSelector = {
  /** In the list of Addresses */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Equal to Address */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Not Equal to Address */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Not in the list of Addresses */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Address selector */
export type BitqueryAddressSelectorIn = {
  /** In the list of Addresses */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Equal to Address */
  is?: InputMaybe<Scalars['String']['input']>;
};

/** Address with statistics */
export type BitqueryAddressStatDimension = {
  __typename?: 'BitqueryAddressStatDimension';
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** First active */
  firstActive?: Maybe<BitqueryDateTime>;
  /** Inbound transactions */
  inboundTransactions?: Maybe<Scalars['Int']['output']>;
  /** Inflows */
  inflows?: Maybe<Scalars['Float']['output']>;
  /** Last active */
  lastActive?: Maybe<BitqueryDateTime>;
  /** Outbound transactions */
  outboundTransactions?: Maybe<Scalars['Int']['output']>;
  /** Outflows */
  outflows?: Maybe<Scalars['Float']['output']>;
  /** Unique days with transfers */
  uniqueDaysWithTransfers?: Maybe<Scalars['Int']['output']>;
  /** Unique receivers */
  uniqueReceivers?: Maybe<Scalars['Int']['output']>;
  /** Unique senders */
  uniqueSenders?: Maybe<Scalars['Int']['output']>;
};


/** Address with statistics */
export type BitqueryAddressStatDimensionBalanceArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};

/** Blockchain account with address and type */
export type BitqueryAddressWithAccount = {
  __typename?: 'BitqueryAddressWithAccount';
  /** Account ID */
  account: Scalars['String']['output'];
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Account type */
  type: Scalars['String']['output'];
};

/** Algorand Blockchain */
export type BitqueryAlgorand = {
  __typename?: 'BitqueryAlgorand';
  /** Basic information about address ( or smart contract ) */
  address: Array<BitqueryAlgorandAddressInfo>;
  /** Arguments of Smart Contract Calls and Events */
  arguments?: Maybe<Array<BitqueryAlgorandArguments>>;
  /** Blockchain Blocks */
  blocks?: Maybe<Array<BitqueryAlgorandBlocks>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryAlgorandCoinpath>>;
  /** Smart Contract Calls */
  smartContractCalls?: Maybe<Array<BitqueryAlgorandSmartContractCalls>>;
  /** Blockchain Transactions */
  transactions?: Maybe<Array<BitqueryAlgorandTransactions>>;
  /** Currency Transfers */
  transfers?: Maybe<Array<BitqueryAlgorandTransfers>>;
};


/** Algorand Blockchain */
export type BitqueryAlgorandAddressArgs = {
  address: Array<BitqueryAddressSelectorIn>;
};


/** Algorand Blockchain */
export type BitqueryAlgorandArgumentsArgs = {
  any?: InputMaybe<Array<BitqueryAlgorandArgumentFilter>>;
  argindex?: InputMaybe<BitqueryArgumentIndexSelector>;
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  caller?: InputMaybe<Array<BitqueryAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  reference?: InputMaybe<Array<BitqueryAddressSelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Algorand Blockchain */
export type BitqueryAlgorandBlocksArgs = {
  any?: InputMaybe<Array<BitqueryAlgorandBlockFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  currentProtocol?: InputMaybe<BitqueryStringIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  nextProtocol?: InputMaybe<BitqueryStringIdSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  proposer?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Algorand Blockchain */
export type BitqueryAlgorandCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryAlgorandCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCoinpathOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Algorand Blockchain */
export type BitqueryAlgorandSmartContractCallsArgs = {
  any?: InputMaybe<Array<BitqueryAlgorandSmartContractCallFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
};


/** Algorand Blockchain */
export type BitqueryAlgorandTransactionsArgs = {
  any?: InputMaybe<Array<BitqueryAlgorandTransactionFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  group?: InputMaybe<BitqueryGroupSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCurrency?: InputMaybe<Array<BitqueryAlgorandCurrencySelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
  txSubtype?: InputMaybe<BitqueryTxSubtypeSelector>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
};


/** Algorand Blockchain */
export type BitqueryAlgorandTransfersArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  any?: InputMaybe<Array<BitqueryAlgorandTransferFilter>>;
  currency?: InputMaybe<Array<BitqueryAlgorandCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  receiver?: InputMaybe<Array<BitqueryAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transferType?: InputMaybe<BitqueryAlgorandTransferTypeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
};

/** Address detailed information for Algorand network */
export type BitqueryAlgorandAddressInfo = {
  __typename?: 'BitqueryAlgorandAddressInfo';
  /** Address */
  address?: Maybe<BitqueryAddress>;
  /** Current address balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** Created Assets */
  createdAssets?: Maybe<Array<BitqueryAlgorandCreatedAssets>>;
  /** Current pending rewards */
  pendingRewards?: Maybe<Scalars['Float']['output']>;
  /** Current rewards */
  rewards?: Maybe<Scalars['Float']['output']>;
  /** Current round */
  round?: Maybe<Scalars['String']['output']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<BitqueryAlgorandSmartContract>;
  /** Current status */
  status?: Maybe<Scalars['String']['output']>;
  /** Total amount of created apps */
  totalCreatedApps?: Maybe<Scalars['Int']['output']>;
  /** Total amount of created assets */
  totalCreatedAssets?: Maybe<Scalars['Int']['output']>;
};


/** Address detailed information for Algorand network */
export type BitqueryAlgorandAddressInfoBalanceArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Address detailed information for Algorand network */
export type BitqueryAlgorandAddressInfoPendingRewardsArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Address detailed information for Algorand network */
export type BitqueryAlgorandAddressInfoRewardsArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};

export type BitqueryAlgorandArgumentFilter = {
  argindex?: InputMaybe<BitqueryArgumentIndexSelector>;
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  caller?: InputMaybe<Array<BitqueryAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryAddressSelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};

/** Arguments of Smart Contract Calls */
export type BitqueryAlgorandArguments = {
  __typename?: 'BitqueryAlgorandArguments';
  any?: Maybe<Scalars['String']['output']>;
  /** Sequential index of value in array ( multi-dimensional) */
  argindex: Scalars['Int']['output'];
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']['output']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  firstRound?: Maybe<Scalars['Int']['output']>;
  genesisHash64?: Maybe<Scalars['String']['output']>;
  genesisId?: Maybe<Scalars['String']['output']>;
  lastRound?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  note?: Maybe<Scalars['String']['output']>;
  poolerror?: Maybe<Scalars['String']['output']>;
  /** Smart contract being called */
  smartContract?: Maybe<BitqueryAlgorandSmartContract>;
  /** Transaction where call happened */
  transaction?: Maybe<BitqueryTransactionHashIndex>;
  /** Transaction sender */
  txSender?: Maybe<BitqueryAddress>;
  /** Transaction type in which the transfer happened */
  txType?: Maybe<BitqueryAlgorandTxType>;
  /** The Value of argument */
  value?: Maybe<Scalars['String']['output']>;
};


/** Arguments of Smart Contract Calls */
export type BitqueryAlgorandArgumentsAnyArgs = {
  of: BitqueryAlgorandArgumentsMeasureable;
};


/** Arguments of Smart Contract Calls */
export type BitqueryAlgorandArgumentsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Arguments of Smart Contract Calls */
export type BitqueryAlgorandArgumentsCountArgs = {
  argindex?: InputMaybe<BitqueryArgumentIndexSelector>;
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  caller?: InputMaybe<Array<BitqueryAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryAddressSelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls */
export type BitqueryAlgorandArgumentsCountBigIntArgs = {
  argindex?: InputMaybe<BitqueryArgumentIndexSelector>;
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  caller?: InputMaybe<Array<BitqueryAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryAddressSelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls */
export type BitqueryAlgorandArgumentsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Arguments of Smart Contract Calls */
export type BitqueryAlgorandArgumentsMaximumArgs = {
  get?: InputMaybe<BitqueryAlgorandArgumentsMeasureable>;
  of: BitqueryAlgorandArgumentsMeasureable;
};


/** Arguments of Smart Contract Calls */
export type BitqueryAlgorandArgumentsMinimumArgs = {
  get?: InputMaybe<BitqueryAlgorandArgumentsMeasureable>;
  of: BitqueryAlgorandArgumentsMeasureable;
};


/** Arguments of Smart Contract Calls */
export type BitqueryAlgorandArgumentsSmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
};


/** Arguments of Smart Contract Calls */
export type BitqueryAlgorandArgumentsTransactionArgs = {
  txFrom?: InputMaybe<Array<BitqueryAddressSelector>>;
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Arguments of Smart Contract Calls */
export type BitqueryAlgorandArgumentsTxSenderArgs = {
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
};


/** Arguments of Smart Contract Calls */
export type BitqueryAlgorandArgumentsTxTypeArgs = {
  txType?: InputMaybe<Array<BitqueryAlgorandTxType>>;
};


/** Arguments of Smart Contract Calls */
export type BitqueryAlgorandArgumentsValueArgs = {
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};

export enum BitqueryAlgorandArgumentsMeasureable {
  /** Argument index */
  ArgumentIndex = 'argument_index',
  /** Argument value */
  ArgumentValue = 'argument_value',
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Smart Contract */
  SmartContract = 'smart_contract',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Transaction Sender */
  TxSender = 'tx_sender',
  /** Transaction type */
  TxType = 'tx_type'
}

export type BitqueryAlgorandBlockFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  currentProtocol?: InputMaybe<BitqueryStringIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  nextProtocol?: InputMaybe<BitqueryStringIdSelector>;
  proposer?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

/** Blocks in Algorand blockchain */
export type BitqueryAlgorandBlocks = {
  __typename?: 'BitqueryAlgorandBlocks';
  any?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  currentProtocol?: Maybe<Scalars['String']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  frac: Scalars['BitqueryBigInt']['output'];
  /** Block hash */
  hash: Scalars['String']['output'];
  /** Block number (height) in blockchain */
  height: Scalars['Int']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  nextProtocol?: Maybe<Scalars['String']['output']>;
  nextProtocolApprovals?: Maybe<Scalars['BitqueryBigInt']['output']>;
  nextProtocolSwitchOn?: Maybe<Scalars['BitqueryBigInt']['output']>;
  nextProtocolVoteBefore?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Previous block hash */
  previousBlockHash: Scalars['String']['output'];
  /** Block proposer */
  proposer?: Maybe<BitqueryAddress>;
  rate?: Maybe<Scalars['Float']['output']>;
  reward?: Maybe<Scalars['Float']['output']>;
  seed?: Maybe<Scalars['String']['output']>;
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  txnRoot: Scalars['String']['output'];
  upgradeApprove?: Maybe<Scalars['Int']['output']>;
  upgradePropose?: Maybe<Scalars['String']['output']>;
};


/** Blocks in Algorand blockchain */
export type BitqueryAlgorandBlocksAnyArgs = {
  of: BitqueryAlgorandBlocksMeasureable;
};


/** Blocks in Algorand blockchain */
export type BitqueryAlgorandBlocksCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  currentProtocol?: InputMaybe<BitqueryStringIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  nextProtocol?: InputMaybe<BitqueryStringIdSelector>;
  proposer?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryAlgorandBlocksUniq>;
};


/** Blocks in Algorand blockchain */
export type BitqueryAlgorandBlocksCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  currentProtocol?: InputMaybe<BitqueryStringIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  nextProtocol?: InputMaybe<BitqueryStringIdSelector>;
  proposer?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryAlgorandBlocksUniq>;
};


/** Blocks in Algorand blockchain */
export type BitqueryAlgorandBlocksExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Blocks in Algorand blockchain */
export type BitqueryAlgorandBlocksHashArgs = {
  blockHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Blocks in Algorand blockchain */
export type BitqueryAlgorandBlocksHeightArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Blocks in Algorand blockchain */
export type BitqueryAlgorandBlocksMaximumArgs = {
  get?: InputMaybe<BitqueryAlgorandBlocksMeasureable>;
  of: BitqueryAlgorandBlocksMeasureable;
};


/** Blocks in Algorand blockchain */
export type BitqueryAlgorandBlocksMinimumArgs = {
  get?: InputMaybe<BitqueryAlgorandBlocksMeasureable>;
  of: BitqueryAlgorandBlocksMeasureable;
};


/** Blocks in Algorand blockchain */
export type BitqueryAlgorandBlocksProposerArgs = {
  proposer?: InputMaybe<Array<BitqueryAddressSelector>>;
};


/** Blocks in Algorand blockchain */
export type BitqueryAlgorandBlocksRateArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currentProtocol?: InputMaybe<BitqueryStringIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  nextProtocol?: InputMaybe<BitqueryStringIdSelector>;
  proposer?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Blocks in Algorand blockchain */
export type BitqueryAlgorandBlocksRewardArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currentProtocol?: InputMaybe<BitqueryStringIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nextProtocol?: InputMaybe<BitqueryStringIdSelector>;
  proposer?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Blocks in Algorand blockchain */
export type BitqueryAlgorandBlocksTimestampArgs = {
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

export enum BitqueryAlgorandBlocksMeasureable {
  /** Block */
  Block = 'block',
  /** Block hash */
  BlockHash = 'block_hash',
  /** Block Reward */
  BlockReward = 'block_reward',
  /** Date */
  Date = 'date',
  /** Next protocol approvals */
  NextProtocolApprovals = 'next_protocol_approvals',
  /** Block Proposer */
  Proposer = 'proposer',
  /** Time */
  Time = 'time'
}

export enum BitqueryAlgorandBlocksUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique proposer count */
  Proposers = 'proposers'
}

export enum BitqueryAlgorandCallsMeasureable {
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Smart Contract */
  SmartContract = 'smart_contract',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Transaction Sender */
  TxSender = 'tx_sender',
  /** Transaction type */
  TxType = 'tx_type'
}

/** Coinpath */
export type BitqueryAlgorandCoinpath = {
  __typename?: 'BitqueryAlgorandCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<BitqueryTransactionHashValue>;
};


/** Coinpath */
export type BitqueryAlgorandCoinpathAmountArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Coinpath */
export type BitqueryAlgorandCoinpathAnyArgs = {
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryAlgorandCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryAlgorandCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};

/** Algorand created assets */
export type BitqueryAlgorandCreatedAssets = {
  __typename?: 'BitqueryAlgorandCreatedAssets';
  /** Creator */
  creator?: Maybe<Scalars['String']['output']>;
  /** Decimals */
  decimals?: Maybe<Scalars['Int']['output']>;
  /** Asset Index */
  index?: Maybe<Scalars['Int']['output']>;
  /** Manager */
  manager?: Maybe<Scalars['String']['output']>;
  /** Name */
  name?: Maybe<Scalars['String']['output']>;
  /** Reserve */
  reserve?: Maybe<Scalars['String']['output']>;
  /** symbol */
  symbol?: Maybe<Scalars['String']['output']>;
  /** URL */
  url?: Maybe<Scalars['String']['output']>;
};

/**
 * Currency selector in Algorand blockchain.
 *   Currency is selected by asset ID. To select ALGO use ID=0
 */
export type BitqueryAlgorandCurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['Int']['input']>;
  /** Currency not */
  not?: InputMaybe<Scalars['Int']['input']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export enum BitqueryAlgorandNetwork {
  /** Algorand Mainnet (ALGO) */
  Algorand = 'algorand',
  /** Algorand Betanet */
  AlgorandBetanet = 'algorand_betanet',
  /** Algorand Testnet */
  AlgorandTestnet = 'algorand_testnet'
}

/** Algorand smart contract */
export type BitqueryAlgorandSmartContract = {
  __typename?: 'BitqueryAlgorandSmartContract';
  /** Smart Contract Address */
  address: BitqueryAddress;
  /** Smart Contract byte code */
  bytecode?: Maybe<Scalars['String']['output']>;
  /** Smart Contract Deassembled source code */
  source?: Maybe<Scalars['String']['output']>;
};

export type BitqueryAlgorandSmartContractCallFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
};

/** Smart Contract Calls */
export type BitqueryAlgorandSmartContractCalls = {
  __typename?: 'BitqueryAlgorandSmartContractCalls';
  any?: Maybe<Scalars['String']['output']>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']['output']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Fee used in transaction call */
  fee?: Maybe<Scalars['Float']['output']>;
  firstRound?: Maybe<Scalars['Int']['output']>;
  genesisHash64?: Maybe<Scalars['String']['output']>;
  genesisId?: Maybe<Scalars['String']['output']>;
  lastRound?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  note?: Maybe<Scalars['String']['output']>;
  poolerror?: Maybe<Scalars['String']['output']>;
  /** Smart contract being called */
  smartContract?: Maybe<BitqueryAlgorandSmartContract>;
  /** Transaction where call happened */
  transaction?: Maybe<BitqueryTransactionHashIndex>;
  /** Transaction sender */
  txSender?: Maybe<BitqueryAddress>;
  /** Transaction type in which the transfer happened */
  txType?: Maybe<BitqueryAlgorandTxType>;
};


/** Smart Contract Calls */
export type BitqueryAlgorandSmartContractCallsAnyArgs = {
  of: BitqueryAlgorandCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryAlgorandSmartContractCallsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Smart Contract Calls */
export type BitqueryAlgorandSmartContractCallsCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type BitqueryAlgorandSmartContractCallsCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type BitqueryAlgorandSmartContractCallsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Smart Contract Calls */
export type BitqueryAlgorandSmartContractCallsFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
};


/** Smart Contract Calls */
export type BitqueryAlgorandSmartContractCallsMaximumArgs = {
  get?: InputMaybe<BitqueryAlgorandCallsMeasureable>;
  of: BitqueryAlgorandCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryAlgorandSmartContractCallsMinimumArgs = {
  get?: InputMaybe<BitqueryAlgorandCallsMeasureable>;
  of: BitqueryAlgorandCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryAlgorandSmartContractCallsSmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
};


/** Smart Contract Calls */
export type BitqueryAlgorandSmartContractCallsTransactionArgs = {
  txFrom?: InputMaybe<Array<BitqueryAddressSelector>>;
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Smart Contract Calls */
export type BitqueryAlgorandSmartContractCallsTxSenderArgs = {
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
};


/** Smart Contract Calls */
export type BitqueryAlgorandSmartContractCallsTxTypeArgs = {
  txType?: InputMaybe<Array<BitqueryAlgorandTxType>>;
};

export type BitqueryAlgorandTransactionFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  group?: InputMaybe<BitqueryGroupSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCurrency?: InputMaybe<Array<BitqueryAlgorandCurrencySelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
  txSubtype?: InputMaybe<BitqueryTxSubtypeSelector>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
};

/** Algorand transaction with attributes */
export type BitqueryAlgorandTransactionWithAttributes = {
  __typename?: 'BitqueryAlgorandTransactionWithAttributes';
  /** Block of the Output Transaction for this input */
  block?: Maybe<Scalars['Int']['output']>;
  /** Transaction fee */
  fee?: Maybe<Scalars['Float']['output']>;
  firstRound?: Maybe<Scalars['Int']['output']>;
  /** Transaction rewards ( from )  */
  fromrewards?: Maybe<Scalars['Float']['output']>;
  group?: Maybe<Scalars['String']['output']>;
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction index in block, 0-based */
  index: Scalars['String']['output'];
  lastRound?: Maybe<Scalars['Int']['output']>;
  lease?: Maybe<Scalars['String']['output']>;
  note?: Maybe<Scalars['String']['output']>;
  poolerror?: Maybe<Scalars['String']['output']>;
  /** Transfer transaction sender */
  sender?: Maybe<BitqueryAddress>;
  /** Transaction sub type */
  subtype?: Maybe<BitqueryAlgorandTxSubType>;
  /** Transaction type in which the transfer happened */
  type?: Maybe<BitqueryAlgorandTxType>;
};

/** Transactions in Algorand blockchain */
export type BitqueryAlgorandTransactions = {
  __typename?: 'BitqueryAlgorandTransactions';
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BitqueryBlock>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Asset related to transaction */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  fee?: Maybe<Scalars['Float']['output']>;
  firstRound?: Maybe<Scalars['Int']['output']>;
  genesisHash?: Maybe<Scalars['String']['output']>;
  genesisId?: Maybe<Scalars['String']['output']>;
  group?: Maybe<Scalars['String']['output']>;
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction index in block, 0 based */
  index?: Maybe<Scalars['Int']['output']>;
  lastRound?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  note?: Maybe<Scalars['String']['output']>;
  poolerror?: Maybe<Scalars['String']['output']>;
  /** Transaction sender */
  sender?: Maybe<BitqueryAddress>;
  /** Transaction sub type */
  subtype?: Maybe<BitqueryAlgorandTxSubType>;
  /** Transaction type */
  type?: Maybe<BitqueryAlgorandTxType>;
};


/** Transactions in Algorand blockchain */
export type BitqueryAlgorandTransactionsAnyArgs = {
  of: BitqueryAlgorandTransactionsMeasureable;
};


/** Transactions in Algorand blockchain */
export type BitqueryAlgorandTransactionsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transactions in Algorand blockchain */
export type BitqueryAlgorandTransactionsCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  group?: InputMaybe<BitqueryGroupSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCurrency?: InputMaybe<Array<BitqueryAlgorandCurrencySelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
  txSubtype?: InputMaybe<BitqueryTxSubtypeSelector>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
  uniq?: InputMaybe<BitqueryAlgorandTransactionsUniq>;
};


/** Transactions in Algorand blockchain */
export type BitqueryAlgorandTransactionsCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  group?: InputMaybe<BitqueryGroupSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCurrency?: InputMaybe<Array<BitqueryAlgorandCurrencySelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
  txSubtype?: InputMaybe<BitqueryTxSubtypeSelector>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
  uniq?: InputMaybe<BitqueryAlgorandTransactionsUniq>;
};


/** Transactions in Algorand blockchain */
export type BitqueryAlgorandTransactionsCurrencyArgs = {
  txCurrency?: InputMaybe<Array<BitqueryAlgorandCurrencySelector>>;
};


/** Transactions in Algorand blockchain */
export type BitqueryAlgorandTransactionsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transactions in Algorand blockchain */
export type BitqueryAlgorandTransactionsFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  group?: InputMaybe<BitqueryGroupSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCurrency?: InputMaybe<Array<BitqueryAlgorandCurrencySelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
  txSubtype?: InputMaybe<BitqueryTxSubtypeSelector>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
};


/** Transactions in Algorand blockchain */
export type BitqueryAlgorandTransactionsHashArgs = {
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Transactions in Algorand blockchain */
export type BitqueryAlgorandTransactionsIndexArgs = {
  txIndex?: InputMaybe<Array<BitqueryTxIndexSelector>>;
};


/** Transactions in Algorand blockchain */
export type BitqueryAlgorandTransactionsMaximumArgs = {
  get?: InputMaybe<BitqueryAlgorandTransactionsMeasureable>;
  of: BitqueryAlgorandTransactionsMeasureable;
};


/** Transactions in Algorand blockchain */
export type BitqueryAlgorandTransactionsMinimumArgs = {
  get?: InputMaybe<BitqueryAlgorandTransactionsMeasureable>;
  of: BitqueryAlgorandTransactionsMeasureable;
};


/** Transactions in Algorand blockchain */
export type BitqueryAlgorandTransactionsSenderArgs = {
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
};


/** Transactions in Algorand blockchain */
export type BitqueryAlgorandTransactionsSubtypeArgs = {
  txType?: InputMaybe<BitqueryTxSubtypeSelector>;
};


/** Transactions in Algorand blockchain */
export type BitqueryAlgorandTransactionsTypeArgs = {
  txType?: InputMaybe<BitqueryTxTypeSelector>;
};

export enum BitqueryAlgorandTransactionsMeasureable {
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Fee value */
  Fee = 'fee',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Transaction Sender */
  TxSender = 'tx_sender'
}

export enum BitqueryAlgorandTransactionsUniq {
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique currencies */
  Currencies = 'currencies',
  /** Unique date count */
  Dates = 'dates',
  /** Unique TX senders count */
  Senders = 'senders'
}

export type BitqueryAlgorandTransferFilter = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryAlgorandCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<Array<BitqueryAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transferType?: InputMaybe<BitqueryAlgorandTransferTypeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
};

export enum BitqueryAlgorandTransferType {
  /** Close */
  Close = 'close',
  /** Create Asset */
  Create = 'create',
  /** Asset Freeze */
  Freeze = 'freeze',
  /** Genesis Block */
  Genesis = 'genesis',
  /** Reward */
  Reward = 'reward',
  /** Send */
  Send = 'send',
  /** Asset Unfreeze */
  Unfreeze = 'unfreeze'
}

/** Select transfers by type */
export type BitqueryAlgorandTransferTypeSelector = {
  /** Transfer Type in the list */
  in?: InputMaybe<Array<BitqueryAlgorandTransferType>>;
  /** Transfer Type is */
  is?: InputMaybe<BitqueryAlgorandTransferType>;
  /** Transfer Type not */
  not?: InputMaybe<BitqueryAlgorandTransferType>;
  /** Transfer Type not in the list */
  notIn?: InputMaybe<Array<BitqueryAlgorandTransferType>>;
};

/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryAlgorandTransfers = {
  __typename?: 'BitqueryAlgorandTransfers';
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BitqueryBlock>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  firstRound?: Maybe<Scalars['Int']['output']>;
  lastRound?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  memo?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Transfer receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Transfer sender */
  sender?: Maybe<BitqueryAddress>;
  /** Transaction where transfer happened */
  transaction?: Maybe<BitqueryAlgorandTransactionWithAttributes>;
  /** Transfer Type */
  transferType?: Maybe<BitqueryAlgorandTransferType>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryAlgorandTransfersAmountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<Array<BitqueryAlgorandCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  receiver?: InputMaybe<Array<BitqueryAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transferType?: InputMaybe<BitqueryAlgorandTransferTypeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryAlgorandTransfersAnyArgs = {
  of: BitqueryAlgorandTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryAlgorandTransfersBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryAlgorandTransfersCountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryAlgorandCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<Array<BitqueryAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transferType?: InputMaybe<BitqueryAlgorandTransferTypeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
  uniq?: InputMaybe<BitqueryTransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryAlgorandTransfersCountBigIntArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryAlgorandCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<Array<BitqueryAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transferType?: InputMaybe<BitqueryAlgorandTransferTypeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
  uniq?: InputMaybe<BitqueryTransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryAlgorandTransfersCurrencyArgs = {
  currency?: InputMaybe<Array<BitqueryAlgorandCurrencySelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryAlgorandTransfersExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryAlgorandTransfersMaximumArgs = {
  get?: InputMaybe<BitqueryAlgorandTransfersMeasureable>;
  of: BitqueryAlgorandTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryAlgorandTransfersMinimumArgs = {
  get?: InputMaybe<BitqueryAlgorandTransfersMeasureable>;
  of: BitqueryAlgorandTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryAlgorandTransfersReceiverArgs = {
  receiver?: InputMaybe<Array<BitqueryAddressSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryAlgorandTransfersSenderArgs = {
  sender?: InputMaybe<Array<BitqueryAddressSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryAlgorandTransfersTransactionArgs = {
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryAlgorandTransfersTransferTypeArgs = {
  transferType?: InputMaybe<Array<BitqueryAlgorandTransferType>>;
};

export enum BitqueryAlgorandTransfersMeasureable {
  /** Amount */
  Amount = 'amount',
  /** Currency Asset ID */
  AssetId = 'asset_id',
  /** Block */
  Block = 'block',
  /** Currency symbol */
  CurrencySymbol = 'currency_symbol',
  /** Date */
  Date = 'date',
  /** Receiver */
  Receiver = 'receiver',
  /** Sender */
  Sender = 'sender',
  /** Time */
  Time = 'time',
  /** Transfer type */
  TransferType = 'transfer_type',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** TX Sender */
  TxSender = 'tx_sender',
  /** Transaction type */
  TxType = 'tx_type'
}

export enum BitqueryAlgorandTxSubType {
  /** Close */
  Close = 'close',
  /** Asset Configuration */
  Configure = 'configure',
  /** Create */
  Create = 'create',
  /** Asset Freeze */
  Freeze = 'freeze',
  /** Key Reg */
  Keyreg = 'keyreg',
  /** None */
  None = 'none',
  /** Send */
  Send = 'send',
  /** Asset Unfreeze */
  Unfreeze = 'unfreeze'
}

export enum BitqueryAlgorandTxType {
  /** Asset Configuration */
  Acfg = 'acfg',
  /** Asset Freeze or Unfreeze */
  Afrz = 'afrz',
  /** Application Call */
  Appl = 'appl',
  /** Asset Transfer */
  Axfer = 'axfer',
  /** Genesis Block */
  Genesis = 'genesis',
  /** Key Reg */
  Keyreg = 'keyreg',
  /** Pay */
  Pay = 'pay'
}

export enum BitqueryAmountAggregateFunction {
  /** Any value */
  Any = 'any',
  /** Last value */
  AnyLast = 'anyLast',
  /** Average */
  Average = 'average',
  /** Maximum */
  Maximum = 'maximum',
  /** Median */
  Median = 'median',
  /** Minimum */
  Minimum = 'minimum',
  /** Sum (total) */
  Sum = 'sum',
  /** Unique estimate fast */
  Unique = 'unique',
  /** Unique exact */
  UniqueExact = 'uniqueExact'
}

/** Select by amount */
export type BitqueryAmountSelector = {
  /** Amount in range */
  between?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** Amount greater than */
  gt?: InputMaybe<Scalars['Float']['input']>;
  /** Amount greater or equal than */
  gteq?: InputMaybe<Scalars['Float']['input']>;
  /** Amount in the list */
  in?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** Amount is */
  is?: InputMaybe<Scalars['Float']['input']>;
  /** Amount less than */
  lt?: InputMaybe<Scalars['Float']['input']>;
  /** Amount less or equal than */
  lteq?: InputMaybe<Scalars['Float']['input']>;
  /** Amount not */
  not?: InputMaybe<Scalars['Float']['input']>;
  /** Amount not in the list */
  notIn?: InputMaybe<Array<Scalars['Float']['input']>>;
};

/** Selector of index of argument in call */
export type BitqueryArgumentIndexSelector = {
  /** Tx index in the list */
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Tx index is */
  is?: InputMaybe<Scalars['Int']['input']>;
  /** Tx index not */
  not?: InputMaybe<Scalars['Int']['input']>;
  /** Tx index not in the list */
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** Argument of Smart contract method or event */
export type BitqueryArgumentName = {
  __typename?: 'BitqueryArgumentName';
  /** Name */
  name: Scalars['String']['output'];
  /** Type */
  type: Scalars['String']['output'];
};

/** Argument name and value of smart contract call or event */
export type BitqueryArgumentNameValue = {
  __typename?: 'BitqueryArgumentNameValue';
  /** Argument name */
  argument: Scalars['String']['output'];
  /** Argument data type */
  argumentType: Scalars['String']['output'];
  /** Sequential index of value in array ( multi-dimensional) */
  index: Scalars['String']['output'];
  /** Value as String */
  value: Scalars['String']['output'];
};

/** Selector of argument for smart contract method or event */
export type BitqueryArgumentSelector = {
  /** Argument in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Argument is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Argument not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Argument not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Selector of argument type for smart contract method or event */
export type BitqueryArgumentTypeSelector = {
  /** Argument type in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Argument type is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Argument type not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Argument type not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Argument value of smart contract call or event */
export type BitqueryArgumentValue = {
  __typename?: 'BitqueryArgumentValue';
  /** Value as Address */
  address?: Maybe<BitqueryEthereumAddressInfo>;
  /** Value as String */
  value: Scalars['String']['output'];
};

/** Selector of value of argument for smart contract method or event */
export type BitqueryArgumentValueSelector = {
  /** Value in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Value is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Value not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Value not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export enum BitqueryBaseCurrencyEnum {
  /** Binance Smart Chain */
  Bnb = 'BNB',
  /** Bitcoin */
  Btc = 'BTC',
  /** Ethereum */
  Eth = 'ETH',
  /** Dollar */
  Usd = 'USD',
  /** Tether USDT */
  Usdt = 'USDT'
}

/** Select by ID with BigInt datatype */
export type BitqueryBigIntIdSelector = {
  /** ID in range */
  between?: InputMaybe<Array<Scalars['BitqueryBigInt']['input']>>;
  /** ID greater than */
  gt?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  /** ID greater or equal than */
  gteq?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  /** ID in the list */
  in?: InputMaybe<Array<Scalars['BitqueryBigInt']['input']>>;
  /** ID is */
  is?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  /** ID less than */
  lt?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  /** ID less or equal than */
  lteq?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  /** ID not */
  not?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  /** ID not in the list */
  notIn?: InputMaybe<Array<Scalars['BitqueryBigInt']['input']>>;
};

/** Select by big number */
export type BitqueryBigIntegerSelector = {
  /** in range */
  between?: InputMaybe<Array<Scalars['BitqueryBigInt']['input']>>;
  /** greater than */
  gt?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  /** greater or equal than */
  gteq?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  /** in the list */
  in?: InputMaybe<Array<Scalars['BitqueryBigInt']['input']>>;
  /** is */
  is?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  /** less than */
  lt?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  /** less or equal than */
  lteq?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  /** not */
  not?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  /** not in the list */
  notIn?: InputMaybe<Array<Scalars['BitqueryBigInt']['input']>>;
};

/** Binance DEX */
export type BitqueryBinance = {
  __typename?: 'BitqueryBinance';
  /** Binance DEX Network Blocks */
  blocks?: Maybe<Array<BitqueryBinanceBlock>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryBinanceCoinpath>>;
  /** Binance DEX Network Exchange Orders */
  orders?: Maybe<Array<BitqueryBinanceOrders>>;
  /** Binance DEX Network Trades between currencies */
  trades?: Maybe<Array<BitqueryBinanceTrades>>;
  /** Binance DEX Network Transactions */
  transactions?: Maybe<Array<BitqueryBinanceTransactions>>;
  /** Binance DEX Network Currency Transfers */
  transfers?: Maybe<Array<BitqueryBinanceTransfers>>;
};


/** Binance DEX */
export type BitqueryBinanceBlocksArgs = {
  any?: InputMaybe<Array<BitqueryBinanceBlockFilter>>;
  blockId?: InputMaybe<BitqueryStringIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  validatorFeeAddr?: InputMaybe<BitqueryBinanceAddressSelector>;
  validatorMoniker?: InputMaybe<BitqueryStringIdSelector>;
  validatorOperahraddress?: InputMaybe<BitqueryBinanceAddressSelector>;
  validatorOperatorAddress?: InputMaybe<BitqueryBinanceAddressSelector>;
};


/** Binance DEX */
export type BitqueryBinanceCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryBinanceAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryBinanceAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCoinpathOptions>;
  receiver?: InputMaybe<BitqueryBinanceAddressSelector>;
  sender?: InputMaybe<BitqueryBinanceAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Binance DEX */
export type BitqueryBinanceOrdersArgs = {
  any?: InputMaybe<Array<BitqueryBinanceOrderFilter>>;
  baseAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  baseCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  orderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  orderOwner?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  orderSide?: InputMaybe<Array<BitqueryOrderSideSelector>>;
  orderStatus?: InputMaybe<Array<BitqueryOrderStatusSelector>>;
  orderTimeInForce?: InputMaybe<Array<BitqueryOrderTimeInForceSelector>>;
  orderType?: InputMaybe<Array<BitqueryOrderTypeSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Binance DEX */
export type BitqueryBinanceTradesArgs = {
  any?: InputMaybe<Array<BitqueryBinanceTradeFilter>>;
  baseAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  baseCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  buyOrderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  buyer?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  sellOrderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  seller?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeId?: InputMaybe<Array<BitqueryTradeIdSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Binance DEX */
export type BitqueryBinanceTransactionsArgs = {
  any?: InputMaybe<Array<BitqueryBinanceTransactionFilter>>;
  currency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  deposit?: InputMaybe<Array<BitqueryAmountSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  proposalId?: InputMaybe<BitqueryStringIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCode?: InputMaybe<BitqueryIntIdSelector>;
  transactionSource?: InputMaybe<BitqueryIntIdSelector>;
  transactionType?: InputMaybe<BitqueryBinanceTransactionTypeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Binance DEX */
export type BitqueryBinanceTransfersArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  any?: InputMaybe<Array<BitqueryBinanceTransferFilter>>;
  currency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  orderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  outputIndex?: InputMaybe<Array<BitqueryOutputIndexSelector>>;
  receiver?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeId?: InputMaybe<Array<BitqueryTradeIdSelector>>;
  transferType?: InputMaybe<Array<BitqueryBinanceTransferTypeSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};

/** Binance Address should start with bnb and contain 42 chars. */
export type BitqueryBinanceAddressSelector = {
  /** In the list of Addresses */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Equal to Address */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Not Equal to Address */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Not in the list of Addresses */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Binance Address should start with bnb and contain 42 chars. */
export type BitqueryBinanceAddressSelectorIn = {
  /** Equal to Address */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Not Equal to Address */
  not?: InputMaybe<Scalars['String']['input']>;
};

/** Block */
export type BitqueryBinanceBlock = {
  __typename?: 'BitqueryBinanceBlock';
  any?: Maybe<Scalars['String']['output']>;
  /** Block ID */
  blockId?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Block number (height) in blockchain */
  height: Scalars['Int']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Validator consensus pubkey */
  validatorConsensusPubkey?: Maybe<Scalars['String']['output']>;
  /** Validator fee address */
  validatorFeeAddr?: Maybe<BitqueryAddress>;
  /** Validator moniker */
  validatorMoniker?: Maybe<Scalars['String']['output']>;
  /** Validator operator HR address */
  validatorOperaHrAddress?: Maybe<BitqueryAddress>;
  /** Validator operator address */
  validatorOperatorAddress?: Maybe<BitqueryAddress>;
};


/** Block */
export type BitqueryBinanceBlockAnyArgs = {
  of: BitqueryBinanceBlocksMeasureable;
};


/** Block */
export type BitqueryBinanceBlockBlockIdArgs = {
  blockId?: InputMaybe<BitqueryStringIdSelector>;
};


/** Block */
export type BitqueryBinanceBlockCountArgs = {
  blockId?: InputMaybe<BitqueryStringIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryBinanceBlockUniq>;
  validatorFeeAddr?: InputMaybe<BitqueryBinanceAddressSelector>;
  validatorMoniker?: InputMaybe<BitqueryStringIdSelector>;
  validatorOperahraddress?: InputMaybe<BitqueryBinanceAddressSelector>;
  validatorOperatorAddress?: InputMaybe<BitqueryBinanceAddressSelector>;
};


/** Block */
export type BitqueryBinanceBlockCountBigIntArgs = {
  blockId?: InputMaybe<BitqueryStringIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryBinanceBlockUniq>;
  validatorFeeAddr?: InputMaybe<BitqueryBinanceAddressSelector>;
  validatorMoniker?: InputMaybe<BitqueryStringIdSelector>;
  validatorOperahraddress?: InputMaybe<BitqueryBinanceAddressSelector>;
  validatorOperatorAddress?: InputMaybe<BitqueryBinanceAddressSelector>;
};


/** Block */
export type BitqueryBinanceBlockExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Block */
export type BitqueryBinanceBlockHeightArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Block */
export type BitqueryBinanceBlockMaximumArgs = {
  get?: InputMaybe<BitqueryBinanceBlocksMeasureable>;
  of: BitqueryBinanceBlocksMeasureable;
};


/** Block */
export type BitqueryBinanceBlockMinimumArgs = {
  get?: InputMaybe<BitqueryBinanceBlocksMeasureable>;
  of: BitqueryBinanceBlocksMeasureable;
};


/** Block */
export type BitqueryBinanceBlockTimestampArgs = {
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Block */
export type BitqueryBinanceBlockValidatorConsensusPubkeyArgs = {
  validatorConsensusPubkey?: InputMaybe<BitqueryStringIdSelector>;
};


/** Block */
export type BitqueryBinanceBlockValidatorFeeAddrArgs = {
  validatorFeeAddr?: InputMaybe<BitqueryBinanceAddressSelector>;
};


/** Block */
export type BitqueryBinanceBlockValidatorMonikerArgs = {
  validatorMoniker?: InputMaybe<BitqueryStringIdSelector>;
};


/** Block */
export type BitqueryBinanceBlockValidatorOperaHrAddressArgs = {
  validatorOperaHrAddress?: InputMaybe<BitqueryBinanceAddressSelector>;
};


/** Block */
export type BitqueryBinanceBlockValidatorOperatorAddressArgs = {
  validatorOperatorAddress?: InputMaybe<BitqueryBinanceAddressSelector>;
};

export type BitqueryBinanceBlockFilter = {
  blockId?: InputMaybe<BitqueryStringIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  validatorFeeAddr?: InputMaybe<BitqueryBinanceAddressSelector>;
  validatorMoniker?: InputMaybe<BitqueryStringIdSelector>;
  validatorOperahraddress?: InputMaybe<BitqueryBinanceAddressSelector>;
  validatorOperatorAddress?: InputMaybe<BitqueryBinanceAddressSelector>;
};

export enum BitqueryBinanceBlockUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Validator fee addresses */
  ValidatorFeeAddresses = 'validator_fee_addresses',
  /** Validator operators */
  ValidatorOperatorAddresses = 'validator_operator_addresses'
}

export enum BitqueryBinanceBlocksMeasureable {
  /** Block */
  Block = 'block',
  /** Block hash */
  BlockHash = 'block_hash',
  /** Date */
  Date = 'date',
  /** Time */
  Time = 'time',
  /** Validator moniker */
  ValidatorMoniker = 'validator_moniker'
}

/** Coinpath */
export type BitqueryBinanceCoinpath = {
  __typename?: 'BitqueryBinanceCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryBinanceCoinpathAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryBinanceCoinpathAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<BitqueryTransactionHashValueTime>;
};


/** Coinpath */
export type BitqueryBinanceCoinpathAmountArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Coinpath */
export type BitqueryBinanceCoinpathAnyArgs = {
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryBinanceCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryBinanceCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};

/** Address detailed information for Binance network */
export type BitqueryBinanceCoinpathAddress = {
  __typename?: 'BitqueryBinanceCoinpathAddress';
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  amountIn?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  amountOut?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  balance?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Smart Contract if exists on the address */
  firstTxAt?: Maybe<BitqueryDateTime>;
  /** Smart Contract if exists on the address */
  lastTxAt?: Maybe<BitqueryDateTime>;
  receiversCount?: Maybe<Scalars['Int']['output']>;
  sendersCount?: Maybe<Scalars['Int']['output']>;
  /** Address type */
  type?: Maybe<Scalars['String']['output']>;
};

/**
 * Binance token selector by tokenId.
 *     Native binance token has BNB symbol.
 *     Note that most Binance symbols has two dash separated parts, for example: 'TROY-9B8_BNB'
 */
export type BitqueryBinanceCurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Currency not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type BitqueryBinanceOrderFilter = {
  baseAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  baseCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  orderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  orderOwner?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  orderSide?: InputMaybe<Array<BitqueryOrderSideSelector>>;
  orderStatus?: InputMaybe<Array<BitqueryOrderStatusSelector>>;
  orderTimeInForce?: InputMaybe<Array<BitqueryOrderTimeInForceSelector>>;
  orderType?: InputMaybe<Array<BitqueryOrderTypeSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};

export enum BitqueryBinanceOrderSide {
  /** Buy Side */
  Buy = 'buy',
  /** Sell Side */
  Sell = 'sell'
}

export enum BitqueryBinanceOrderStatus {
  /** Ack */
  Ack = 'Ack',
  /** Canceled */
  Canceled = 'Canceled',
  /** Expired */
  Expired = 'Expired',
  /** Failed Blocking */
  FailedBlocking = 'FailedBlocking',
  /** Fully Fill */
  FullyFill = 'FullyFill',
  /** Ioc Expire */
  IocExpire = 'IocExpire',
  /** Ioc No Fill */
  IocNoFill = 'IocNoFill',
  /** Partial Fill */
  PartialFill = 'PartialFill'
}

export enum BitqueryBinanceOrderTimeInForce {
  /** Good Till Expiry */
  Gte = 'GTE',
  /** Immediate Or Cancel */
  Ioc = 'IOC'
}

export enum BitqueryBinanceOrderType {
  /** Limit Order */
  LimitOrder = 'LimitOrder'
}

/** Binance DEX Order */
export type BitqueryBinanceOrders = {
  __typename?: 'BitqueryBinanceOrders';
  any?: Maybe<Scalars['String']['output']>;
  baseAmount?: Maybe<Scalars['Float']['output']>;
  baseCurrency?: Maybe<BitqueryCurrency>;
  /** Block where order transaction is included */
  block?: Maybe<BitqueryBlock>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Order ID */
  orderId?: Maybe<Scalars['String']['output']>;
  /** Order owner address */
  orderOwner?: Maybe<BitqueryAddress>;
  /** Order Side */
  orderSide?: Maybe<BitqueryBinanceOrderSide>;
  /** Order Status */
  orderStatus?: Maybe<BitqueryBinanceOrderStatus>;
  /** Order Time In Force */
  orderTimeInForce?: Maybe<BitqueryBinanceOrderTimeInForce>;
  /** Order Type */
  orderType?: Maybe<BitqueryBinanceOrderType>;
  price?: Maybe<Scalars['Float']['output']>;
  quoteAmount?: Maybe<Scalars['Float']['output']>;
  quoteCurrency?: Maybe<BitqueryCurrency>;
  /** Transaction where order created */
  transaction?: Maybe<BitqueryTransactionHash>;
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersAnyArgs = {
  of: BitqueryBinanceOrdersMeasureable;
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersBaseAmountArgs = {
  baseAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  baseCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  orderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  orderOwner?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  orderSide?: InputMaybe<Array<BitqueryOrderSideSelector>>;
  orderStatus?: InputMaybe<Array<BitqueryOrderStatusSelector>>;
  orderTimeInForce?: InputMaybe<Array<BitqueryOrderTimeInForceSelector>>;
  orderType?: InputMaybe<Array<BitqueryOrderTypeSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersBaseCurrencyArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersCountArgs = {
  baseAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  baseCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  orderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  orderOwner?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  orderSide?: InputMaybe<Array<BitqueryOrderSideSelector>>;
  orderStatus?: InputMaybe<Array<BitqueryOrderStatusSelector>>;
  orderTimeInForce?: InputMaybe<Array<BitqueryOrderTimeInForceSelector>>;
  orderType?: InputMaybe<Array<BitqueryOrderTypeSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryBinanceOrdersUniq>;
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersCountBigIntArgs = {
  baseAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  baseCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  orderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  orderOwner?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  orderSide?: InputMaybe<Array<BitqueryOrderSideSelector>>;
  orderStatus?: InputMaybe<Array<BitqueryOrderStatusSelector>>;
  orderTimeInForce?: InputMaybe<Array<BitqueryOrderTimeInForceSelector>>;
  orderType?: InputMaybe<Array<BitqueryOrderTypeSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryBinanceOrdersUniq>;
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersMaximumArgs = {
  get?: InputMaybe<BitqueryBinanceOrdersMeasureable>;
  of: BitqueryBinanceOrdersMeasureable;
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersMinimumArgs = {
  get?: InputMaybe<BitqueryBinanceOrdersMeasureable>;
  of: BitqueryBinanceOrdersMeasureable;
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersOrderIdArgs = {
  orderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersOrderOwnerArgs = {
  owner?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersOrderSideArgs = {
  orderSide?: InputMaybe<Array<BitqueryOrderSideSelector>>;
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersOrderStatusArgs = {
  orderStatus?: InputMaybe<Array<BitqueryOrderStatusSelector>>;
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersOrderTimeInForceArgs = {
  orderTimeInForce?: InputMaybe<Array<BitqueryOrderTimeInForceSelector>>;
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersOrderTypeArgs = {
  orderType?: InputMaybe<Array<BitqueryOrderTypeSelector>>;
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersQuoteAmountArgs = {
  baseAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  baseCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  orderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  orderOwner?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  orderSide?: InputMaybe<Array<BitqueryOrderSideSelector>>;
  orderStatus?: InputMaybe<Array<BitqueryOrderStatusSelector>>;
  orderTimeInForce?: InputMaybe<Array<BitqueryOrderTimeInForceSelector>>;
  orderType?: InputMaybe<Array<BitqueryOrderTypeSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersQuoteCurrencyArgs = {
  quoteCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersTransactionArgs = {
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};

export enum BitqueryBinanceOrdersMeasureable {
  /** Base Amount */
  BaseAmount = 'base_amount',
  /** Base currency */
  BaseCurrency = 'base_currency',
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Order ID */
  OrderId = 'order_id',
  /** Order owner */
  OrderOwner = 'order_owner',
  /** Order side */
  OrderSide = 'order_side',
  /** Order status */
  OrderStatus = 'order_status',
  /** Price */
  Price = 'price',
  /** Quote Amount */
  QuoteAmount = 'quote_amount',
  /** Quote currency */
  QuoteCurrency = 'quote_currency',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

export enum BitqueryBinanceOrdersUniq {
  /** Unique base currencies */
  BaseCurrencies = 'base_currencies',
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates',
  /** Unique order ID count */
  Orders = 'orders',
  /** Unique order owners */
  Owners = 'owners',
  /** Unique quote currencies */
  QuoteCurrencies = 'quote_currencies',
  /** Unique Transactions */
  Txs = 'txs'
}

export type BitqueryBinanceTradeFilter = {
  baseAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  baseCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  buyOrderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  buyer?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  sellOrderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  seller?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeId?: InputMaybe<Array<BitqueryTradeIdSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};

/** Binance DEX Trades */
export type BitqueryBinanceTrades = {
  __typename?: 'BitqueryBinanceTrades';
  any?: Maybe<Scalars['String']['output']>;
  baseAmount?: Maybe<Scalars['Float']['output']>;
  baseCurrency?: Maybe<BitqueryCurrency>;
  /** Block where trade transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Buy Order ID */
  buyOrderId?: Maybe<Scalars['String']['output']>;
  /** Trade buyer address */
  buyer?: Maybe<BitqueryAddress>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  price?: Maybe<Scalars['Float']['output']>;
  quoteAmount?: Maybe<Scalars['Float']['output']>;
  quoteCurrency?: Maybe<BitqueryCurrency>;
  /** Sell Order ID */
  sellOrderId?: Maybe<Scalars['String']['output']>;
  /** Trade seller address */
  seller?: Maybe<BitqueryAddress>;
  /** Trade ID */
  tradeId?: Maybe<Scalars['String']['output']>;
  /** Transaction where trade happened */
  transaction?: Maybe<BitqueryTransactionHashIndex>;
};


/** Binance DEX Trades */
export type BitqueryBinanceTradesAnyArgs = {
  of: BitqueryBinanceTradesMeasureable;
};


/** Binance DEX Trades */
export type BitqueryBinanceTradesBaseAmountArgs = {
  baseAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  baseCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  buyOrderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  buyer?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  sellOrderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  seller?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeId?: InputMaybe<Array<BitqueryTradeIdSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Binance DEX Trades */
export type BitqueryBinanceTradesBaseCurrencyArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
};


/** Binance DEX Trades */
export type BitqueryBinanceTradesBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Binance DEX Trades */
export type BitqueryBinanceTradesBuyOrderIdArgs = {
  buyOrderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
};


/** Binance DEX Trades */
export type BitqueryBinanceTradesBuyerArgs = {
  buyer?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
};


/** Binance DEX Trades */
export type BitqueryBinanceTradesCountArgs = {
  baseAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  baseCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  buyOrderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  buyer?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  sellOrderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  seller?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeId?: InputMaybe<Array<BitqueryTradeIdSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryBinanceTradesUniq>;
};


/** Binance DEX Trades */
export type BitqueryBinanceTradesCountBigIntArgs = {
  baseAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  baseCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  buyOrderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  buyer?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  sellOrderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  seller?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeId?: InputMaybe<Array<BitqueryTradeIdSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryBinanceTradesUniq>;
};


/** Binance DEX Trades */
export type BitqueryBinanceTradesExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Binance DEX Trades */
export type BitqueryBinanceTradesMaximumArgs = {
  get?: InputMaybe<BitqueryBinanceTradesMeasureable>;
  of: BitqueryBinanceTradesMeasureable;
};


/** Binance DEX Trades */
export type BitqueryBinanceTradesMinimumArgs = {
  get?: InputMaybe<BitqueryBinanceTradesMeasureable>;
  of: BitqueryBinanceTradesMeasureable;
};


/** Binance DEX Trades */
export type BitqueryBinanceTradesQuoteAmountArgs = {
  baseAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  baseCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  buyOrderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  buyer?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  sellOrderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  seller?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeId?: InputMaybe<Array<BitqueryTradeIdSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Binance DEX Trades */
export type BitqueryBinanceTradesQuoteCurrencyArgs = {
  quoteCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
};


/** Binance DEX Trades */
export type BitqueryBinanceTradesSellOrderIdArgs = {
  sellOrderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
};


/** Binance DEX Trades */
export type BitqueryBinanceTradesSellerArgs = {
  seller?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
};


/** Binance DEX Trades */
export type BitqueryBinanceTradesTradeIdArgs = {
  tradeId?: InputMaybe<Array<BitqueryTradeIdSelector>>;
};


/** Binance DEX Trades */
export type BitqueryBinanceTradesTransactionArgs = {
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};

export enum BitqueryBinanceTradesMeasureable {
  /** Base Amount */
  BaseAmount = 'base_amount',
  /** Base currency */
  BaseCurrency = 'base_currency',
  /** Block */
  Block = 'block',
  /** Buy Order ID */
  BuyOrderId = 'buy_order_id',
  /** Buyer */
  Buyer = 'buyer',
  /** Date */
  Date = 'date',
  /** Price */
  Price = 'price',
  /** Quote Amount */
  QuoteAmount = 'quote_amount',
  /** Quote currency */
  QuoteCurrency = 'quote_currency',
  /** Sell Order ID */
  SellOrderId = 'sell_order_id',
  /** Seller */
  Seller = 'seller',
  /** Time */
  Time = 'time',
  /** Trade ID */
  TradeId = 'trade_id',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

export enum BitqueryBinanceTradesUniq {
  /** Unique base currencies */
  BaseCurrencies = 'base_currencies',
  /** Unique blocks */
  Blocks = 'blocks',
  /** Buy Orders */
  BuyOrders = 'buy_orders',
  /** Unique buyers count */
  Buyers = 'buyers',
  /** Unique date count */
  Dates = 'dates',
  /** Unique quote currencies */
  QuoteCurrencies = 'quote_currencies',
  /** Sell Orders */
  SellOrders = 'sell_orders',
  /** Unique sellers count */
  Sellers = 'sellers',
  /** Trades */
  Trades = 'trades',
  /** Unique Transactions */
  Txs = 'txs'
}

export type BitqueryBinanceTransactionFilter = {
  currency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  deposit?: InputMaybe<Array<BitqueryAmountSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  proposalId?: InputMaybe<BitqueryStringIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCode?: InputMaybe<BitqueryIntIdSelector>;
  transactionSource?: InputMaybe<BitqueryIntIdSelector>;
  transactionType?: InputMaybe<BitqueryBinanceTransactionTypeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};

export enum BitqueryBinanceTransactionType {
  /** Bind */
  Bind = 'BIND',
  /** Submit evidence */
  BscSubmitEvidence = 'BSC_SUBMIT_EVIDENCE',
  /** Burn */
  Burn = 'BURN',
  /** Cancel Order */
  CancelOrder = 'CANCEL_ORDER',
  /** Cross chain claim */
  Claim = 'CLAIM',
  /** Hash Timer Locked Claim */
  ClaimHtl = 'CLAIM_HTL',
  /** Create sidechain validator */
  CreateSidechainValidator = 'CREATE_SIDECHAIN_VALIDATOR',
  /** Deposit */
  Deposit = 'DEPOSIT',
  /** Hash Timer Locked Deposit */
  DepositHtl = 'DEPOSIT_HTL',
  /** Edit sidechain validator */
  EditSidechainValidator = 'EDIT_SIDECHAIN_VALIDATOR',
  /** Freeze Token */
  FreezeToken = 'FREEZE_TOKEN',
  /** Hash Timer Locked Transfer */
  HtlTransfer = 'HTL_TRANSFER',
  /** Issue */
  Issue = 'ISSUE',
  /** Listing */
  Listing = 'LISTING',
  /** Mini Token Issue */
  MiniTokenIssue = 'MINI_TOKEN_ISSUE',
  /** Mini Token Listing */
  MiniTokenList = 'MINI_TOKEN_LIST',
  /** Mini Token Set URI */
  MiniTokenSetUri = 'MINI_TOKEN_SET_URI',
  /** Mint */
  Mint = 'MINT',
  /** New Order */
  NewOrder = 'NEW_ORDER',
  /** Hash Timer Locked  Refund */
  RefundHtl = 'REFUND_HTL',
  /** Delegate for sidechain */
  SidechainDelegate = 'SIDECHAIN_DELEGATE',
  /** ReDelegate for sidechain */
  SidechainRedelegate = 'SIDECHAIN_REDELEGATE',
  /** Unbond from sidechain */
  SidechainUnbond = 'SIDECHAIN_UNBOND',
  /** Unjail from sidechain */
  SidechainUnjail = 'SIDECHAIN_UNJAIL',
  /** Side chain deposit */
  SideDeposit = 'SIDE_DEPOSIT',
  /** Side chain submit poroposal */
  SideSubmitProposal = 'SIDE_SUBMIT_PROPOSAL',
  /** Side chain vote */
  SideVote = 'SIDE_VOTE',
  /** Submit Proposal */
  SubmitProposal = 'SUBMIT_PROPOSAL',
  /** Set Account Flag */
  SetAccountFlag = 'SetAccountFlag',
  /** Tiny Token Issue */
  TinyTokenIssue = 'TINY_TOKEN_ISSUE',
  /** Tiny Token Listing */
  TinyTokenList = 'TINY_TOKEN_LIST',
  /** Tiny Token Set URI */
  TinyTokenSetUri = 'TINY_TOKEN_SET_URI',
  /** Transfer */
  Transfer = 'TRANSFER',
  /** Cross chain transfer */
  TransferOut = 'TRANSFER_OUT',
  /** Time Lock */
  TimeLock = 'TimeLock',
  /** Time Relock */
  TimeRelock = 'TimeRelock',
  /** Time Unlock */
  TimeUnlock = 'TimeUnlock',
  /** UnBind */
  Unbind = 'UNBIND',
  /** Unfreeze Token */
  UnfreezeToken = 'UNFREEZE_TOKEN',
  /** Vote */
  Vote = 'VOTE'
}

/** Select by transaction type */
export type BitqueryBinanceTransactionTypeSelector = {
  /** Transaction Type in the list */
  in?: InputMaybe<Array<BitqueryBinanceTransactionType>>;
  /** Transaction Type is */
  is?: InputMaybe<BitqueryBinanceTransactionType>;
  /** Transaction Type not */
  not?: InputMaybe<BitqueryBinanceTransactionType>;
  /** Transaction Type not in the list */
  notIn?: InputMaybe<Array<BitqueryBinanceTransactionType>>;
};

/** Transaction */
export type BitqueryBinanceTransactions = {
  __typename?: 'BitqueryBinanceTransactions';
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency issued in transaction */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Deposit amount in transaction */
  deposit?: Maybe<Scalars['Float']['output']>;
  /** Transaction Description */
  description?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** TX index in block, 0 based */
  index?: Maybe<Scalars['Int']['output']>;
  /** Transaction Log */
  log?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Transaction Memo */
  memo?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Proposal ID */
  proposalId?: Maybe<Scalars['Int']['output']>;
  /** Transaction Type */
  transactionCode?: Maybe<Scalars['Int']['output']>;
  /** Transaction Source */
  transactionSource?: Maybe<BitqueryTransactionSource>;
  /** Transaction Type */
  transactionType?: Maybe<BitqueryBinanceTransactionType>;
};


/** Transaction */
export type BitqueryBinanceTransactionsAnyArgs = {
  of: BitqueryBinanceTransactionsMeasureable;
};


/** Transaction */
export type BitqueryBinanceTransactionsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transaction */
export type BitqueryBinanceTransactionsCountArgs = {
  currency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  deposit?: InputMaybe<Array<BitqueryAmountSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  proposalId?: InputMaybe<BitqueryStringIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCode?: InputMaybe<BitqueryIntIdSelector>;
  transactionSource?: InputMaybe<BitqueryIntIdSelector>;
  transactionType?: InputMaybe<BitqueryBinanceTransactionTypeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryBinanceTransactionsUniq>;
};


/** Transaction */
export type BitqueryBinanceTransactionsCountBigIntArgs = {
  currency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  deposit?: InputMaybe<Array<BitqueryAmountSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  proposalId?: InputMaybe<BitqueryStringIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCode?: InputMaybe<BitqueryIntIdSelector>;
  transactionSource?: InputMaybe<BitqueryIntIdSelector>;
  transactionType?: InputMaybe<BitqueryBinanceTransactionTypeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryBinanceTransactionsUniq>;
};


/** Transaction */
export type BitqueryBinanceTransactionsCurrencyArgs = {
  currency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
};


/** Transaction */
export type BitqueryBinanceTransactionsDepositArgs = {
  deposit?: InputMaybe<Array<BitqueryAmountSelector>>;
};


/** Transaction */
export type BitqueryBinanceTransactionsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transaction */
export type BitqueryBinanceTransactionsHashArgs = {
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Transaction */
export type BitqueryBinanceTransactionsMaximumArgs = {
  get?: InputMaybe<BitqueryBinanceTransactionsMeasureable>;
  of: BitqueryBinanceTransactionsMeasureable;
};


/** Transaction */
export type BitqueryBinanceTransactionsMinimumArgs = {
  get?: InputMaybe<BitqueryBinanceTransactionsMeasureable>;
  of: BitqueryBinanceTransactionsMeasureable;
};


/** Transaction */
export type BitqueryBinanceTransactionsProposalIdArgs = {
  proposalId?: InputMaybe<Array<BitqueryIntIdSelector>>;
};


/** Transaction */
export type BitqueryBinanceTransactionsTransactionCodeArgs = {
  transactionCode?: InputMaybe<BitqueryIntIdSelector>;
};


/** Transaction */
export type BitqueryBinanceTransactionsTransactionSourceArgs = {
  transactionSource?: InputMaybe<BitqueryIntIdSelector>;
};


/** Transaction */
export type BitqueryBinanceTransactionsTransactionTypeArgs = {
  transactionType?: InputMaybe<Array<BitqueryBinanceTransactionTypeSelector>>;
};

export enum BitqueryBinanceTransactionsMeasureable {
  /** Block */
  Block = 'block',
  /** Currency */
  CurrencySymbol = 'currency_symbol',
  /** Date */
  Date = 'date',
  /** Time */
  Time = 'time',
  /** Transaction Code */
  TransactionCode = 'transaction_code',
  /** Transaction Memo */
  TransactionMemo = 'transaction_memo',
  /** Transaction Source Code */
  TransactionSourceCode = 'transaction_source_code',
  /** Transaction Source Name */
  TransactionSourceName = 'transaction_source_name',
  /** Transaction Type */
  TransactionType = 'transaction_type',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

export enum BitqueryBinanceTransactionsUniq {
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates',
  /** Unique transaction source count */
  TransactionSources = 'transaction_sources'
}

export type BitqueryBinanceTransferFilter = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  orderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  outputIndex?: InputMaybe<Array<BitqueryOutputIndexSelector>>;
  receiver?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeId?: InputMaybe<Array<BitqueryTradeIdSelector>>;
  transferType?: InputMaybe<Array<BitqueryBinanceTransferTypeSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};

export enum BitqueryBinanceTransferType {
  /** Bind */
  Bind = 'BIND',
  /** Reward for block */
  BlockReward = 'BLOCK_REWARD',
  /** Submit evidence */
  BscSubmitEvidence = 'BSC_SUBMIT_EVIDENCE',
  /** Burning amount */
  Burn = 'BURN',
  /** Cross chain claim */
  Claim = 'CLAIM',
  /** Claiming Hash Timer Locked Transfer */
  ClaimHtl = 'CLAIM_HTL',
  /** Create sidechain validator */
  CreateSidechainValidator = 'CREATE_SIDECHAIN_VALIDATOR',
  /** Deposit for Hash Timer Locked Transfer */
  DepositHtl = 'DEPOSIT_HTL',
  /** Fee for DEX orders */
  DexFee = 'DEX_FEE',
  /** Edit sidechain validator */
  EditSidechainValidator = 'EDIT_SIDECHAIN_VALIDATOR',
  /** Genesis declaration */
  GenesisDelegation = 'GENESIS_DELEGATION',
  /** Genesis supply declaration */
  GenesisSupply = 'GENESIS_SUPPLY',
  /** Hash Timer Locked Transfer */
  HtlTransfer = 'HTL_TRANSFER',
  /** Issue token */
  Issue = 'ISSUE',
  /** Mini Token Issue */
  MiniTokenIssue = 'MINI_TOKEN_ISSUE',
  /** Mint token */
  Mint = 'MINT',
  /** Delegate for sidechain */
  SidechainDelegate = 'SIDECHAIN_DELEGATE',
  /** ReDelegate for sidechain */
  SidechainRedelegate = 'SIDECHAIN_REDELEGATE',
  /** Unbond from sidechain */
  SidechainUnbond = 'SIDECHAIN_UNBOND',
  /** Side chain deposit */
  SideDeposit = 'SIDE_DEPOSIT',
  /** Side chain submit poroposal */
  SideSubmitProposal = 'SIDE_SUBMIT_PROPOSAL',
  /** Side chain vote */
  SideVote = 'SIDE_VOTE',
  /** Tiny Token Issue */
  TinyTokenIssue = 'TINY_TOKEN_ISSUE',
  /** Trade buy side */
  TradeBuy = 'TRADE_BUY',
  /** Trade sell side */
  TradeSell = 'TRADE_SELL',
  /** Transfer */
  Transfer = 'TRANSFER',
  /** Cross chain transfer */
  TransferOut = 'TRANSFER_OUT',
  /** Transaction fee */
  TxFee = 'TX_FEE',
  /** UnBind */
  Unbind = 'UNBIND'
}

/** Select transfer type(s) */
export type BitqueryBinanceTransferTypeSelector = {
  /** Transfer type in the list */
  in?: InputMaybe<Array<BitqueryBinanceTransferType>>;
  /** Transfer type is */
  is?: InputMaybe<BitqueryBinanceTransferType>;
  /** Transfer type not */
  not?: InputMaybe<BitqueryBinanceTransferType>;
  /** Transfer type not in the list */
  notIn?: InputMaybe<Array<BitqueryBinanceTransferType>>;
};

/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryBinanceTransfers = {
  __typename?: 'BitqueryBinanceTransfers';
  /** Transfer amount */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Transfer count */
  count?: Maybe<Scalars['Int']['output']>;
  /** Transfer count */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Order Id of trade where transfer happened */
  orderId?: Maybe<Scalars['String']['output']>;
  /** Index of the output for the transfer, 0-based */
  outputIndex?: Maybe<Scalars['Int']['output']>;
  /** Transfer receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Transfer sender */
  sender?: Maybe<BitqueryAddress>;
  /** Id of trade where transfer happened */
  tradeId?: Maybe<Scalars['String']['output']>;
  /** Transaction where transfer happened */
  transaction?: Maybe<BitqueryTransactionHashIndex>;
  /** Transfer type */
  transferType?: Maybe<BitqueryBinanceTransferType>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryBinanceTransfersAmountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  orderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  outputIndex?: InputMaybe<Array<BitqueryOutputIndexSelector>>;
  receiver?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeId?: InputMaybe<Array<BitqueryTradeIdSelector>>;
  transferType?: InputMaybe<Array<BitqueryBinanceTransferTypeSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryBinanceTransfersAnyArgs = {
  of: BitqueryBinanceTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryBinanceTransfersBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryBinanceTransfersCountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  orderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  outputIndex?: InputMaybe<Array<BitqueryOutputIndexSelector>>;
  receiver?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeId?: InputMaybe<Array<BitqueryTradeIdSelector>>;
  transferType?: InputMaybe<Array<BitqueryBinanceTransferTypeSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryTransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryBinanceTransfersCountBigIntArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  orderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  outputIndex?: InputMaybe<Array<BitqueryOutputIndexSelector>>;
  receiver?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeId?: InputMaybe<Array<BitqueryTradeIdSelector>>;
  transferType?: InputMaybe<Array<BitqueryBinanceTransferTypeSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryTransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryBinanceTransfersCurrencyArgs = {
  currency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryBinanceTransfersExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryBinanceTransfersMaximumArgs = {
  get?: InputMaybe<BitqueryBinanceTransfersMeasureable>;
  of: BitqueryBinanceTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryBinanceTransfersMinimumArgs = {
  get?: InputMaybe<BitqueryBinanceTransfersMeasureable>;
  of: BitqueryBinanceTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryBinanceTransfersOrderIdArgs = {
  orderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryBinanceTransfersOutputIndexArgs = {
  outputIndex?: InputMaybe<Array<BitqueryOutputIndexSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryBinanceTransfersReceiverArgs = {
  receiver?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryBinanceTransfersSenderArgs = {
  sender?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryBinanceTransfersTradeIdArgs = {
  tradeId?: InputMaybe<Array<BitqueryTradeIdSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryBinanceTransfersTransactionArgs = {
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryBinanceTransfersTransferTypeArgs = {
  transferType?: InputMaybe<Array<BitqueryBinanceTransferTypeSelector>>;
};

export enum BitqueryBinanceTransfersMeasureable {
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Currency symbol */
  CurrencySymbol = 'currency_symbol',
  /** Date */
  Date = 'date',
  /** Receiver */
  Receiver = 'receiver',
  /** Sender */
  Sender = 'sender',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

/** Bitcoin and other UTXO type blockchains */
export type BitqueryBitcoin = {
  __typename?: 'BitqueryBitcoin';
  /** Blockchain Address Statistics */
  addressStats?: Maybe<Array<BitqueryBitcoinAddressStats>>;
  /** Blockchain Blocks */
  blocks?: Maybe<Array<BitqueryBitcoinBlock>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryBitcoinCoinpath>>;
  /** Blockchain Transaction Inputs */
  inputs?: Maybe<Array<BitqueryBitcoinTransactionInput>>;
  /** Blockchain Transaction OmniTransactions */
  omniTransactions?: Maybe<Array<BitqueryBitcoinOmniTransactiosn>>;
  /** Blockchain Transaction OmniTransfers */
  omniTransfers?: Maybe<Array<BitqueryBitcoinOmniTransfers>>;
  /** Blockchain Transaction Outputs */
  outputs?: Maybe<Array<BitqueryBitcoinTransactionOutput>>;
  /** Blockchain Transactions */
  transactions?: Maybe<Array<BitqueryBitcoinTransaction>>;
};


/** Bitcoin and other UTXO type blockchains */
export type BitqueryBitcoinAddressStatsArgs = {
  address: BitqueryAddressSelector;
  options?: InputMaybe<BitqueryQueryOptions>;
};


/** Bitcoin and other UTXO type blockchains */
export type BitqueryBitcoinBlocksArgs = {
  any?: InputMaybe<Array<BitqueryBitcoinBlockFilter>>;
  blockHash?: InputMaybe<BitqueryStringIdSelector>;
  blockSize?: InputMaybe<BitqueryIntegerSelector>;
  blockStrippedSize?: InputMaybe<BitqueryIntegerSelector>;
  blockVersion?: InputMaybe<BitqueryIntegerSelector>;
  blockWeight?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  difficulty?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
};


/** Bitcoin and other UTXO type blockchains */
export type BitqueryBitcoinCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryBitcoinCoinpathOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Bitcoin and other UTXO type blockchains */
export type BitqueryBitcoinInputsArgs = {
  any?: InputMaybe<Array<BitqueryBitcoinInputFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inOutputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inOutputTxId?: InputMaybe<BitqueryHashSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inputScriptType?: InputMaybe<BitqueryStringSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Bitcoin and other UTXO type blockchains */
export type BitqueryBitcoinOmniTransactionsArgs = {
  any?: InputMaybe<Array<BitqueryBitcoinOmniTransactionsFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  invalidReason?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  typeId?: InputMaybe<BitqueryIntegerSelector>;
  valid?: InputMaybe<BitqueryIntegerSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Bitcoin and other UTXO type blockchains */
export type BitqueryBitcoinOmniTransfersArgs = {
  any?: InputMaybe<Array<BitqueryBitcoinOmniTransfersFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  invalidReason?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  typeId?: InputMaybe<BitqueryIntegerSelector>;
  valid?: InputMaybe<BitqueryIntegerSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Bitcoin and other UTXO type blockchains */
export type BitqueryBitcoinOutputsArgs = {
  any?: InputMaybe<Array<BitqueryBitcoinOutputFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputDirection?: InputMaybe<BitqueryBitcoinOutputDirectionSelector>;
  outputIndex?: InputMaybe<BitqueryIntegerSelector>;
  outputScriptType?: InputMaybe<BitqueryStringSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Bitcoin and other UTXO type blockchains */
export type BitqueryBitcoinTransactionsArgs = {
  any?: InputMaybe<Array<BitqueryBitcoinTransactionFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  minedValue?: InputMaybe<BitqueryFloatSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']['input']>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txLocktime?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  txVersion?: InputMaybe<BitqueryIntegerSelector>;
  txVsize?: InputMaybe<BitqueryIntegerSelector>;
  txWeight?: InputMaybe<BitqueryIntegerSelector>;
};

/** AddressStat */
export type BitqueryBitcoinAddressStats = {
  __typename?: 'BitqueryBitcoinAddressStats';
  /** Address With Statistics */
  address?: Maybe<BitqueryAddressStatDimension>;
};

/** Block */
export type BitqueryBitcoinBlock = {
  __typename?: 'BitqueryBitcoinBlock';
  any?: Maybe<Scalars['String']['output']>;
  /** Block Hash */
  blockHash?: Maybe<Scalars['String']['output']>;
  /** Block size */
  blockSize?: Maybe<Scalars['Int']['output']>;
  /** Block size */
  blockSizeBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Block stripped size */
  blockStrippedSize?: Maybe<Scalars['Int']['output']>;
  /** Block version */
  blockVersion?: Maybe<Scalars['Int']['output']>;
  /** Block weight */
  blockWeight?: Maybe<Scalars['Int']['output']>;
  /** Block chainwork */
  chainwork?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Difficulty */
  difficulty?: Maybe<Scalars['Float']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Block number (height) in blockchain */
  height: Scalars['Int']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  /** Block median timestamp */
  medianTime?: Maybe<BitqueryDateTime>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction count in block */
  transactionCount?: Maybe<Scalars['Int']['output']>;
};


/** Block */
export type BitqueryBitcoinBlockAnyArgs = {
  of: BitqueryBitcoinBlocksMeasureable;
};


/** Block */
export type BitqueryBitcoinBlockBlockHashArgs = {
  blockHash?: InputMaybe<BitqueryStringIdSelector>;
};


/** Block */
export type BitqueryBitcoinBlockBlockSizeArgs = {
  blockSize?: InputMaybe<BitqueryIntegerSelector>;
};


/** Block */
export type BitqueryBitcoinBlockBlockStrippedSizeArgs = {
  blockStrippedSize?: InputMaybe<BitqueryIntegerSelector>;
};


/** Block */
export type BitqueryBitcoinBlockBlockVersionArgs = {
  blockVersion?: InputMaybe<BitqueryIntegerSelector>;
};


/** Block */
export type BitqueryBitcoinBlockBlockWeightArgs = {
  blockWeight?: InputMaybe<BitqueryIntegerSelector>;
};


/** Block */
export type BitqueryBitcoinBlockCountArgs = {
  blockHash?: InputMaybe<BitqueryStringIdSelector>;
  blockSize?: InputMaybe<BitqueryIntegerSelector>;
  blockStrippedSize?: InputMaybe<BitqueryIntegerSelector>;
  blockVersion?: InputMaybe<BitqueryIntegerSelector>;
  blockWeight?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  difficulty?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCount?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryBitcoinBlockUniq>;
};


/** Block */
export type BitqueryBitcoinBlockCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryStringIdSelector>;
  blockSize?: InputMaybe<BitqueryIntegerSelector>;
  blockStrippedSize?: InputMaybe<BitqueryIntegerSelector>;
  blockVersion?: InputMaybe<BitqueryIntegerSelector>;
  blockWeight?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  difficulty?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCount?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryBitcoinBlockUniq>;
};


/** Block */
export type BitqueryBitcoinBlockDifficultyArgs = {
  difficulty?: InputMaybe<BitqueryFloatSelector>;
};


/** Block */
export type BitqueryBitcoinBlockExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Block */
export type BitqueryBitcoinBlockHeightArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Block */
export type BitqueryBitcoinBlockMaximumArgs = {
  get?: InputMaybe<BitqueryBitcoinBlocksMeasureable>;
  of: BitqueryBitcoinBlocksMeasureable;
};


/** Block */
export type BitqueryBitcoinBlockMinimumArgs = {
  get?: InputMaybe<BitqueryBitcoinBlocksMeasureable>;
  of: BitqueryBitcoinBlocksMeasureable;
};


/** Block */
export type BitqueryBitcoinBlockTimestampArgs = {
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Block */
export type BitqueryBitcoinBlockTransactionCountArgs = {
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryBitcoinBlockFilter = {
  blockHash?: InputMaybe<BitqueryStringIdSelector>;
  blockSize?: InputMaybe<BitqueryIntegerSelector>;
  blockStrippedSize?: InputMaybe<BitqueryIntegerSelector>;
  blockVersion?: InputMaybe<BitqueryIntegerSelector>;
  blockWeight?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  difficulty?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
};

export enum BitqueryBitcoinBlockUniq {
  /** Unique date count */
  Dates = 'dates'
}

export enum BitqueryBitcoinBlocksMeasureable {
  /** Block */
  Block = 'block',
  /** Block hash */
  BlockHash = 'block_hash',
  /** Date */
  Date = 'date',
  /** Time */
  Time = 'time',
  /** Tx Count */
  TransactionCount = 'transaction_count'
}

/** Coinpath */
export type BitqueryBitcoinCoinpath = {
  __typename?: 'BitqueryBitcoinCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryBitcoinCoinpathAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryBitcoinCoinpathAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<BitqueryBitcoinTransactionHashIndexValues>;
  /** Attributes of transaction included in Coinpath result */
  transactions?: Maybe<Array<BitqueryCoinpathEntry>>;
};


/** Coinpath */
export type BitqueryBitcoinCoinpathAmountArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Coinpath */
export type BitqueryBitcoinCoinpathAnyArgs = {
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryBitcoinCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryBitcoinCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};

/** Address detailed information for Bitcoin network */
export type BitqueryBitcoinCoinpathAddress = {
  __typename?: 'BitqueryBitcoinCoinpathAddress';
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Smart Contract if exists on the address */
  firstTxAt?: Maybe<BitqueryDateTime>;
  /** Smart Contract if exists on the address */
  lastTxAt?: Maybe<BitqueryDateTime>;
  receiversCount?: Maybe<Scalars['Int']['output']>;
  sendersCount?: Maybe<Scalars['Int']['output']>;
  /** Address type */
  type?: Maybe<Scalars['String']['output']>;
};

export enum BitqueryBitcoinCoinpathMethod {
  /** Tracking money flow by amounts, ignoring coins (default) */
  Moneyflow = 'moneyflow',
  /** Tracking coins by UTXO transactions */
  Utxo = 'utxo'
}

/** Limits, Ordering, Constraints, Coinpath Options */
export type BitqueryBitcoinCoinpathOptions = {
  /** Ordering field(s) for ascending */
  asc?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Converting field(s) to integer datatype and then ordering field(s) for ascending */
  ascByInteger?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Method to use coinpath */
  coinpathMethod?: InputMaybe<BitqueryBitcoinCoinpathMethod>;
  /** Raise error if complexity ( currently measured in transaction count ) is higher than this option */
  complexityLimit?: InputMaybe<Scalars['Int']['input']>;
  /** Ordering field(s) for descending */
  desc?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Converting field(s) to integer datatype and then ordering field(s) for descending */
  descByInteger?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Flow direction */
  direction?: InputMaybe<BitqueryFlowDirection>;
  /** Limit number of results */
  limit?: InputMaybe<Scalars['Int']['input']>;
  /** Limit number of results by specific field */
  limitBy?: InputMaybe<BitqueryLimitByOption>;
  /** Do not expand addresses having count transactions more than this */
  maximumAddressTxCount?: InputMaybe<Scalars['Int']['input']>;
  /** Maximum total transaction count returned */
  maximumTotalTxCount?: InputMaybe<Scalars['Int']['input']>;
  /** Do not include transactions below this amount */
  minimumTxAmount?: InputMaybe<Scalars['Float']['input']>;
  /** Offset of results, starting from 0 */
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Invalidating cache seed */
  seed?: InputMaybe<Scalars['Int']['input']>;
};

export type BitqueryBitcoinInputFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inOutputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inOutputTxId?: InputMaybe<BitqueryHashSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inputScriptType?: InputMaybe<BitqueryStringSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};

export enum BitqueryBitcoinInputUniq {
  /** Unique addresses count */
  Addresses = 'addresses',
  /** Unique block count */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates',
  /** Unique transactions count */
  Transactions = 'transactions'
}

export enum BitqueryBitcoinInputsMeasureable {
  /** Address */
  Address = 'address',
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Input index */
  InputIndex = 'input_index',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Transaction index */
  TxIndex = 'tx_index'
}

export enum BitqueryBitcoinNetwork {
  /** Bitcoin Cash ( BCH ) */
  Bitcash = 'bitcash',
  /** Bitcoin ( BTC ) */
  Bitcoin = 'bitcoin',
  /** Bitcoin SV ( BSV ) */
  Bitcoinsv = 'bitcoinsv',
  /** Dash ( DASH ) */
  Dash = 'dash',
  /** Dogecoin ( DOGE ) */
  Dogecoin = 'dogecoin',
  /** Litecoin ( LTC ) */
  Litecoin = 'litecoin',
  /** ZCash ( ZCASH ) */
  Zcash = 'zcash'
}

export type BitqueryBitcoinOmniTransactionsFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  invalidReason?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  typeId?: InputMaybe<BitqueryIntegerSelector>;
  valid?: InputMaybe<BitqueryIntegerSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};

export enum BitqueryBitcoinOmniTransactionsMeasureablse {
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Fee Value */
  FeeValue = 'fee_value',
  /** Time */
  Time = 'time',
  /** Transactions hash */
  TxHash = 'tx_hash',
  /** Transactions index */
  TxIndex = 'tx_index'
}

export enum BitqueryBitcoinOmniTransactionsUniq {
  /** Unique block count */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates',
  /** Unique transactions count */
  Transactions = 'transactions',
  /** Unique transaction sender */
  TxSender = 'tx_sender'
}

/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosn = {
  __typename?: 'BitqueryBitcoinOmniTransactiosn';
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Hash of the block */
  blockHash: Scalars['String']['output'];
  /** OmniTransaction s count */
  count?: Maybe<Scalars['Int']['output']>;
  /** OmniTransaction s count */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Transactions total fee value */
  feeValue?: Maybe<Scalars['Float']['output']>;
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** OmniTransactions index in block, 0-based */
  index: Scalars['String']['output'];
  /** Invalid Reason */
  invalidReason: Scalars['String']['output'];
  /** Invalid Reason */
  json: Scalars['String']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Transaction Sender */
  txSender: Scalars['String']['output'];
  /** Type */
  type: Scalars['String']['output'];
  /** Type Int */
  typeInt: Scalars['Int']['output'];
  /** Version */
  valid: Scalars['Int']['output'];
  /** Version */
  version: Scalars['Int']['output'];
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnAnyArgs = {
  of: BitqueryBitcoinOmniTransactionsMeasureablse;
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnBlockHashArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  invalidReason?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  typeId?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryBitcoinOmniTransactionsUniq>;
  valid?: InputMaybe<BitqueryIntegerSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  invalidReason?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  typeId?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryBitcoinOmniTransactionsUniq>;
  valid?: InputMaybe<BitqueryIntegerSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnExpressionArgs = {
  get: Scalars['String']['input'];
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnFeeValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  invalidReason?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  typeId?: InputMaybe<BitqueryIntegerSelector>;
  valid?: InputMaybe<BitqueryIntegerSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnHashArgs = {
  txHash?: InputMaybe<BitqueryStringIdSelector>;
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnIndexArgs = {
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnInvalidReasonArgs = {
  invalidReason?: InputMaybe<BitqueryStringSelector>;
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnJsonArgs = {
  json?: InputMaybe<BitqueryStringSelector>;
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnMaximumArgs = {
  get?: InputMaybe<BitqueryBitcoinOmniTransactionsMeasureablse>;
  of: BitqueryBitcoinOmniTransactionsMeasureablse;
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnMinimumArgs = {
  get?: InputMaybe<BitqueryBitcoinOmniTransactionsMeasureablse>;
  of: BitqueryBitcoinOmniTransactionsMeasureablse;
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnTxSenderArgs = {
  txSender?: InputMaybe<BitqueryHashSelector>;
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnTypeArgs = {
  type?: InputMaybe<BitqueryStringSelector>;
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnTypeIntArgs = {
  typeInt?: InputMaybe<BitqueryIntegerSelector>;
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnValidArgs = {
  valid?: InputMaybe<BitqueryIntegerSelector>;
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnVersionArgs = {
  version?: InputMaybe<BitqueryIntegerSelector>;
};

/** OmniTransfers */
export type BitqueryBitcoinOmniTransfers = {
  __typename?: 'BitqueryBitcoinOmniTransfers';
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Hash of the block */
  blockHash: Scalars['String']['output'];
  /** Transaction s count */
  count?: Maybe<Scalars['Int']['output']>;
  /** Transaction s count */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Direction */
  direction?: Maybe<Scalars['String']['output']>;
  /** Divisible */
  divisible?: Maybe<Scalars['Int']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Transactions total fee value */
  feeValue?: Maybe<Scalars['Float']['output']>;
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transactions index in block, 0-based */
  index: Scalars['String']['output'];
  /** Ismine */
  ismine?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Transfer From */
  transferFrom: Scalars['String']['output'];
  /** Transfer From */
  transferTo: Scalars['String']['output'];
  /** Transaction Sender */
  txSender: Scalars['String']['output'];
  /** Type */
  type: Scalars['String']['output'];
  /** Type Int */
  typeInt: Scalars['Int']['output'];
  /** value */
  value?: Maybe<Scalars['Float']['output']>;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersAnyArgs = {
  of: BitqueryBitcoinOmniTransfersMeasureablse;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersBlockHashArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  invalidReason?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  typeId?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryBitcoinOmniTransfersUniq>;
  valid?: InputMaybe<BitqueryIntegerSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  invalidReason?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  typeId?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryBitcoinOmniTransfersUniq>;
  valid?: InputMaybe<BitqueryIntegerSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersDirectionArgs = {
  direction?: InputMaybe<BitqueryStringSelector>;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersDivisibleArgs = {
  divisible?: InputMaybe<BitqueryIntegerSelector>;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersExpressionArgs = {
  get: Scalars['String']['input'];
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersFeeValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  invalidReason?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  typeId?: InputMaybe<BitqueryIntegerSelector>;
  valid?: InputMaybe<BitqueryIntegerSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersHashArgs = {
  txHash?: InputMaybe<BitqueryStringIdSelector>;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersIndexArgs = {
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersIsmineArgs = {
  ismine?: InputMaybe<BitqueryIntegerSelector>;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersMaximumArgs = {
  get?: InputMaybe<BitqueryBitcoinOmniTransfersMeasureablse>;
  of: BitqueryBitcoinOmniTransfersMeasureablse;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersMinimumArgs = {
  get?: InputMaybe<BitqueryBitcoinOmniTransfersMeasureablse>;
  of: BitqueryBitcoinOmniTransfersMeasureablse;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersTransferFromArgs = {
  transferFrom?: InputMaybe<BitqueryHashSelector>;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersTransferToArgs = {
  transferTo?: InputMaybe<BitqueryHashSelector>;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersTxSenderArgs = {
  txSender?: InputMaybe<BitqueryHashSelector>;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersTypeArgs = {
  type?: InputMaybe<BitqueryStringSelector>;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersTypeIntArgs = {
  typeInt?: InputMaybe<BitqueryIntegerSelector>;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersValueArgs = {
  value?: InputMaybe<BitqueryFloatSelector>;
};

export type BitqueryBitcoinOmniTransfersFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  invalidReason?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  typeId?: InputMaybe<BitqueryIntegerSelector>;
  valid?: InputMaybe<BitqueryIntegerSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};

export enum BitqueryBitcoinOmniTransfersMeasureablse {
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Fee Value */
  FeeValue = 'fee_value',
  /** Time */
  Time = 'time',
  /** Transactions hash */
  TxHash = 'tx_hash',
  /** Transactions index */
  TxIndex = 'tx_index'
}

export enum BitqueryBitcoinOmniTransfersUniq {
  /** Unique block count */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates',
  /** Unique transactions count */
  Transactions = 'transactions',
  /** Unique transaction sender */
  TxSender = 'tx_sender'
}

export enum BitqueryBitcoinOutputDirection {
  /** Change return */
  Change = 'change',
  /** Fee */
  Fee = 'fee',
  /** Genesis */
  Genesis = 'genesis',
  /** Likely Change return */
  LikelyChange = 'likely_change',
  /** Likely Not a change return */
  LikelyNotChange = 'likely_not_change',
  /** Mining */
  Mining = 'mining',
  /** Minting */
  Minting = 'minting',
  /** Not a change return */
  NotChange = 'not_change',
  /** Not defined */
  Unknown = 'unknown'
}

/** A guessed direction of output */
export type BitqueryBitcoinOutputDirectionSelector = {
  /** In the list of direction */
  in?: InputMaybe<Array<BitqueryBitcoinOutputDirection>>;
  /** Equal to direction */
  is?: InputMaybe<BitqueryBitcoinOutputDirection>;
  /** Not Equal to direction */
  not?: InputMaybe<BitqueryBitcoinOutputDirection>;
  /** Not in the list of direction */
  notIn?: InputMaybe<Array<BitqueryBitcoinOutputDirection>>;
};

export type BitqueryBitcoinOutputFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputDirection?: InputMaybe<BitqueryBitcoinOutputDirectionSelector>;
  outputIndex?: InputMaybe<BitqueryIntegerSelector>;
  outputScriptType?: InputMaybe<BitqueryStringSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};

export enum BitqueryBitcoinOutputUniq {
  /** Unique input addresses count */
  Addresses = 'addresses',
  /** Unique block count */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates',
  /** Unique transactions count */
  Transactions = 'transactions'
}

export enum BitqueryBitcoinOutputsMeasureable {
  /** Address */
  Address = 'address',
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Output index */
  OutputIndex = 'output_index',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Transaction index */
  TxIndex = 'tx_index'
}

/** Transaction */
export type BitqueryBitcoinTransaction = {
  __typename?: 'BitqueryBitcoinTransaction';
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Transaction  count */
  count?: Maybe<Scalars['Int']['output']>;
  /** Transaction  count */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Transaction total fee value */
  feeValue?: Maybe<Scalars['Float']['output']>;
  /** Transaction total fee value */
  feeValueDecimal?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction index in block, 0-based */
  index: Scalars['String']['output'];
  /** Transaction total input count */
  inputCount?: Maybe<Scalars['Int']['output']>;
  /** Transaction total input count */
  inputCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Transaction total input value */
  inputValue?: Maybe<Scalars['Float']['output']>;
  /** Transaction total input value as decimal */
  inputValueDecimal?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Transaction total mined value */
  minedValue?: Maybe<Scalars['Float']['output']>;
  /** Transaction total mined value */
  minedValueDecimal?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Transaction total output count */
  outputCount?: Maybe<Scalars['Int']['output']>;
  /** Transaction total output count */
  outputCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Transaction total output value */
  outputValue?: Maybe<Scalars['Float']['output']>;
  /** Transaction total output value */
  outputValueDecimal?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Transaction is coinbase */
  txCoinbase?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction locktime */
  txLocktime?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Transaction size */
  txSize?: Maybe<Scalars['Int']['output']>;
  /** Transaction version */
  txVersion?: Maybe<Scalars['Int']['output']>;
  /** Transaction vsize */
  txVsize?: Maybe<Scalars['Int']['output']>;
  /** Transaction weight */
  txWeight?: Maybe<Scalars['Int']['output']>;
};


/** Transaction */
export type BitqueryBitcoinTransactionAnyArgs = {
  of: BitqueryBitcoinTransactionsMeasureable;
};


/** Transaction */
export type BitqueryBitcoinTransactionBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  minedValue?: InputMaybe<BitqueryFloatSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']['input']>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txLocktime?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  txVersion?: InputMaybe<BitqueryIntegerSelector>;
  txVsize?: InputMaybe<BitqueryIntegerSelector>;
  txWeight?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryBitcoinTransactionUniq>;
};


/** Transaction */
export type BitqueryBitcoinTransactionCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  minedValue?: InputMaybe<BitqueryFloatSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']['input']>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txLocktime?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  txVersion?: InputMaybe<BitqueryIntegerSelector>;
  txVsize?: InputMaybe<BitqueryIntegerSelector>;
  txWeight?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryBitcoinTransactionUniq>;
};


/** Transaction */
export type BitqueryBitcoinTransactionExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transaction */
export type BitqueryBitcoinTransactionFeeValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  minedValue?: InputMaybe<BitqueryFloatSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']['input']>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txLocktime?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  txVersion?: InputMaybe<BitqueryIntegerSelector>;
  txVsize?: InputMaybe<BitqueryIntegerSelector>;
  txWeight?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionFeeValueDecimalArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  minedValue?: InputMaybe<BitqueryFloatSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']['input']>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txLocktime?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  txVersion?: InputMaybe<BitqueryIntegerSelector>;
  txVsize?: InputMaybe<BitqueryIntegerSelector>;
  txWeight?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionHashArgs = {
  txHash?: InputMaybe<BitqueryStringIdSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionIndexArgs = {
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionInputCountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  minedValue?: InputMaybe<BitqueryFloatSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']['input']>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txLocktime?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  txVersion?: InputMaybe<BitqueryIntegerSelector>;
  txVsize?: InputMaybe<BitqueryIntegerSelector>;
  txWeight?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionInputCountBigIntArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  minedValue?: InputMaybe<BitqueryFloatSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']['input']>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txLocktime?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  txVersion?: InputMaybe<BitqueryIntegerSelector>;
  txVsize?: InputMaybe<BitqueryIntegerSelector>;
  txWeight?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionInputValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  minedValue?: InputMaybe<BitqueryFloatSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']['input']>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txLocktime?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  txVersion?: InputMaybe<BitqueryIntegerSelector>;
  txVsize?: InputMaybe<BitqueryIntegerSelector>;
  txWeight?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionInputValueDecimalArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  minedValue?: InputMaybe<BitqueryFloatSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']['input']>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txLocktime?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  txVersion?: InputMaybe<BitqueryIntegerSelector>;
  txVsize?: InputMaybe<BitqueryIntegerSelector>;
  txWeight?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionMaximumArgs = {
  get?: InputMaybe<BitqueryBitcoinTransactionsMeasureable>;
  of: BitqueryBitcoinTransactionsMeasureable;
};


/** Transaction */
export type BitqueryBitcoinTransactionMinedValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  minedValue?: InputMaybe<BitqueryFloatSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']['input']>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txLocktime?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  txVersion?: InputMaybe<BitqueryIntegerSelector>;
  txVsize?: InputMaybe<BitqueryIntegerSelector>;
  txWeight?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionMinedValueDecimalArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  minedValue?: InputMaybe<BitqueryFloatSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']['input']>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txLocktime?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  txVersion?: InputMaybe<BitqueryIntegerSelector>;
  txVsize?: InputMaybe<BitqueryIntegerSelector>;
  txWeight?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionMinimumArgs = {
  get?: InputMaybe<BitqueryBitcoinTransactionsMeasureable>;
  of: BitqueryBitcoinTransactionsMeasureable;
};


/** Transaction */
export type BitqueryBitcoinTransactionOutputCountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  minedValue?: InputMaybe<BitqueryFloatSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']['input']>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txLocktime?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  txVersion?: InputMaybe<BitqueryIntegerSelector>;
  txVsize?: InputMaybe<BitqueryIntegerSelector>;
  txWeight?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionOutputCountBigIntArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  minedValue?: InputMaybe<BitqueryFloatSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']['input']>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txLocktime?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  txVersion?: InputMaybe<BitqueryIntegerSelector>;
  txVsize?: InputMaybe<BitqueryIntegerSelector>;
  txWeight?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionOutputValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  minedValue?: InputMaybe<BitqueryFloatSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']['input']>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txLocktime?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  txVersion?: InputMaybe<BitqueryIntegerSelector>;
  txVsize?: InputMaybe<BitqueryIntegerSelector>;
  txWeight?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionOutputValueDecimalArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  minedValue?: InputMaybe<BitqueryFloatSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']['input']>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txLocktime?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  txVersion?: InputMaybe<BitqueryIntegerSelector>;
  txVsize?: InputMaybe<BitqueryIntegerSelector>;
  txWeight?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionTxCoinbaseArgs = {
  txCoinbase?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Transaction */
export type BitqueryBitcoinTransactionTxLocktimeArgs = {
  txLocktime?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionTxSizeArgs = {
  txSize?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionTxVersionArgs = {
  txVersion?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionTxVsizeArgs = {
  txVsize?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionTxWeightArgs = {
  txWeight?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryBitcoinTransactionFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  minedValue?: InputMaybe<BitqueryFloatSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']['input']>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txLocktime?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  txVersion?: InputMaybe<BitqueryIntegerSelector>;
  txVsize?: InputMaybe<BitqueryIntegerSelector>;
  txWeight?: InputMaybe<BitqueryIntegerSelector>;
};

/** Blockchain transaction */
export type BitqueryBitcoinTransactionHashIndexValues = {
  __typename?: 'BitqueryBitcoinTransactionHashIndexValues';
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction index in block, 0-based */
  index: Scalars['String']['output'];
  /** Transaction value in input */
  valueIn: Scalars['Float']['output'];
  /** Transaction value in input */
  valueInDecimal: Scalars['BitqueryDecimalNumber']['output'];
  /** Transaction value in output */
  valueOut: Scalars['Float']['output'];
  /** Transaction value in output */
  valueOutDecimal: Scalars['BitqueryDecimalNumber']['output'];
};

/** Transaction Input */
export type BitqueryBitcoinTransactionInput = {
  __typename?: 'BitqueryBitcoinTransactionInput';
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Input count */
  count?: Maybe<Scalars['Int']['output']>;
  /** Input count */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Input address */
  inputAddress?: Maybe<BitqueryAddress>;
  /** Input index */
  inputIndex?: Maybe<Scalars['Int']['output']>;
  /** Input script */
  inputScript?: Maybe<Scalars['String']['output']>;
  /** Input script type and attributes */
  inputScriptType?: Maybe<BitqueryInputScript>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Output Transaction for this input */
  outputTransaction?: Maybe<BitqueryTransactionHashIndex>;
  /** Transaction ID Hash */
  transaction?: Maybe<BitqueryTransactionHashIndex>;
  /** Input value */
  value?: Maybe<Scalars['Float']['output']>;
  /** Input value as decimal */
  valueDecimal?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
};


/** Transaction Input */
export type BitqueryBitcoinTransactionInputAnyArgs = {
  of: BitqueryBitcoinInputsMeasureable;
};


/** Transaction Input */
export type BitqueryBitcoinTransactionInputBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transaction Input */
export type BitqueryBitcoinTransactionInputCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inOutputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inOutputTxId?: InputMaybe<BitqueryHashSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inputScriptType?: InputMaybe<BitqueryStringSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryBitcoinInputUniq>;
};


/** Transaction Input */
export type BitqueryBitcoinTransactionInputCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inOutputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inOutputTxId?: InputMaybe<BitqueryHashSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inputScriptType?: InputMaybe<BitqueryStringSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryBitcoinInputUniq>;
};


/** Transaction Input */
export type BitqueryBitcoinTransactionInputExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transaction Input */
export type BitqueryBitcoinTransactionInputInputAddressArgs = {
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
};


/** Transaction Input */
export type BitqueryBitcoinTransactionInputInputIndexArgs = {
  inputIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction Input */
export type BitqueryBitcoinTransactionInputInputScriptTypeArgs = {
  inputScriptType?: InputMaybe<BitqueryStringSelector>;
};


/** Transaction Input */
export type BitqueryBitcoinTransactionInputMaximumArgs = {
  get?: InputMaybe<BitqueryBitcoinInputsMeasureable>;
  of: BitqueryBitcoinInputsMeasureable;
};


/** Transaction Input */
export type BitqueryBitcoinTransactionInputMinimumArgs = {
  get?: InputMaybe<BitqueryBitcoinInputsMeasureable>;
  of: BitqueryBitcoinInputsMeasureable;
};


/** Transaction Input */
export type BitqueryBitcoinTransactionInputOutputTransactionArgs = {
  inOutputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inOutputTxId?: InputMaybe<BitqueryStringIdSelector>;
};


/** Transaction Input */
export type BitqueryBitcoinTransactionInputTransactionArgs = {
  txId?: InputMaybe<BitqueryStringIdSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction Input */
export type BitqueryBitcoinTransactionInputValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  inOutputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inOutputTxId?: InputMaybe<BitqueryHashSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inputScriptType?: InputMaybe<BitqueryStringSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction Input */
export type BitqueryBitcoinTransactionInputValueDecimalArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inOutputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inOutputTxId?: InputMaybe<BitqueryHashSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inputScriptType?: InputMaybe<BitqueryStringSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};

/** Transaction Output */
export type BitqueryBitcoinTransactionOutput = {
  __typename?: 'BitqueryBitcoinTransactionOutput';
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Output count */
  count?: Maybe<Scalars['Int']['output']>;
  /** Output count */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Output address */
  outputAddress?: Maybe<BitqueryAddress>;
  /** Output guessed direction */
  outputDirection?: Maybe<BitqueryBitcoinOutputDirection>;
  /** Output index */
  outputIndex?: Maybe<Scalars['Int']['output']>;
  /** Output script */
  outputScript?: Maybe<Scalars['String']['output']>;
  /** Output script type and attributes */
  outputScriptType?: Maybe<BitqueryOutputScript>;
  reqSigs?: Maybe<Scalars['Int']['output']>;
  /** Transaction ID Hash */
  transaction?: Maybe<BitqueryTransactionHashIndex>;
  /** Output value */
  value?: Maybe<Scalars['Float']['output']>;
  /** Output value as decimal */
  valueDecimal?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
};


/** Transaction Output */
export type BitqueryBitcoinTransactionOutputAnyArgs = {
  of: BitqueryBitcoinOutputsMeasureable;
};


/** Transaction Output */
export type BitqueryBitcoinTransactionOutputBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transaction Output */
export type BitqueryBitcoinTransactionOutputCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputDirection?: InputMaybe<BitqueryBitcoinOutputDirectionSelector>;
  outputIndex?: InputMaybe<BitqueryIntegerSelector>;
  outputScriptType?: InputMaybe<BitqueryStringSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryBitcoinOutputUniq>;
};


/** Transaction Output */
export type BitqueryBitcoinTransactionOutputCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputDirection?: InputMaybe<BitqueryBitcoinOutputDirectionSelector>;
  outputIndex?: InputMaybe<BitqueryIntegerSelector>;
  outputScriptType?: InputMaybe<BitqueryStringSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryBitcoinOutputUniq>;
};


/** Transaction Output */
export type BitqueryBitcoinTransactionOutputExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transaction Output */
export type BitqueryBitcoinTransactionOutputMaximumArgs = {
  get?: InputMaybe<BitqueryBitcoinOutputsMeasureable>;
  of: BitqueryBitcoinOutputsMeasureable;
};


/** Transaction Output */
export type BitqueryBitcoinTransactionOutputMinimumArgs = {
  get?: InputMaybe<BitqueryBitcoinOutputsMeasureable>;
  of: BitqueryBitcoinOutputsMeasureable;
};


/** Transaction Output */
export type BitqueryBitcoinTransactionOutputOutputAddressArgs = {
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
};


/** Transaction Output */
export type BitqueryBitcoinTransactionOutputOutputDirectionArgs = {
  outputDirection?: InputMaybe<BitqueryBitcoinOutputDirectionSelector>;
};


/** Transaction Output */
export type BitqueryBitcoinTransactionOutputOutputIndexArgs = {
  outputIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction Output */
export type BitqueryBitcoinTransactionOutputOutputScriptTypeArgs = {
  inputScriptType?: InputMaybe<BitqueryStringSelector>;
};


/** Transaction Output */
export type BitqueryBitcoinTransactionOutputTransactionArgs = {
  txId?: InputMaybe<BitqueryStringIdSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction Output */
export type BitqueryBitcoinTransactionOutputValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputDirection?: InputMaybe<BitqueryBitcoinOutputDirectionSelector>;
  outputIndex?: InputMaybe<BitqueryIntegerSelector>;
  outputScriptType?: InputMaybe<BitqueryStringSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction Output */
export type BitqueryBitcoinTransactionOutputValueDecimalArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inOutputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inOutputTxId?: InputMaybe<BitqueryHashSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inputScriptType?: InputMaybe<BitqueryStringSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};

export enum BitqueryBitcoinTransactionUniq {
  /** Unique block count */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates'
}

export enum BitqueryBitcoinTransactionsMeasureable {
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Fee Value */
  FeeValue = 'fee_value',
  /** Input count */
  InputCount = 'input_count',
  /** Transaction input value */
  InputValue = 'input_value',
  /** Output count */
  OutputCount = 'output_count',
  /** Transaction output value */
  OutputValue = 'output_value',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Transaction index */
  TxIndex = 'tx_index',
  /** Transaction size */
  TxSize = 'tx_size'
}

/** Block */
export type BitqueryBlock = {
  __typename?: 'BitqueryBlock';
  /** Block number (height) in blockchain */
  height: Scalars['Int']['output'];
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
};

/** BlockExtended */
export type BitqueryBlockExtended = {
  __typename?: 'BitqueryBlockExtended';
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Block number (height) in blockchain */
  height: Scalars['Int']['output'];
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
};

/** ConfluxBlock */
export type BitqueryBlockInfo = {
  __typename?: 'BitqueryBlockInfo';
  /** Block hash */
  hash?: Maybe<Scalars['String']['output']>;
  /** Block number (height) in blockchain */
  height: Scalars['Int']['output'];
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
};

/** Select block by height ( sequence number) */
export type BitqueryBlockSelector = {
  /** Block height in range */
  between?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Block height greater than */
  gt?: InputMaybe<Scalars['Int']['input']>;
  /** Block height greater or equal than */
  gteq?: InputMaybe<Scalars['Int']['input']>;
  /** Block height in the list */
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Block height is */
  is?: InputMaybe<Scalars['Int']['input']>;
  /** Block height less than */
  lt?: InputMaybe<Scalars['Int']['input']>;
  /** Block height less or equal than */
  lteq?: InputMaybe<Scalars['Int']['input']>;
  /** Block height not */
  not?: InputMaybe<Scalars['Int']['input']>;
  /** Block height not in the list */
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** Select block by height ( sequence number) */
export type BitqueryBlockSelectorRange = {
  /** Block height in range */
  between?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Block height greater than */
  gt?: InputMaybe<Scalars['Int']['input']>;
  /** Block height greater or equal than */
  gteq?: InputMaybe<Scalars['Int']['input']>;
  /** Block height eq */
  is?: InputMaybe<Scalars['Int']['input']>;
  /** Block height less than */
  lt?: InputMaybe<Scalars['Int']['input']>;
  /** Block height less or equal than */
  lteq?: InputMaybe<Scalars['Int']['input']>;
};

/** Blockchain network */
export type BitqueryBlockchainNetwork = {
  __typename?: 'BitqueryBlockchainNetwork';
  /** Network name */
  network: BitqueryNetwork;
  /** Network protocol type */
  protocol: BitqueryProtocol;
};

/** Select by boolean (sequence number) */
export type BitqueryBooleanSelector = {
  /** Is */
  is?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is not */
  not?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Cardano */
export type BitqueryCardano = {
  __typename?: 'BitqueryCardano';
  /** Information about address */
  address: Array<BitqueryCardanoAddressInfo>;
  /** Blockchain Address Statistics */
  addressStats?: Maybe<Array<BitqueryCardanoAddressStats>>;
  /** Blockchain Blocks */
  blocks?: Maybe<Array<BitqueryCardanoBlock>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryCardanoCoinpath>>;
  /** Blockchain Transaction Inputs */
  inputs?: Maybe<Array<BitqueryCardanoTransactionInput>>;
  /** Blockchain Tokens Mints */
  mints?: Maybe<Array<BitqueryCardanoTransactionMint>>;
  /** Blockchain Transaction Outputs */
  outputs?: Maybe<Array<BitqueryCardanoTransactionOutput>>;
  /** Blockchain Transactions */
  transactions?: Maybe<Array<BitqueryCardanoTransaction>>;
};


/** Cardano */
export type BitqueryCardanoAddressArgs = {
  address: Array<BitqueryAddressSelectorIn>;
};


/** Cardano */
export type BitqueryCardanoAddressStatsArgs = {
  address: BitqueryAddressSelector;
  options?: InputMaybe<BitqueryQueryOptions>;
};


/** Cardano */
export type BitqueryCardanoBlocksArgs = {
  any?: InputMaybe<Array<BitqueryCardanoBlockFilter>>;
  blockHash?: InputMaybe<BitqueryStringIdSelector>;
  blockSize?: InputMaybe<BitqueryIntegerSelector>;
  blockVersion?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  opCert?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  slot?: InputMaybe<BitqueryIntegerSelector>;
  slotInEpoch?: InputMaybe<BitqueryIntegerSelector>;
  slotLeaderHash?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  version?: InputMaybe<BitqueryStringSelector>;
  vrfKey?: InputMaybe<BitqueryStringSelector>;
};


/** Cardano */
export type BitqueryCardanoCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  initialAddress?: InputMaybe<BitqueryAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCardanoCoinpathOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Cardano */
export type BitqueryCardanoInputsArgs = {
  any?: InputMaybe<Array<BitqueryCardanoInputFilter>>;
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inOutputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inOutputTxId?: InputMaybe<BitqueryHashSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inputSource?: InputMaybe<BitqueryCardanoInputSourcenSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Cardano */
export type BitqueryCardanoMintsArgs = {
  any?: InputMaybe<Array<BitqueryCardanoMintFilter>>;
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  value?: InputMaybe<BitqueryFloatSelector>;
};


/** Cardano */
export type BitqueryCardanoOutputsArgs = {
  any?: InputMaybe<Array<BitqueryCardanoOutputFilter>>;
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputDirection?: InputMaybe<BitqueryCardanoOutputDirectionSelector>;
  outputIndex?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Cardano */
export type BitqueryCardanoTransactionsArgs = {
  any?: InputMaybe<Array<BitqueryCardanoTransactionFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};

/** Address balance information for Cardano network */
export type BitqueryCardanoAddressBalance = {
  __typename?: 'BitqueryCardanoAddressBalance';
  /** Currency */
  currency?: Maybe<BitqueryCurrency>;
  /** Currency value */
  value?: Maybe<Scalars['Float']['output']>;
};

/** Address detailed information for Cardano network */
export type BitqueryCardanoAddressInfo = {
  __typename?: 'BitqueryCardanoAddressInfo';
  /** Address */
  address?: Maybe<BitqueryAddress>;
  /** Current address balances */
  balance?: Maybe<Array<BitqueryCardanoAddressBalance>>;
  /** Current staking addressese info */
  staking?: Maybe<Array<BitqueryCardanoStakingAddress>>;
};

/** AddressStat */
export type BitqueryCardanoAddressStats = {
  __typename?: 'BitqueryCardanoAddressStats';
  /** Address With Statistics */
  address?: Maybe<BitqueryAddressStatDimension>;
};

/** Block */
export type BitqueryCardanoBlock = {
  __typename?: 'BitqueryCardanoBlock';
  any?: Maybe<Scalars['String']['output']>;
  /** Block Hash */
  blockHash?: Maybe<Scalars['String']['output']>;
  /** Block size */
  blockSize?: Maybe<Scalars['Int']['output']>;
  /** Block version */
  blockVersion?: Maybe<Scalars['Int']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Epoch number */
  epoch?: Maybe<Scalars['Int']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Block number (height) in blockchain */
  height: Scalars['Int']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Op cert */
  opCert?: Maybe<Scalars['String']['output']>;
  /** Slot number */
  slot?: Maybe<Scalars['Int']['output']>;
  /** Slot in epoch number */
  slotInEpoch?: Maybe<Scalars['Int']['output']>;
  /** Slot leader description */
  slotLeaderDescription?: Maybe<Scalars['String']['output']>;
  /** Slot leader hash */
  slotLeaderHash?: Maybe<Scalars['String']['output']>;
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction count in block */
  transactionCount?: Maybe<Scalars['Int']['output']>;
  /** VRF Key */
  vrfKey?: Maybe<Scalars['String']['output']>;
};


/** Block */
export type BitqueryCardanoBlockAnyArgs = {
  of: BitqueryCardanoBlocksMeasureable;
};


/** Block */
export type BitqueryCardanoBlockBlockHashArgs = {
  blockHash?: InputMaybe<BitqueryStringIdSelector>;
};


/** Block */
export type BitqueryCardanoBlockBlockSizeArgs = {
  blockSize?: InputMaybe<BitqueryIntegerSelector>;
};


/** Block */
export type BitqueryCardanoBlockBlockVersionArgs = {
  blockVersion?: InputMaybe<BitqueryIntegerSelector>;
};


/** Block */
export type BitqueryCardanoBlockCountArgs = {
  blockHash?: InputMaybe<BitqueryStringIdSelector>;
  blockSize?: InputMaybe<BitqueryIntegerSelector>;
  blockStrippedSize?: InputMaybe<BitqueryIntegerSelector>;
  blockVersion?: InputMaybe<BitqueryIntegerSelector>;
  blockWeight?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  difficulty?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCount?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryCardanoBlockUniq>;
};


/** Block */
export type BitqueryCardanoBlockCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryStringIdSelector>;
  blockSize?: InputMaybe<BitqueryIntegerSelector>;
  blockStrippedSize?: InputMaybe<BitqueryIntegerSelector>;
  blockVersion?: InputMaybe<BitqueryIntegerSelector>;
  blockWeight?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  difficulty?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCount?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryCardanoBlockUniq>;
};


/** Block */
export type BitqueryCardanoBlockExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Block */
export type BitqueryCardanoBlockHeightArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Block */
export type BitqueryCardanoBlockMaximumArgs = {
  get?: InputMaybe<BitqueryCardanoBlocksMeasureable>;
  of: BitqueryCardanoBlocksMeasureable;
};


/** Block */
export type BitqueryCardanoBlockMinimumArgs = {
  get?: InputMaybe<BitqueryCardanoBlocksMeasureable>;
  of: BitqueryCardanoBlocksMeasureable;
};


/** Block */
export type BitqueryCardanoBlockTimestampArgs = {
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Block */
export type BitqueryCardanoBlockTransactionCountArgs = {
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryCardanoBlockFilter = {
  blockHash?: InputMaybe<BitqueryStringIdSelector>;
  blockSize?: InputMaybe<BitqueryIntegerSelector>;
  blockVersion?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  opCert?: InputMaybe<BitqueryStringSelector>;
  slot?: InputMaybe<BitqueryIntegerSelector>;
  slotInEpoch?: InputMaybe<BitqueryIntegerSelector>;
  slotLeaderHash?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  version?: InputMaybe<BitqueryStringSelector>;
  vrfKey?: InputMaybe<BitqueryStringSelector>;
};

export enum BitqueryCardanoBlockUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique epoch */
  Epoch = 'epoch',
  /** Unique slot */
  Slot = 'slot',
  /** Unique slot leader */
  SlotLeader = 'slot_leader',
  /** Unique version */
  Version = 'version'
}

export enum BitqueryCardanoBlocksMeasureable {
  /** Block */
  Block = 'block',
  /** Block hash */
  BlockHash = 'block_hash',
  /** Date */
  Date = 'date',
  /** Time */
  Time = 'time',
  /** Tx Count */
  TransactionCount = 'transaction_count'
}

/** Coinpath */
export type BitqueryCardanoCoinpath = {
  __typename?: 'BitqueryCardanoCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryCardanoCoinpathAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryCardanoCoinpathAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<BitqueryCardanoTransactionHashIndexValues>;
  /** Attributes of transaction included in Coinpath result */
  transactions?: Maybe<Array<BitqueryCoinpathEntry>>;
};


/** Coinpath */
export type BitqueryCardanoCoinpathAmountArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Coinpath */
export type BitqueryCardanoCoinpathAnyArgs = {
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryCardanoCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryCardanoCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};

/** Address detailed information for Cardano network */
export type BitqueryCardanoCoinpathAddress = {
  __typename?: 'BitqueryCardanoCoinpathAddress';
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Smart Contract if exists on the address */
  firstTxAt?: Maybe<BitqueryDateTime>;
  /** Smart Contract if exists on the address */
  lastTxAt?: Maybe<BitqueryDateTime>;
  receiversCount?: Maybe<Scalars['Int']['output']>;
  sendersCount?: Maybe<Scalars['Int']['output']>;
  /** Address type */
  type?: Maybe<Scalars['String']['output']>;
};

export enum BitqueryCardanoCoinpathMethod {
  /** Tracking money flow by amounts, ignoring coins (default) */
  Moneyflow = 'moneyflow',
  /** Tracking coins by UTXO transactions */
  Utxo = 'utxo'
}

/** Limits, Ordering, Constraints, Coinpath Options */
export type BitqueryCardanoCoinpathOptions = {
  /** Ordering field(s) for ascending */
  asc?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Converting field(s) to integer datatype and then ordering field(s) for ascending */
  ascByInteger?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Method to use coinpath */
  coinpathMethod?: InputMaybe<BitqueryCardanoCoinpathMethod>;
  /** Raise error if complexity ( currently measured in transaction count ) is higher than this option */
  complexityLimit?: InputMaybe<Scalars['Int']['input']>;
  /** Ordering field(s) for descending */
  desc?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Converting field(s) to integer datatype and then ordering field(s) for descending */
  descByInteger?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Flow direction */
  direction?: InputMaybe<BitqueryFlowDirection>;
  /** Limit number of results */
  limit?: InputMaybe<Scalars['Int']['input']>;
  /** Limit number of results by specific field */
  limitBy?: InputMaybe<BitqueryLimitByOption>;
  /** Do not expand addresses having count transactions more than this */
  maximumAddressTxCount?: InputMaybe<Scalars['Int']['input']>;
  /** Maximum total transaction count returned */
  maximumTotalTxCount?: InputMaybe<Scalars['Int']['input']>;
  /** Do not include transactions below this amount */
  minimumTxAmount?: InputMaybe<Scalars['Float']['input']>;
  /** Offset of results, starting from 0 */
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Invalidating cache seed */
  seed?: InputMaybe<Scalars['Int']['input']>;
  /** Option to get info for staking addresses */
  stakingAddress?: InputMaybe<Scalars['Boolean']['input']>;
};

/**
 * Cardano token selector by tokenId.
 *     Native binance token has ADA symbol, pass it as argument.
 *     Otherwise pass asset fingerprint, starting from asset...
 */
export type BitqueryCardanoCurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Currency not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type BitqueryCardanoInputFilter = {
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inOutputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inOutputTxId?: InputMaybe<BitqueryHashSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inputSource?: InputMaybe<BitqueryCardanoInputSourcenSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};

export enum BitqueryCardanoInputSource {
  /** Input */
  Input = 'input',
  /** Stake Deregistration */
  StakeDeregistration = 'stake_deregistration',
  /** Withdrawal */
  Withdrawal = 'withdrawal'
}

/** A source input */
export type BitqueryCardanoInputSourcenSelector = {
  /** In the list of source */
  in?: InputMaybe<Array<BitqueryCardanoInputSource>>;
  /** Equal to source */
  is?: InputMaybe<BitqueryCardanoInputSource>;
  /** Not Equal to source */
  not?: InputMaybe<BitqueryCardanoInputSource>;
  /** Not in the list of source */
  notIn?: InputMaybe<Array<BitqueryCardanoInputSource>>;
};

export enum BitqueryCardanoInputUniq {
  /** Unique addresses count */
  Addresses = 'addresses',
  /** Unique block count */
  Blocks = 'blocks',
  /** Unique currencies count */
  Currencies = 'currencies',
  /** Unique date count */
  Dates = 'dates',
  /** Unique source count */
  Sources = 'sources',
  /** Unique transactions count */
  Transactions = 'transactions'
}

export enum BitqueryCardanoInputsMeasureable {
  /** Address */
  Address = 'address',
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Input index */
  InputIndex = 'input_index',
  /** Input source */
  Source = 'source',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Transaction index */
  TxIndex = 'tx_index'
}

export type BitqueryCardanoMintFilter = {
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  value?: InputMaybe<BitqueryFloatSelector>;
};

export enum BitqueryCardanoMintUniq {
  /** Unique block count */
  Blocks = 'blocks',
  /** Unique currencies count */
  Currencies = 'currencies',
  /** Unique date count */
  Dates = 'dates',
  /** Unique transactions count */
  Transactions = 'transactions'
}

export enum BitqueryCardanoMintsMeasureable {
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Transaction index */
  TxIndex = 'tx_index'
}

export enum BitqueryCardanoNetwork {
  /** Cardano ( ADA ) */
  Cardano = 'cardano'
}

export enum BitqueryCardanoOutputDirection {
  /** Change return */
  Change = 'change',
  /** Stake Registration */
  Deposit = 'deposit',
  /** Genesis */
  Genesis = 'genesis',
  /** Not a change return */
  NotChange = 'not_change',
  /** Stake Registration */
  StakeRegistration = 'stake_registration',
  /** Not defined */
  Unknown = 'unknown'
}

/** A guessed direction of output */
export type BitqueryCardanoOutputDirectionSelector = {
  /** In the list of direction */
  in?: InputMaybe<Array<BitqueryCardanoOutputDirection>>;
  /** Equal to direction */
  is?: InputMaybe<BitqueryCardanoOutputDirection>;
  /** Not Equal to direction */
  not?: InputMaybe<BitqueryCardanoOutputDirection>;
  /** Not in the list of direction */
  notIn?: InputMaybe<Array<BitqueryCardanoOutputDirection>>;
};

export type BitqueryCardanoOutputFilter = {
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputDirection?: InputMaybe<BitqueryCardanoOutputDirectionSelector>;
  outputIndex?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};

export enum BitqueryCardanoOutputUniq {
  /** Unique input addresses count */
  Addresses = 'addresses',
  /** Unique block count */
  Blocks = 'blocks',
  /** Unique currencies count */
  Currencies = 'currencies',
  /** Unique date count */
  Dates = 'dates',
  /** Unique direction count */
  Directions = 'directions',
  /** Unique transactions count */
  Transactions = 'transactions'
}

export enum BitqueryCardanoOutputsMeasureable {
  /** Address */
  Address = 'address',
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Output direction */
  Direction = 'direction',
  /** Output index */
  OutputIndex = 'output_index',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Transaction index */
  TxIndex = 'tx_index'
}

/** Address staking information for Cardano network */
export type BitqueryCardanoStakingAddress = {
  __typename?: 'BitqueryCardanoStakingAddress';
  /** Staking Address */
  address?: Maybe<BitqueryAddress>;
  /** Controlled total stake */
  controlledTotalStake?: Maybe<Scalars['Float']['output']>;
  /** Rewards value */
  rewardsAmount?: Maybe<Scalars['Float']['output']>;
  /** Rewards available */
  rewardsAvailable?: Maybe<Scalars['Float']['output']>;
  /** Staked value */
  stakedAmount?: Maybe<Scalars['Float']['output']>;
  /** Staked value including rewards */
  stakedAmountWithRewards?: Maybe<Scalars['Float']['output']>;
  /** Withdrawn value */
  withdrawnAmount?: Maybe<Scalars['Float']['output']>;
};

/** Transaction */
export type BitqueryCardanoTransaction = {
  __typename?: 'BitqueryCardanoTransaction';
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Transaction  count */
  count?: Maybe<Scalars['Int']['output']>;
  /** Transaction  count */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Transaction total deposit value */
  depositValue?: Maybe<Scalars['Float']['output']>;
  /** Transaction total fee value */
  depositValueDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Transaction total fee value */
  feeValue?: Maybe<Scalars['Float']['output']>;
  /** Transaction total fee value */
  feeValueDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Included at timestamp */
  includedAt?: Maybe<BitqueryDateTime>;
  /** Transaction index in block, 0-based */
  index: Scalars['String']['output'];
  /** Transaction total input count */
  inputCount?: Maybe<Scalars['Int']['output']>;
  /** Transaction total input count */
  inputCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Transaction total input value */
  inputValue?: Maybe<Scalars['Float']['output']>;
  /** Transaction total input value as decimal */
  inputValueDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  /** Invalid before */
  invalidBefore?: Maybe<Scalars['String']['output']>;
  /** Invalid hereafter */
  invalidHereafter?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Metadata */
  metadata?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Transaction total mint count */
  mintCount?: Maybe<Scalars['Int']['output']>;
  /** Transaction total mint count */
  mintCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Transaction total output count */
  outputCount?: Maybe<Scalars['Int']['output']>;
  /** Transaction total output count */
  outputCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Transaction total output value */
  outputValue?: Maybe<Scalars['Float']['output']>;
  /** Transaction total output value */
  outputValueDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  /** Transaction size */
  txSize?: Maybe<Scalars['Int']['output']>;
  /** Transaction total withdrawal count */
  withdrawalCount?: Maybe<Scalars['Int']['output']>;
  /** Transaction total withdrawal count */
  withdrawalCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Transaction total withdrawal value */
  withdrawalValue?: Maybe<Scalars['Float']['output']>;
  /** Transaction total fee value */
  withdrawalValueDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
};


/** Transaction */
export type BitqueryCardanoTransactionAnyArgs = {
  of: BitqueryCardanoTransactionsMeasureable;
};


/** Transaction */
export type BitqueryCardanoTransactionBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryCardanoTransactionUniq>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryCardanoTransactionUniq>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionDepositValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionDepositValueDecimalArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transaction */
export type BitqueryCardanoTransactionFeeValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionFeeValueDecimalArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionHashArgs = {
  txHash?: InputMaybe<BitqueryStringIdSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionIndexArgs = {
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionInputCountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionInputCountBigIntArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionInputValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionInputValueDecimalArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionMaximumArgs = {
  get?: InputMaybe<BitqueryCardanoTransactionsMeasureable>;
  of: BitqueryCardanoTransactionsMeasureable;
};


/** Transaction */
export type BitqueryCardanoTransactionMinimumArgs = {
  get?: InputMaybe<BitqueryCardanoTransactionsMeasureable>;
  of: BitqueryCardanoTransactionsMeasureable;
};


/** Transaction */
export type BitqueryCardanoTransactionMintCountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionMintCountBigIntArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionOutputCountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionOutputCountBigIntArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionOutputValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionOutputValueDecimalArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionTxSizeArgs = {
  txSize?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionWithdrawalCountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionWithdrawalCountBigIntArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionWithdrawalValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionWithdrawalValueDecimalArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};

export type BitqueryCardanoTransactionFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};

/** Blockchain transaction */
export type BitqueryCardanoTransactionHashIndexValues = {
  __typename?: 'BitqueryCardanoTransactionHashIndexValues';
  depositValue: Scalars['Float']['output'];
  /** Transaction deposit value as decimal */
  depositValueDecimal: Scalars['BitqueryDecimalNumberAsDiv']['output'];
  feeValue: Scalars['Float']['output'];
  /** Transaction fee value as decimal */
  feeValueDecimal: Scalars['BitqueryDecimalNumberAsDiv']['output'];
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  includedAt: BitqueryDateTime;
  /** Transaction index in block, 0-based */
  index: Scalars['String']['output'];
  invalidBefore: Scalars['String']['output'];
  invalidHereafter: Scalars['String']['output'];
  metadata: Scalars['String']['output'];
  txSize: Scalars['Int']['output'];
  /** Transaction value in input */
  valueIn: Scalars['Float']['output'];
  /** Transaction value in input as decimal */
  valueInDecimal: Scalars['BitqueryDecimalNumberAsDiv']['output'];
  /** Transaction value in output */
  valueOut: Scalars['Float']['output'];
  /** Transaction value in output as decimal */
  valueOutDecimal: Scalars['BitqueryDecimalNumberAsDiv']['output'];
  withdrawalValue: Scalars['Float']['output'];
  /** Transaction withdraw value as decimal */
  withdrawalValueDecimal: Scalars['BitqueryDecimalNumberAsDiv']['output'];
};

/** Transaction Input */
export type BitqueryCardanoTransactionInput = {
  __typename?: 'BitqueryCardanoTransactionInput';
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Input count */
  count?: Maybe<Scalars['Int']['output']>;
  /** Input count */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of the input */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Input address */
  inputAddress?: Maybe<BitqueryAddress>;
  /** Input index */
  inputIndex?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Output Transaction for this input */
  outputTransaction?: Maybe<BitqueryTransactionHashIndex>;
  /** Source of the input */
  source?: Maybe<BitqueryCardanoInputSource>;
  /** Transaction ID Hash */
  transaction?: Maybe<BitqueryTransactionHashIndex>;
  /** Input value */
  value?: Maybe<Scalars['Float']['output']>;
  /** Input value as decimal */
  valueDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
};


/** Transaction Input */
export type BitqueryCardanoTransactionInputAnyArgs = {
  of: BitqueryCardanoInputsMeasureable;
};


/** Transaction Input */
export type BitqueryCardanoTransactionInputBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transaction Input */
export type BitqueryCardanoTransactionInputCountArgs = {
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inOutputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inOutputTxId?: InputMaybe<BitqueryHashSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inputSource?: InputMaybe<BitqueryCardanoInputSourcenSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryCardanoInputUniq>;
};


/** Transaction Input */
export type BitqueryCardanoTransactionInputCountBigIntArgs = {
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inOutputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inOutputTxId?: InputMaybe<BitqueryHashSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inputSource?: InputMaybe<BitqueryCardanoInputSourcenSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryCardanoInputUniq>;
};


/** Transaction Input */
export type BitqueryCardanoTransactionInputExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transaction Input */
export type BitqueryCardanoTransactionInputInputAddressArgs = {
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
};


/** Transaction Input */
export type BitqueryCardanoTransactionInputInputIndexArgs = {
  inputIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction Input */
export type BitqueryCardanoTransactionInputMaximumArgs = {
  get?: InputMaybe<BitqueryCardanoInputsMeasureable>;
  of: BitqueryCardanoInputsMeasureable;
};


/** Transaction Input */
export type BitqueryCardanoTransactionInputMinimumArgs = {
  get?: InputMaybe<BitqueryCardanoInputsMeasureable>;
  of: BitqueryCardanoInputsMeasureable;
};


/** Transaction Input */
export type BitqueryCardanoTransactionInputOutputTransactionArgs = {
  inOutputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inOutputTxId?: InputMaybe<BitqueryStringIdSelector>;
};


/** Transaction Input */
export type BitqueryCardanoTransactionInputTransactionArgs = {
  txId?: InputMaybe<BitqueryStringIdSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction Input */
export type BitqueryCardanoTransactionInputValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  inOutputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inOutputTxId?: InputMaybe<BitqueryHashSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inputSource?: InputMaybe<BitqueryCardanoInputSourcenSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction Input */
export type BitqueryCardanoTransactionInputValueDecimalArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inOutputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inOutputTxId?: InputMaybe<BitqueryHashSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inputSource?: InputMaybe<BitqueryCardanoInputSourcenSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};

/** Transaction Mint */
export type BitqueryCardanoTransactionMint = {
  __typename?: 'BitqueryCardanoTransactionMint';
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Mint count */
  count?: Maybe<Scalars['Int']['output']>;
  /** Mint count */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of the mint */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Transaction ID Hash */
  transaction?: Maybe<BitqueryTransactionHashIndex>;
  /** Mint value */
  value?: Maybe<Scalars['Float']['output']>;
};


/** Transaction Mint */
export type BitqueryCardanoTransactionMintAnyArgs = {
  of: BitqueryCardanoMintsMeasureable;
};


/** Transaction Mint */
export type BitqueryCardanoTransactionMintBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transaction Mint */
export type BitqueryCardanoTransactionMintCountArgs = {
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryCardanoMintUniq>;
  value?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction Mint */
export type BitqueryCardanoTransactionMintCountBigIntArgs = {
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryCardanoMintUniq>;
  value?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction Mint */
export type BitqueryCardanoTransactionMintExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transaction Mint */
export type BitqueryCardanoTransactionMintMaximumArgs = {
  get?: InputMaybe<BitqueryCardanoMintsMeasureable>;
  of: BitqueryCardanoMintsMeasureable;
};


/** Transaction Mint */
export type BitqueryCardanoTransactionMintMinimumArgs = {
  get?: InputMaybe<BitqueryCardanoMintsMeasureable>;
  of: BitqueryCardanoMintsMeasureable;
};


/** Transaction Mint */
export type BitqueryCardanoTransactionMintTransactionArgs = {
  txId?: InputMaybe<BitqueryStringIdSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction Mint */
export type BitqueryCardanoTransactionMintValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  value?: InputMaybe<BitqueryFloatSelector>;
};

/** Transaction Output */
export type BitqueryCardanoTransactionOutput = {
  __typename?: 'BitqueryCardanoTransactionOutput';
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Output count */
  count?: Maybe<Scalars['Int']['output']>;
  /** Output count */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of the output */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Output address */
  outputAddress?: Maybe<BitqueryAddress>;
  /** Output guessed direction */
  outputDirection?: Maybe<BitqueryCardanoOutputDirection>;
  /** Output index */
  outputIndex?: Maybe<Scalars['Int']['output']>;
  /** Transaction ID Hash */
  transaction?: Maybe<BitqueryTransactionHashIndex>;
  /** Output value */
  value?: Maybe<Scalars['Float']['output']>;
  /** Input value as decimal */
  valueDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
};


/** Transaction Output */
export type BitqueryCardanoTransactionOutputAnyArgs = {
  of: BitqueryCardanoOutputsMeasureable;
};


/** Transaction Output */
export type BitqueryCardanoTransactionOutputBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transaction Output */
export type BitqueryCardanoTransactionOutputCountArgs = {
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputDirection?: InputMaybe<BitqueryCardanoOutputDirectionSelector>;
  outputIndex?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryCardanoOutputUniq>;
};


/** Transaction Output */
export type BitqueryCardanoTransactionOutputCountBigIntArgs = {
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputDirection?: InputMaybe<BitqueryCardanoOutputDirectionSelector>;
  outputIndex?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryCardanoOutputUniq>;
};


/** Transaction Output */
export type BitqueryCardanoTransactionOutputExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transaction Output */
export type BitqueryCardanoTransactionOutputMaximumArgs = {
  get?: InputMaybe<BitqueryCardanoOutputsMeasureable>;
  of: BitqueryCardanoOutputsMeasureable;
};


/** Transaction Output */
export type BitqueryCardanoTransactionOutputMinimumArgs = {
  get?: InputMaybe<BitqueryCardanoOutputsMeasureable>;
  of: BitqueryCardanoOutputsMeasureable;
};


/** Transaction Output */
export type BitqueryCardanoTransactionOutputOutputAddressArgs = {
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
};


/** Transaction Output */
export type BitqueryCardanoTransactionOutputOutputDirectionArgs = {
  outputDirection?: InputMaybe<BitqueryCardanoOutputDirectionSelector>;
};


/** Transaction Output */
export type BitqueryCardanoTransactionOutputOutputIndexArgs = {
  outputIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction Output */
export type BitqueryCardanoTransactionOutputTransactionArgs = {
  txId?: InputMaybe<BitqueryStringIdSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction Output */
export type BitqueryCardanoTransactionOutputValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputDirection?: InputMaybe<BitqueryCardanoOutputDirectionSelector>;
  outputIndex?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction Output */
export type BitqueryCardanoTransactionOutputValueDecimalArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inOutputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inOutputTxId?: InputMaybe<BitqueryHashSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inputSource?: InputMaybe<BitqueryCardanoInputSourcenSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};

export enum BitqueryCardanoTransactionUniq {
  /** Unique block count */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates'
}

export enum BitqueryCardanoTransactionsMeasureable {
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Transaction deposit value */
  DepositValue = 'deposit_value',
  /** Input count */
  InputCount = 'input_count',
  /** Transaction input value */
  InputValue = 'input_value',
  /** Transaction mint count */
  MintCount = 'mint_count',
  /** Output count */
  OutputCount = 'output_count',
  /** Transaction output value */
  OutputValue = 'output_value',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Transaction index */
  TxIndex = 'tx_index',
  /** Transaction size */
  TxSize = 'tx_size',
  /** Transaction withdrawal count */
  WithdrawalCount = 'withdrawal_count',
  /** Transaction withdrawal value */
  WithdrawalValue = 'withdrawal_value'
}

/** Transaction attributes in coinpath */
export type BitqueryCoinpathEntry = {
  __typename?: 'BitqueryCoinpathEntry';
  /** Amount involved in the flow */
  amount: Scalars['Float']['output'];
  /** Block of transaction */
  height: Scalars['Int']['output'];
  /** Time of transaction in ISO 8601 format */
  timestamp: Scalars['BitqueryISO8601DateTime']['output'];
  /** Hash of transaction */
  txHash: Scalars['String']['output'];
  /** Amount transfered in transaction */
  txValue: Scalars['Float']['output'];
};

export enum BitqueryCoinpathMeasureable {
  /** Block */
  Block = 'block',
  /** Depth */
  Depth = 'depth',
  /** Receiver */
  Receiver = 'receiver',
  /** Sender */
  Sender = 'sender',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

/** Limits, Ordering, Constraints, Coinpath Options */
export type BitqueryCoinpathOptions = {
  /** Ordering field(s) for ascending */
  asc?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Converting field(s) to integer datatype and then ordering field(s) for ascending */
  ascByInteger?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Raise error if complexity ( currently measured in transaction count ) is higher than this option */
  complexityLimit?: InputMaybe<Scalars['Int']['input']>;
  /** Ordering field(s) for descending */
  desc?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Converting field(s) to integer datatype and then ordering field(s) for descending */
  descByInteger?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Flow direction */
  direction?: InputMaybe<BitqueryFlowDirection>;
  /** Limit number of results */
  limit?: InputMaybe<Scalars['Int']['input']>;
  /** Limit number of results by specific field */
  limitBy?: InputMaybe<BitqueryLimitByOption>;
  /** Do not expand addresses having count transactions more than this */
  maximumAddressTxCount?: InputMaybe<Scalars['Int']['input']>;
  /** Maximum total transaction count returned */
  maximumTotalTxCount?: InputMaybe<Scalars['Int']['input']>;
  /** Do not include transactions below this amount */
  minimumTxAmount?: InputMaybe<Scalars['Float']['input']>;
  /** Offset of results, starting from 0 */
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Invalidating cache seed */
  seed?: InputMaybe<Scalars['Int']['input']>;
};

/** Conflux Chain */
export type BitqueryConflux = {
  __typename?: 'BitqueryConflux';
  /** Conflux Active Addresses */
  activeAddresses?: Maybe<Array<BitqueryConfluxActiveAddress>>;
  /** Basic information about address ( or smart contract ) */
  address: Array<BitqueryConfluxAddressInfoWithBalance>;
  /** Arguments of Smart Contract Calls and Events */
  arguments?: Maybe<Array<BitqueryConfluxArguments>>;
  /** Blockchain Blocks */
  blocks?: Maybe<Array<BitqueryConfluxBlocks>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryConfluxCoinpath>>;
  /** References of Smart Contract Calls and Events */
  references?: Maybe<Array<BitqueryConfluxReferencess>>;
  /** Smart Contract Calls */
  smartContractCalls?: Maybe<Array<BitqueryConfluxSmartContractCalls>>;
  /** Smart Contract Events */
  smartContractEvents?: Maybe<Array<BitqueryConfluxSmartContractEvent>>;
  /** Blockchain Transactions */
  transactions?: Maybe<Array<BitqueryConfluxTransactions>>;
  /** Currency Transfers */
  transfers?: Maybe<Array<BitqueryConfluxTransfers>>;
};


/** Conflux Chain */
export type BitqueryConfluxActiveAddressesArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryConfluxCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  receiver?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Conflux Chain */
export type BitqueryConfluxAddressArgs = {
  address: Array<BitqueryConfluxAddressSelectorIn>;
};


/** Conflux Chain */
export type BitqueryConfluxArgumentsArgs = {
  any?: InputMaybe<Array<BitqueryConfluxArgumentFilter>>;
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Conflux Chain */
export type BitqueryConfluxBlocksArgs = {
  any?: InputMaybe<Array<BitqueryConfluxBlockFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryBlockSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  options?: InputMaybe<BitqueryQueryOptions>;
  pivot?: InputMaybe<Scalars['Boolean']['input']>;
  refereeCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  referenceBlockHash?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Conflux Chain */
export type BitqueryConfluxCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryConfluxCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryConfluxAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCoinpathOptions>;
  receiver?: InputMaybe<BitqueryConfluxAddressSelector>;
  sender?: InputMaybe<BitqueryConfluxAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Conflux Chain */
export type BitqueryConfluxReferencesArgs = {
  any?: InputMaybe<Array<BitqueryConfluxReferencesFilter>>;
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Conflux Chain */
export type BitqueryConfluxSmartContractCallsArgs = {
  any?: InputMaybe<Array<BitqueryConfluxSmartContractCallFilter>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  smartContractType?: InputMaybe<BitqueryConfluxSmartContractTypeSelector>;
  success?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Conflux Chain */
export type BitqueryConfluxSmartContractEventsArgs = {
  any?: InputMaybe<Array<BitqueryConfluxSmartContractEventFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractType?: InputMaybe<BitqueryConfluxSmartContractTypeSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Conflux Chain */
export type BitqueryConfluxTransactionsArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  any?: InputMaybe<Array<BitqueryConfluxTransactionFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCreates?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Conflux Chain */
export type BitqueryConfluxTransfersArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  any?: InputMaybe<Array<BitqueryConfluxTransferFilter>>;
  currency?: InputMaybe<Array<BitqueryConfluxCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  receiver?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};

/** Address that have been active in transfers */
export type BitqueryConfluxActiveAddress = {
  __typename?: 'BitqueryConfluxActiveAddress';
  /** Transfer address */
  address?: Maybe<BitqueryConfluxAddressInfo>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
};


/** Address that have been active in transfers */
export type BitqueryConfluxActiveAddressCountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryConfluxCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq: BitqueryActiveAddressUniq;
};


/** Address that have been active in transfers */
export type BitqueryConfluxActiveAddressCountBigIntArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryConfluxCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq: BitqueryActiveAddressUniq;
};

/** Address detailed information for Conflux network */
export type BitqueryConfluxAddressInfo = {
  __typename?: 'BitqueryConfluxAddressInfo';
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<BitqueryConfluxSmartContractInfo>;
};

/** Blockchain address */
export type BitqueryConfluxAddressInfoWithBalance = {
  __typename?: 'BitqueryConfluxAddressInfoWithBalance';
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** DEPRECATED Current address balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** DEPRECATED Balances by currencies for the address */
  balances?: Maybe<Array<BitqueryConfluxBalance>>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<BitqueryConfluxSmartContractInfoWithAttributes>;
};


/** Blockchain address */
export type BitqueryConfluxAddressInfoWithBalanceBalanceArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Blockchain address */
export type BitqueryConfluxAddressInfoWithBalanceBalancesArgs = {
  currency?: InputMaybe<BitqueryConfluxCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelectorRange>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

/**
 * Address should start from cfx: and contain hex digits.
 *   If digits are case sensitive, address is checked against checksum according to EIP-55.
 */
export type BitqueryConfluxAddressSelector = {
  /** In the list of Addresses */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Equal to Address */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Not Equal to Address */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Not in the list of Addresses */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/**
 * Address should start from cfx: and contain hex digits.
 *   If digits are case sensitive, address is checked against checksum according to EIP-55.
 */
export type BitqueryConfluxAddressSelectorIn = {
  /** In the list of Addresses */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Equal to Address */
  is?: InputMaybe<Scalars['String']['input']>;
};

export type BitqueryConfluxArgumentFilter = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};

/** Argument name and value of smart contract call or event */
export type BitqueryConfluxArgumentNameValue = {
  __typename?: 'BitqueryConfluxArgumentNameValue';
  /** Argument name */
  argument: Scalars['String']['output'];
  /** Argument data type */
  argumentType: Scalars['String']['output'];
  /** Sequential index of value in array ( multi-dimensional) */
  index: Scalars['String']['output'];
  /** Value as String */
  value: Scalars['String']['output'];
};

/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArguments = {
  __typename?: 'BitqueryConfluxArguments';
  any?: Maybe<Scalars['String']['output']>;
  /** Method or event argument */
  argument?: Maybe<BitqueryArgumentName>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callDepth?: Maybe<Scalars['String']['output']>;
  /** Caller of the method invocation ( tx sender or another smart contract ) */
  caller?: Maybe<BitqueryConfluxAddressInfo>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']['output']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** External call executed explicitly by tx sender. Internal calls executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']['output']>;
  /** Sequential index of value in array ( multi-dimensional) */
  index: Scalars['String']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  number?: Maybe<Scalars['Float']['output']>;
  /** Address value of method or event argument */
  reference?: Maybe<BitqueryConfluxAddressInfo>;
  /** Smart contract being called */
  smartContract?: Maybe<BitqueryConfluxSmartContract>;
  /** Contract method or event */
  smartContractSignature?: Maybe<BitquerySignature>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction where call happened */
  transaction?: Maybe<BitqueryConfluxTransactionInfo>;
  /** The Value of method or event argument */
  value?: Maybe<BitqueryArgumentValue>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArgumentsAnyArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  as?: InputMaybe<BitqueryConfluxArgumentsConvertable>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  of: BitqueryConfluxArgumentsMeasureable;
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArgumentsArgumentArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Scalars['String']['input']>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArgumentsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArgumentsCallerArgs = {
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArgumentsCountArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitquerySmartContractArgumentsUniq>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArgumentsCountBigIntArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitquerySmartContractArgumentsUniq>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArgumentsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArgumentsExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArgumentsMaximumArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  as?: InputMaybe<BitqueryConfluxArgumentsConvertable>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  get?: InputMaybe<BitqueryConfluxArgumentsMeasureable>;
  height?: InputMaybe<BitqueryBlockSelector>;
  of: BitqueryConfluxArgumentsMeasureable;
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArgumentsMinimumArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  as?: InputMaybe<BitqueryConfluxArgumentsConvertable>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  get?: InputMaybe<BitqueryConfluxArgumentsMeasureable>;
  height?: InputMaybe<BitqueryBlockSelector>;
  of: BitqueryConfluxArgumentsMeasureable;
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArgumentsNumberArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArgumentsReferenceArgs = {
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArgumentsSmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArgumentsSmartContractSignatureArgs = {
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArgumentsSuccessArgs = {
  success?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArgumentsTransactionArgs = {
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArgumentsValueArgs = {
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};

export enum BitqueryConfluxArgumentsConvertable {
  /** Token name */
  TokenName = 'token_name',
  /** Token symbol */
  TokenSymbol = 'token_symbol'
}

export enum BitqueryConfluxArgumentsMeasureable {
  /** Argument */
  Argument = 'argument',
  /** Argument index */
  ArgumentIndex = 'argument_index',
  /** Argument type */
  ArgumentType = 'argument_type',
  /** Argument value */
  ArgumentValue = 'argument_value',
  /** Block */
  Block = 'block',
  /** Call depth */
  CallDepth = 'call_depth',
  /** Caller */
  Caller = 'caller',
  /** Date */
  Date = 'date',
  /** Smart Contract Method Signature */
  Signature = 'signature',
  /** Smart Contract Method Signature Hash */
  SignatureHash = 'signature_hash',
  /** Smart Contract Method Name */
  SignatureName = 'signature_name',
  /** Smart Contract Method Signature */
  SignatureType = 'signature_type',
  /** Smart Contract */
  SmartContract = 'smart_contract',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

/** Balance in a currency */
export type BitqueryConfluxBalance = {
  __typename?: 'BitqueryConfluxBalance';
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** History of balance changes by currencies for the address */
  history?: Maybe<Array<BitqueryConfluxBalanceChange>>;
  value?: Maybe<Scalars['Float']['output']>;
};


/** Balance in a currency */
export type BitqueryConfluxBalanceValueArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};

/** Change of balance in a currency */
export type BitqueryConfluxBalanceChange = {
  __typename?: 'BitqueryConfluxBalanceChange';
  /** Block number (height) in blockchain */
  block: Scalars['Int']['output'];
  /** Block timestamp */
  timestamp?: Maybe<Scalars['BitqueryISO8601DateTime']['output']>;
  /** Transfer amount ( positive inbound, negative outbound) */
  transferAmount?: Maybe<Scalars['Float']['output']>;
  value?: Maybe<Scalars['Float']['output']>;
};

export type BitqueryConfluxBlockFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryBlockSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  pivot?: InputMaybe<Scalars['Boolean']['input']>;
  refereeCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  referenceBlockHash?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};

/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocks = {
  __typename?: 'BitqueryConfluxBlocks';
  /** Block is adaptive */
  adaptive: Scalars['Boolean']['output'];
  any?: Maybe<Scalars['String']['output']>;
  /** Blame */
  blame: Scalars['Int']['output'];
  /** Block index in epoch */
  blockPosition: Scalars['Int']['output'];
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Epoch in blockchain */
  epoch: Scalars['Int']['output'];
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Block hash */
  hash: Scalars['String']['output'];
  /** Block height in blockchain */
  height: Scalars['Int']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  /** Block miner */
  miner?: Maybe<BitqueryEthereumAddressInfo>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Block nonce */
  nonce: Scalars['Int']['output'];
  /** Parent block hash */
  parentHash: Scalars['String']['output'];
  /** Block is pivot */
  pivot: Scalars['Boolean']['output'];
  /** Power Quality */
  powerQuality: Scalars['BitqueryBigInt']['output'];
  refereeCount?: Maybe<Scalars['Int']['output']>;
  refereeCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Reference Block hash */
  referenceBlockHash: Scalars['String']['output'];
  size?: Maybe<Scalars['Int']['output']>;
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  totalDifficulty?: Maybe<Scalars['Float']['output']>;
  transactionCount?: Maybe<Scalars['Int']['output']>;
  transactionCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Hash of Transaction included in block */
  txHash: Scalars['String']['output'];
  uncleCount?: Maybe<Scalars['Int']['output']>;
  uncleCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksAnyArgs = {
  of: BitqueryConfluxBlocksMeasureable;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryBlockSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  pivot?: InputMaybe<Scalars['Boolean']['input']>;
  refereeCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  referenceBlockHash?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uniq?: InputMaybe<BitqueryEthereumBlocksUniq>;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryBlockSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  pivot?: InputMaybe<Scalars['Boolean']['input']>;
  refereeCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  referenceBlockHash?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uniq?: InputMaybe<BitqueryEthereumBlocksUniq>;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksEpochArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksHashArgs = {
  blockHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksHeightArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksMaximumArgs = {
  get?: InputMaybe<BitqueryConfluxBlocksMeasureable>;
  of: BitqueryConfluxBlocksMeasureable;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksMinerArgs = {
  miner?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksMinimumArgs = {
  get?: InputMaybe<BitqueryConfluxBlocksMeasureable>;
  of: BitqueryConfluxBlocksMeasureable;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksRefereeCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryBlockSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  pivot?: InputMaybe<Scalars['Boolean']['input']>;
  refereeCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  referenceBlockHash?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksRefereeCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryBlockSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  pivot?: InputMaybe<Scalars['Boolean']['input']>;
  refereeCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  referenceBlockHash?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksReferenceBlockHashArgs = {
  referenceBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksSizeArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryBlockSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  pivot?: InputMaybe<Scalars['Boolean']['input']>;
  refereeCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  referenceBlockHash?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksTimestampArgs = {
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksTotalDifficultyArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryBlockSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  pivot?: InputMaybe<Scalars['Boolean']['input']>;
  refereeCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  referenceBlockHash?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksTransactionCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryBlockSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  pivot?: InputMaybe<Scalars['Boolean']['input']>;
  refereeCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  referenceBlockHash?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksTransactionCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryBlockSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  pivot?: InputMaybe<Scalars['Boolean']['input']>;
  refereeCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  referenceBlockHash?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksTxHashArgs = {
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksUncleCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryBlockSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  pivot?: InputMaybe<Scalars['Boolean']['input']>;
  refereeCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  referenceBlockHash?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksUncleCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryBlockSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  pivot?: InputMaybe<Scalars['Boolean']['input']>;
  refereeCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  referenceBlockHash?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};

export enum BitqueryConfluxBlocksMeasureable {
  /** Block */
  Block = 'block',
  /** Block hash */
  BlockHash = 'block_hash',
  /** Date */
  Date = 'date',
  /** Block Miner */
  Miner = 'miner',
  /** Block Referee Count */
  RefereeCount = 'referee_count',
  /** Time */
  Time = 'time',
  /** Block TX Count */
  TransactionCount = 'transaction_count'
}

export enum BitqueryConfluxCallsMeasureable {
  /** Block */
  Block = 'block',
  /** Call depth */
  CallDepth = 'call_depth',
  /** Caller */
  Caller = 'caller',
  /** Date */
  Date = 'date',
  /** Smart Contract Method Signature */
  Signature = 'signature',
  /** Smart Contract Method Signature Hash */
  SignatureHash = 'signature_hash',
  /** Smart Contract Method Name */
  SignatureName = 'signature_name',
  /** Smart Contract */
  SmartContract = 'smart_contract',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

/** Coinpath */
export type BitqueryConfluxCoinpath = {
  __typename?: 'BitqueryConfluxCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryConfluxCoinpathAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryConfluxCoinpathAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<BitqueryTransactionHashValueTime>;
  /** Attributes of transaction included in Coinpath result */
  transactions?: Maybe<Array<BitqueryCoinpathEntry>>;
};


/** Coinpath */
export type BitqueryConfluxCoinpathAmountArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Coinpath */
export type BitqueryConfluxCoinpathAnyArgs = {
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryConfluxCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryConfluxCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};

/** Address detailed information for Conflux network */
export type BitqueryConfluxCoinpathAddress = {
  __typename?: 'BitqueryConfluxCoinpathAddress';
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  amountIn?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  amountOut?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  balance?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Smart Contract if exists on the address */
  firstTxAt?: Maybe<BitqueryDateTime>;
  /** Smart Contract if exists on the address */
  lastTxAt?: Maybe<BitqueryDateTime>;
  receiversCount?: Maybe<Scalars['Int']['output']>;
  sendersCount?: Maybe<Scalars['Int']['output']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<BitqueryConfluxSmartContractInfo>;
  /** Address type */
  type?: Maybe<Scalars['String']['output']>;
};

/**
 * Currency selector in Conflux blockchain.
 *   Currencies supported are native ( CFX ), ERC20, ERC721 tokens.
 *   You can specify currency symbol or smart contract address. Symbols CFX are reserved for native currencies in Conflux mainnet and classic.
 *   Conflux Smart contract address should start from cfx: and contain 42 symbols.
 *   If digits are case sensitive, address is checked against checksum according to EIP-55.
 */
export type BitqueryConfluxCurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Currency not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export enum BitqueryConfluxEventsMeasureable {
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Smart Contract Event Signature */
  Signature = 'signature',
  /** Smart Contract Event Signature Hash */
  SignatureHash = 'signature_hash',
  /** Smart Contract Event Name */
  SignatureName = 'signature_name',
  /** Smart Contract */
  SmartContract = 'smart_contract',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

export enum BitqueryConfluxNetwork {
  /** Conflux Hydra */
  ConfluxHydra = 'conflux_hydra',
  /** Conflux Oceanus */
  ConfluxOceanus = 'conflux_oceanus',
  /** Conflux Tethys */
  ConfluxTethys = 'conflux_tethys'
}

export type BitqueryConfluxReferencesFilter = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};

/** Address value of method or event argument */
export type BitqueryConfluxReferencess = {
  __typename?: 'BitqueryConfluxReferencess';
  any?: Maybe<Scalars['String']['output']>;
  /** Method or event argument */
  argument?: Maybe<BitqueryArgumentName>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callDepth?: Maybe<Scalars['String']['output']>;
  /** Caller of the method invocation ( tx sender or another smart contract ) */
  caller?: Maybe<BitqueryConfluxAddressInfo>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']['output']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** External call executed explicitly by tx sender. Internal calls executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']['output']>;
  /** Sequential index of value in array ( multi-dimensional) */
  index: Scalars['String']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  number?: Maybe<Scalars['Float']['output']>;
  /** Address value of method or event argument */
  reference?: Maybe<BitqueryConfluxAddressInfo>;
  /** Smart contract being called */
  smartContract?: Maybe<BitqueryEthereumSmartContract>;
  /** Contract method or event */
  smartContractSignature?: Maybe<BitquerySignature>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction where call happened */
  transaction?: Maybe<BitqueryEthereumTransactionInfo>;
};


/** Address value of method or event argument */
export type BitqueryConfluxReferencessAnyArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  as?: InputMaybe<BitqueryConfluxReferencessConvertable>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  of: BitqueryConfluxReferencessMeasureable;
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type BitqueryConfluxReferencessArgumentArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Scalars['String']['input']>;
};


/** Address value of method or event argument */
export type BitqueryConfluxReferencessBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Address value of method or event argument */
export type BitqueryConfluxReferencessCallerArgs = {
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Address value of method or event argument */
export type BitqueryConfluxReferencessCountArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitquerySmartContractArgumentsUniq>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type BitqueryConfluxReferencessCountBigIntArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitquerySmartContractArgumentsUniq>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type BitqueryConfluxReferencessExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Address value of method or event argument */
export type BitqueryConfluxReferencessExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Address value of method or event argument */
export type BitqueryConfluxReferencessMaximumArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  as?: InputMaybe<BitqueryConfluxReferencessConvertable>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  get?: InputMaybe<BitqueryConfluxReferencessMeasureable>;
  height?: InputMaybe<BitqueryBlockSelector>;
  of: BitqueryConfluxReferencessMeasureable;
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type BitqueryConfluxReferencessMinimumArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  as?: InputMaybe<BitqueryConfluxReferencessConvertable>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  get?: InputMaybe<BitqueryConfluxReferencessMeasureable>;
  height?: InputMaybe<BitqueryBlockSelector>;
  of: BitqueryConfluxReferencessMeasureable;
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type BitqueryConfluxReferencessNumberArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type BitqueryConfluxReferencessReferenceArgs = {
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Address value of method or event argument */
export type BitqueryConfluxReferencessSmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Address value of method or event argument */
export type BitqueryConfluxReferencessSmartContractSignatureArgs = {
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
};


/** Address value of method or event argument */
export type BitqueryConfluxReferencessSuccessArgs = {
  success?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};


/** Address value of method or event argument */
export type BitqueryConfluxReferencessTransactionArgs = {
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};

export enum BitqueryConfluxReferencessConvertable {
  /** Token name */
  TokenName = 'token_name',
  /** Token symbol */
  TokenSymbol = 'token_symbol'
}

export enum BitqueryConfluxReferencessMeasureable {
  /** Argument index */
  ArgumentIndex = 'argument_index',
  /** Argument type */
  ArgumentType = 'argument_type',
  /** Argument value */
  ArgumentValue = 'argument_value',
  /** Block */
  Block = 'block',
  /** Call depth */
  CallDepth = 'call_depth',
  /** Caller */
  Caller = 'caller',
  /** Date */
  Date = 'date',
  /** Smart Contract Method Signature */
  Signature = 'signature',
  /** Smart Contract Method Signature Hash */
  SignatureHash = 'signature_hash',
  /** Smart Contract Method Name */
  SignatureName = 'signature_name',
  /** Smart Contract Method Signature */
  SignatureType = 'signature_type',
  /** Smart Contract */
  SmartContract = 'smart_contract',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

/** Conflux smart contract */
export type BitqueryConfluxSmartContract = {
  __typename?: 'BitqueryConfluxSmartContract';
  /** Smart Contract Address */
  address: BitqueryAddress;
  /** Smart Contract Type */
  contractType?: Maybe<BitquerySmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<BitqueryScCurrency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']['output']>;
};

export type BitqueryConfluxSmartContractCallFilter = {
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  smartContractType?: InputMaybe<BitqueryConfluxSmartContractTypeSelector>;
  success?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};

/** Smart Contract Calls */
export type BitqueryConfluxSmartContractCalls = {
  __typename?: 'BitqueryConfluxSmartContractCalls';
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Call arguments */
  arguments?: Maybe<Array<BitqueryConfluxArgumentNameValue>>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callDepth?: Maybe<Scalars['String']['output']>;
  /** Caller of the method invocation ( tx sender or another smart contract ) */
  caller?: Maybe<BitqueryConfluxAddressInfo>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']['output']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** External call executed explicitly by tx sender. Internal calls executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']['output']>;
  /** Gas used for transaction in external call, or by methd in internal call */
  gasValue?: Maybe<Scalars['Float']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Smart contract being called */
  smartContract?: Maybe<BitqueryConfluxSmartContract>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<BitqueryMethod>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction where call happened */
  transaction?: Maybe<BitqueryConfluxTransactionInfo>;
};


/** Smart Contract Calls */
export type BitqueryConfluxSmartContractCallsAmountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  smartContractType?: InputMaybe<BitqueryConfluxSmartContractTypeSelector>;
  success?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Smart Contract Calls */
export type BitqueryConfluxSmartContractCallsAnyArgs = {
  of: BitqueryConfluxCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryConfluxSmartContractCallsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Smart Contract Calls */
export type BitqueryConfluxSmartContractCallsCallerArgs = {
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Smart Contract Calls */
export type BitqueryConfluxSmartContractCallsCountArgs = {
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  smartContractType?: InputMaybe<BitqueryConfluxSmartContractTypeSelector>;
  success?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type BitqueryConfluxSmartContractCallsCountBigIntArgs = {
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  smartContractType?: InputMaybe<BitqueryConfluxSmartContractTypeSelector>;
  success?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type BitqueryConfluxSmartContractCallsExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Smart Contract Calls */
export type BitqueryConfluxSmartContractCallsGasValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  smartContractType?: InputMaybe<BitqueryConfluxSmartContractTypeSelector>;
  success?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Smart Contract Calls */
export type BitqueryConfluxSmartContractCallsMaximumArgs = {
  get?: InputMaybe<BitqueryConfluxCallsMeasureable>;
  of: BitqueryConfluxCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryConfluxSmartContractCallsMinimumArgs = {
  get?: InputMaybe<BitqueryConfluxCallsMeasureable>;
  of: BitqueryConfluxCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryConfluxSmartContractCallsSmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Smart Contract Calls */
export type BitqueryConfluxSmartContractCallsSmartContractMethodArgs = {
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
};


/** Smart Contract Calls */
export type BitqueryConfluxSmartContractCallsSuccessArgs = {
  success?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};


/** Smart Contract Calls */
export type BitqueryConfluxSmartContractCallsTransactionArgs = {
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};

/** Smart Contract Events */
export type BitqueryConfluxSmartContractEvent = {
  __typename?: 'BitqueryConfluxSmartContractEvent';
  any?: Maybe<Scalars['String']['output']>;
  /** Event arguments */
  arguments?: Maybe<Array<BitqueryConfluxArgumentNameValue>>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']['output']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Smart contract being called */
  smartContract?: Maybe<BitqueryConfluxSmartContract>;
  /** Contract event logged */
  smartContractEvent?: Maybe<BitqueryEvent>;
  /** Transaction where event happened */
  transaction?: Maybe<BitqueryConfluxTransactionInfo>;
};


/** Smart Contract Events */
export type BitqueryConfluxSmartContractEventAnyArgs = {
  of: BitqueryConfluxEventsMeasureable;
};


/** Smart Contract Events */
export type BitqueryConfluxSmartContractEventBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Smart Contract Events */
export type BitqueryConfluxSmartContractEventCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractType?: InputMaybe<BitqueryConfluxSmartContractTypeSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Smart Contract Events */
export type BitqueryConfluxSmartContractEventCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractType?: InputMaybe<BitqueryConfluxSmartContractTypeSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Smart Contract Events */
export type BitqueryConfluxSmartContractEventMaximumArgs = {
  get?: InputMaybe<BitqueryConfluxEventsMeasureable>;
  of: BitqueryConfluxEventsMeasureable;
};


/** Smart Contract Events */
export type BitqueryConfluxSmartContractEventMinimumArgs = {
  get?: InputMaybe<BitqueryConfluxEventsMeasureable>;
  of: BitqueryConfluxEventsMeasureable;
};


/** Smart Contract Events */
export type BitqueryConfluxSmartContractEventSmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Smart Contract Events */
export type BitqueryConfluxSmartContractEventSmartContractEventArgs = {
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
};


/** Smart Contract Events */
export type BitqueryConfluxSmartContractEventTransactionArgs = {
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};

export type BitqueryConfluxSmartContractEventFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractType?: InputMaybe<BitqueryConfluxSmartContractTypeSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};

/** Blockchain smart contract */
export type BitqueryConfluxSmartContractInfo = {
  __typename?: 'BitqueryConfluxSmartContractInfo';
  /** Smart Contract Type */
  contractType?: Maybe<BitquerySmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<BitqueryScCurrency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']['output']>;
};

export type BitqueryConfluxSmartContractInfoWithAttribute = {
  __typename?: 'BitqueryConfluxSmartContractInfoWithAttribute';
  /** Value as address if applicable */
  address?: Maybe<BitqueryConfluxAddressInfo>;
  /** Method name */
  name: Scalars['String']['output'];
  /** Method return type */
  type: Scalars['String']['output'];
  /** Method return value */
  value: Scalars['String']['output'];
};

/** Blockchain smart contract */
export type BitqueryConfluxSmartContractInfoWithAttributes = {
  __typename?: 'BitqueryConfluxSmartContractInfoWithAttributes';
  /** Attributes from readonly methods */
  attributes?: Maybe<Array<BitqueryConfluxSmartContractInfoWithAttribute>>;
  /** Smart Contract Type */
  contractType?: Maybe<BitquerySmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<BitqueryScCurrency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']['output']>;
};

/** Selector of smart contract type */
export type BitqueryConfluxSmartContractTypeSelector = {
  /** Smart Contract type in the list */
  in?: InputMaybe<Array<BitquerySmartContractType>>;
  /** Smart Contract type is */
  is?: InputMaybe<BitquerySmartContractType>;
  /** Smart Contract type not */
  not?: InputMaybe<BitquerySmartContractType>;
  /** Smart Contract type not in the list */
  notIn?: InputMaybe<Array<BitquerySmartContractType>>;
};

export type BitqueryConfluxTransactionFilter = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCreates?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};

/** Blockchain transaction info */
export type BitqueryConfluxTransactionInfo = {
  __typename?: 'BitqueryConfluxTransactionInfo';
  /** Gas consumed */
  gas: Scalars['Int']['output'];
  /** Gas price in Gwei */
  gasPrice: Scalars['Float']['output'];
  /** Gas value cost */
  gasValue: Scalars['Float']['output'];
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction from address */
  txFrom: BitqueryConfluxAddressInfo;
};

/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactions = {
  __typename?: 'BitqueryConfluxTransactions';
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BitqueryBlockInfo>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Created smart contract */
  creates?: Maybe<BitqueryEthereumAddressInfo>;
  /** Currency of amount */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Error message if any */
  error?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  gas?: Maybe<Scalars['Int']['output']>;
  /** Currency of gas */
  gasCurrency?: Maybe<BitqueryCurrency>;
  /** Gas price in Gwei */
  gasPrice: Scalars['Float']['output'];
  gasValue?: Maybe<Scalars['Float']['output']>;
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction index in block, 0 based */
  index?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Transaction nonce */
  nonce?: Maybe<Scalars['Int']['output']>;
  /** Transaction sender */
  sender?: Maybe<BitqueryEthereumAddressInfo>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction receiver */
  to?: Maybe<BitqueryEthereumAddressInfo>;
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsAmountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCreates?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsAnyArgs = {
  of: BitqueryConfluxTransactionsMeasureable;
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsBlockArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsCountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCreates?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  uniq?: InputMaybe<BitqueryEthereumTransactionsUniq>;
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsCountBigIntArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCreates?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  uniq?: InputMaybe<BitqueryEthereumTransactionsUniq>;
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsCreatesArgs = {
  txCreates?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsGasArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCreates?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsGasCurrencyArgs = {
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsGasPriceArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCreates?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsGasValueArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCreates?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsHashArgs = {
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsIndexArgs = {
  txIndex?: InputMaybe<Array<BitqueryTxIndexSelector>>;
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsMaximumArgs = {
  get?: InputMaybe<BitqueryConfluxTransactionsMeasureable>;
  of: BitqueryConfluxTransactionsMeasureable;
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsMinimumArgs = {
  get?: InputMaybe<BitqueryConfluxTransactionsMeasureable>;
  of: BitqueryConfluxTransactionsMeasureable;
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsSenderArgs = {
  txSender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsToArgs = {
  txTo?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};

export enum BitqueryConfluxTransactionsMeasureable {
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Gas used */
  Gas = 'gas',
  /** Gas price */
  GasPrice = 'gas_price',
  /** Gas value */
  GasValue = 'gas_value',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Transaction Sender */
  TxSender = 'tx_sender'
}

export type BitqueryConfluxTransferFilter = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryConfluxCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};

/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryConfluxTransfers = {
  __typename?: 'BitqueryConfluxTransfers';
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BitqueryBlock>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Entity identifier ( for ERC-721 NFT tokens ) */
  entityId?: Maybe<Scalars['String']['output']>;
  /** External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']['output']>;
  gasValue?: Maybe<Scalars['Float']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Transfer receiver */
  receiver?: Maybe<BitqueryConfluxAddressInfo>;
  /** Transfer sender */
  sender?: Maybe<BitqueryConfluxAddressInfo>;
  /** Success flag */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction where transfer happened */
  transaction?: Maybe<BitqueryConfluxTransactionInfo>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryConfluxTransfersAmountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<Array<BitqueryConfluxCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  receiver?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryConfluxTransfersAnyArgs = {
  of: BitqueryConfluxTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryConfluxTransfersBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryConfluxTransfersCountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryConfluxCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryTransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryConfluxTransfersCountBigIntArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryConfluxCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryTransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryConfluxTransfersCurrencyArgs = {
  currency?: InputMaybe<Array<BitqueryConfluxCurrencySelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryConfluxTransfersEntityIdArgs = {
  entityId?: InputMaybe<BitqueryEntitySelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryConfluxTransfersExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryConfluxTransfersGasValueArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<Array<BitqueryConfluxCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  receiver?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryConfluxTransfersMaximumArgs = {
  get?: InputMaybe<BitqueryConfluxTransfersMeasureable>;
  of: BitqueryConfluxTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryConfluxTransfersMinimumArgs = {
  get?: InputMaybe<BitqueryConfluxTransfersMeasureable>;
  of: BitqueryConfluxTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryConfluxTransfersReceiverArgs = {
  receiver?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryConfluxTransfersSenderArgs = {
  sender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryConfluxTransfersSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryConfluxTransfersTransactionArgs = {
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};

export enum BitqueryConfluxTransfersMeasureable {
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Token address */
  CurrencyAddress = 'currency_address',
  /** Currency symbol */
  CurrencySymbol = 'currency_symbol',
  /** Date */
  Date = 'date',
  /** Entity ID */
  EntityId = 'entity_id',
  /** Receiver */
  Receiver = 'receiver',
  /** Sender */
  Sender = 'sender',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

/** Cosmos Blockchain */
export type BitqueryCosmos = {
  __typename?: 'BitqueryCosmos';
  /** Basic information about address */
  address: Array<BitqueryCosmosAddressInfo>;
  /** Cosmos Attributes */
  attributes?: Maybe<Array<BitqueryCosmosAttribute>>;
  /** Cosmos Blocks */
  blocks?: Maybe<Array<BitqueryCosmosBlock>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryCosmosCoinpath>>;
  /** Cosmos Messages */
  messages?: Maybe<Array<BitqueryCosmosMessage>>;
  /** Cosmos Transactions */
  transactions?: Maybe<Array<BitqueryCosmosTransaction>>;
  /** Cosmos Transfers */
  transfers?: Maybe<Array<BitqueryCosmosTransfers>>;
};


/** Cosmos Blockchain */
export type BitqueryCosmosAddressArgs = {
  address: Array<BitqueryAddressSelectorIn>;
};


/** Cosmos Blockchain */
export type BitqueryCosmosAttributesArgs = {
  any?: InputMaybe<Array<BitqueryCosmosAttributeFilter>>;
  attribute?: InputMaybe<BitqueryStringSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  eventType?: InputMaybe<BitqueryStringSelector>;
  messageIndex?: InputMaybe<BitqueryIntegerSelector>;
  messageType?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  senders?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSigner?: InputMaybe<BitqueryStringSelector>;
  value?: InputMaybe<BitqueryStringSelector>;
  valueIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Cosmos Blockchain */
export type BitqueryCosmosBlocksArgs = {
  any?: InputMaybe<Array<BitqueryCosmosBlocksFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  proposer?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Cosmos Blockchain */
export type BitqueryCosmosCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryCosmosCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCoinpathOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Cosmos Blockchain */
export type BitqueryCosmosMessagesArgs = {
  any?: InputMaybe<Array<BitqueryCosmosMessageFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  senders?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSigner?: InputMaybe<BitqueryAddressSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Cosmos Blockchain */
export type BitqueryCosmosTransactionsArgs = {
  any?: InputMaybe<Array<BitqueryCosmosTransactionFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  code?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryAmountSelector>;
  gasUsed?: InputMaybe<BitqueryIntegerSelector>;
  gasWanted?: InputMaybe<BitqueryIntegerSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  memo?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  signer?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Cosmos Blockchain */
export type BitqueryCosmosTransfersArgs = {
  any?: InputMaybe<Array<BitqueryCosmosTransferFilter>>;
  block?: InputMaybe<BitqueryBlockSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  currency?: InputMaybe<BitqueryCosmosCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  senders?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSigner?: InputMaybe<BitqueryAddressSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  typeTransfer?: InputMaybe<BitqueryBooleanSelector>;
  value?: InputMaybe<BitqueryAmountSelector>;
};

/** Address detailed information for Cosmos network */
export type BitqueryCosmosAddressInfo = {
  __typename?: 'BitqueryCosmosAddressInfo';
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Native currency balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** Tokens Info */
  tokensInfo?: Maybe<Array<BitqueryCosmosTokensInfo>>;
};


/** Address detailed information for Cosmos network */
export type BitqueryCosmosAddressInfoBalanceArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};

/** Attribute in Cosmos blockchain */
export type BitqueryCosmosAttribute = {
  __typename?: 'BitqueryCosmosAttribute';
  any?: Maybe<Scalars['String']['output']>;
  /** Attribute */
  attribute?: Maybe<Scalars['String']['output']>;
  /** Block info where transaction included */
  block?: Maybe<BitqueryCosmosBlockDimension>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  /** Type of the attribute */
  eventType?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Message info */
  message?: Maybe<BitqueryCosmosMessageDimension>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Transaction info where message included */
  transaction?: Maybe<BitqueryCosmosTransactionDimension>;
  /** Attribute value */
  value?: Maybe<Scalars['String']['output']>;
  /** Index of attribute */
  valueIndex: Scalars['Int']['output'];
};


/** Attribute in Cosmos blockchain */
export type BitqueryCosmosAttributeAnyArgs = {
  of: BitqueryCosmosAttributesMeasurable;
};


/** Attribute in Cosmos blockchain */
export type BitqueryCosmosAttributeCountArgs = {
  attribute?: InputMaybe<BitqueryStringSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  eventType?: InputMaybe<BitqueryStringSelector>;
  messageIndex?: InputMaybe<BitqueryIntegerSelector>;
  messageType?: InputMaybe<BitqueryStringSelector>;
  senders?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSigner?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryCosmosAttributeUniq>;
  value?: InputMaybe<BitqueryStringSelector>;
  valueIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Attribute in Cosmos blockchain */
export type BitqueryCosmosAttributeCountBigIntArgs = {
  attribute?: InputMaybe<BitqueryStringSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  eventType?: InputMaybe<BitqueryStringSelector>;
  messageIndex?: InputMaybe<BitqueryIntegerSelector>;
  messageType?: InputMaybe<BitqueryStringSelector>;
  senders?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSigner?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryCosmosAttributeUniq>;
  value?: InputMaybe<BitqueryStringSelector>;
  valueIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Attribute in Cosmos blockchain */
export type BitqueryCosmosAttributeExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Attribute in Cosmos blockchain */
export type BitqueryCosmosAttributeMaximumArgs = {
  get?: InputMaybe<BitqueryCosmosAttributesMeasurable>;
  of: BitqueryCosmosAttributesMeasurable;
};


/** Attribute in Cosmos blockchain */
export type BitqueryCosmosAttributeMinimumArgs = {
  get?: InputMaybe<BitqueryCosmosAttributesMeasurable>;
  of: BitqueryCosmosAttributesMeasurable;
};

export type BitqueryCosmosAttributeFilter = {
  attribute?: InputMaybe<BitqueryStringSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  eventType?: InputMaybe<BitqueryStringSelector>;
  messageIndex?: InputMaybe<BitqueryIntegerSelector>;
  messageType?: InputMaybe<BitqueryStringSelector>;
  senders?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSigner?: InputMaybe<BitqueryStringSelector>;
  value?: InputMaybe<BitqueryStringSelector>;
  valueIndex?: InputMaybe<BitqueryIntegerSelector>;
};

export enum BitqueryCosmosAttributeUniq {
  /** Unique attributes */
  Attributes = 'attributes',
  /** Unique block hashes */
  BlockHashes = 'blockHashes',
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates',
  /** Unique event types */
  EventTypes = 'eventTypes',
  /** Unique message indices */
  MessageIndices = 'messageIndices',
  /** Unique message senders */
  MessageSenders = 'messageSenders',
  /** Unique message types */
  MessageTypes = 'messageTypes',
  /** Unique time */
  Times = 'times',
  /** Unique transaction hashes */
  TransactionHashes = 'transactionHashes',
  /** Unique transaction indices */
  TransactionIndices = 'transactionIndices',
  /** Unique transaction signers */
  TransactionSigners = 'transactionSigners',
  /** Unique value indices */
  ValueIndices = 'valueIndices',
  /** Unique values */
  Values = 'values'
}

export enum BitqueryCosmosAttributesMeasurable {
  /**  attribute  */
  Attribute = 'attribute',
  /** Number of block in the blockhains */
  Block = 'block',
  /** Hash of the block */
  BlockHash = 'blockHash',
  /** Date */
  Date = 'date',
  /** Type of attr */
  EventType = 'eventType',
  /** Message index in transaction */
  MessageIndex = 'messageIndex',
  /** Message senders */
  MessageSenders = 'messageSenders',
  /** Message success */
  MessageSuccess = 'messageSuccess',
  /** Type of message */
  MessageType = 'messageType',
  /** Time */
  Time = 'time',
  /** Hash of the transaction */
  TransactionHash = 'transactionHash',
  /** Index of the transaction in block */
  TransactionIndex = 'transactionIndex',
  /** Transaction Signer */
  TransactionSigner = 'transactionSigner',
  /** attributeValue */
  Value = 'value',
  /** valueIndex */
  ValueIndex = 'valueIndex'
}

/** Block */
export type BitqueryCosmosBlock = {
  __typename?: 'BitqueryCosmosBlock';
  any?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Block Hash */
  hash?: Maybe<Scalars['String']['output']>;
  /** Block Header */
  header?: Maybe<Scalars['String']['output']>;
  /** Block number (height) in blockchain */
  height: Scalars['Int']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  /** Block Metadata */
  metadata?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Proposer Address */
  proposer?: Maybe<BitqueryAddress>;
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
};


/** Block */
export type BitqueryCosmosBlockAnyArgs = {
  of: BitqueryCosmosBlockMeasurable;
};


/** Block */
export type BitqueryCosmosBlockCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  proposer?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryCosmosBlockUniq>;
};


/** Block */
export type BitqueryCosmosBlockCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  proposer?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryCosmosBlockUniq>;
};


/** Block */
export type BitqueryCosmosBlockExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Block */
export type BitqueryCosmosBlockMaximumArgs = {
  get?: InputMaybe<BitqueryCosmosBlockMeasurable>;
  of: BitqueryCosmosBlockMeasurable;
};


/** Block */
export type BitqueryCosmosBlockMinimumArgs = {
  get?: InputMaybe<BitqueryCosmosBlockMeasurable>;
  of: BitqueryCosmosBlockMeasurable;
};

/** Information about block */
export type BitqueryCosmosBlockDimension = {
  __typename?: 'BitqueryCosmosBlockDimension';
  /** Block Hash */
  hash?: Maybe<Scalars['String']['output']>;
  /** Block number (height) in blockchain */
  height: Scalars['Int']['output'];
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
};

export enum BitqueryCosmosBlockMeasurable {
  /** Date */
  Date = 'date',
  /** Block hash */
  Hash = 'hash',
  /** Block */
  Height = 'height',
  /** Proposer */
  Proposer = 'proposer',
  /** Time */
  Time = 'time'
}

export enum BitqueryCosmosBlockUniq {
  /** Number of block in the blockchains */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates',
  /** Block Hash */
  Hashes = 'hashes',
  /** Block proposer */
  Proposers = 'proposers',
  /** Unique timestamps count */
  Times = 'times'
}

export type BitqueryCosmosBlocksFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  proposer?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

/** Coinpath */
export type BitqueryCosmosCoinpath = {
  __typename?: 'BitqueryCosmosCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryAddress>;
  /** Message of transfer happened */
  transaction?: Maybe<BitqueryTransactionHashValue>;
};


/** Coinpath */
export type BitqueryCosmosCoinpathAmountArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Coinpath */
export type BitqueryCosmosCoinpathAnyArgs = {
  of: BitqueryCosmosCoinpathMeasurable;
};


/** Coinpath */
export type BitqueryCosmosCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryCosmosCoinpathMeasurable>;
  of: BitqueryCosmosCoinpathMeasurable;
};


/** Coinpath */
export type BitqueryCosmosCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryCosmosCoinpathMeasurable>;
  of: BitqueryCosmosCoinpathMeasurable;
};

export enum BitqueryCosmosCoinpathMeasurable {
  /** Block */
  Block = 'block',
  /** Depth */
  Depth = 'depth',
  /** Receiver */
  Receiver = 'receiver',
  /** Sender */
  Sender = 'sender',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TransactionHash = 'transaction_hash'
}

/** Currency selector in Cosmos blockchain */
export type BitqueryCosmosCurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Currency not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Message in Cosmos blockchain */
export type BitqueryCosmosMessage = {
  __typename?: 'BitqueryCosmosMessage';
  any?: Maybe<Scalars['String']['output']>;
  /** Block info where transaction included */
  block?: Maybe<BitqueryCosmosBlockDimension>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Index in tx */
  index: Scalars['Int']['output'];
  /** Body of message  */
  json?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Message sender(s) */
  senders?: Maybe<Scalars['String']['output']>;
  /** Succeeded or failed */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction info where message included */
  transaction?: Maybe<BitqueryCosmosTransactionDimension>;
  /** Type of the message */
  type?: Maybe<Scalars['String']['output']>;
};


/** Message in Cosmos blockchain */
export type BitqueryCosmosMessageAnyArgs = {
  of: BitqueryCosmosMessageMeasurable;
};


/** Message in Cosmos blockchain */
export type BitqueryCosmosMessageCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  senders?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSigner?: InputMaybe<BitqueryAddressSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryCosmosMessageUniq>;
};


/** Message in Cosmos blockchain */
export type BitqueryCosmosMessageCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  senders?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSigner?: InputMaybe<BitqueryAddressSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryCosmosMessageUniq>;
};


/** Message in Cosmos blockchain */
export type BitqueryCosmosMessageExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Message in Cosmos blockchain */
export type BitqueryCosmosMessageMaximumArgs = {
  get?: InputMaybe<BitqueryCosmosMessageMeasurable>;
  of: BitqueryCosmosMessageMeasurable;
};


/** Message in Cosmos blockchain */
export type BitqueryCosmosMessageMinimumArgs = {
  get?: InputMaybe<BitqueryCosmosMessageMeasurable>;
  of: BitqueryCosmosMessageMeasurable;
};

/** Information about message */
export type BitqueryCosmosMessageDimension = {
  __typename?: 'BitqueryCosmosMessageDimension';
  /** Index in tx */
  index: Scalars['Int']['output'];
  /** Message sender(s) */
  senders?: Maybe<Scalars['String']['output']>;
  /** Succeeded or failed */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Type of the message */
  type?: Maybe<Scalars['String']['output']>;
};

export type BitqueryCosmosMessageFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  senders?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSigner?: InputMaybe<BitqueryAddressSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};

export enum BitqueryCosmosMessageMeasurable {
  /** Hash of the block */
  BlockHash = 'blockHash',
  /** Number of block in the blockhains */
  BlockHeight = 'blockHeight',
  /** Date */
  Date = 'date',
  /** Message index in transaction */
  Index = 'index',
  /** Message json */
  Json = 'json',
  /** Message senders */
  Senders = 'senders',
  /** Message success */
  Success = 'success',
  /** Time */
  Time = 'time',
  /** Hash of the transaction */
  TransactionHash = 'transactionHash',
  /** Index of the transaction */
  TransactionIndex = 'transactionIndex',
  /** Transaction Signer */
  TransactionSigner = 'transactionSigner',
  /** Type of message */
  Type = 'type'
}

export enum BitqueryCosmosMessageUniq {
  /** Uniq blocks */
  Blocks = 'blocks',
  /** Uniq date */
  Dates = 'dates',
  /** Uniq senders */
  Senders = 'senders',
  /** Uniq transaction hashes */
  TransactionHashes = 'transactionHashes',
  /** Uniq transaction indices */
  TransactionIndices = 'transactionIndices',
  /** Uniq transaction signers */
  TransactionSigners = 'transactionSigners',
  /** Uniq types */
  Types = 'types'
}

export enum BitqueryCosmosNetwork {
  /** Cosmos Hub Network */
  Cosmoshub = 'cosmoshub',
  /** Crypto.org Mainnet */
  CryptoMainnet = 'crypto_mainnet',
  /** Crypto.org Croeseid Testnet */
  CryptoTestnet = 'crypto_testnet',
  /** Heimdall (Matic Verification Network) */
  Heimdall = 'heimdall',
  /** Terra Mainnet */
  Terra = 'terra'
}

/** Tokens Info */
export type BitqueryCosmosTokensInfo = {
  __typename?: 'BitqueryCosmosTokensInfo';
  /** Token Balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** Denom */
  denom?: Maybe<Scalars['String']['output']>;
};

/** Transaction in Cosmos blockchain */
export type BitqueryCosmosTransaction = {
  __typename?: 'BitqueryCosmosTransaction';
  any?: Maybe<Scalars['String']['output']>;
  /** Block info where transaction included */
  block?: Maybe<BitqueryCosmosBlockDimension>;
  /** code */
  code?: Maybe<Scalars['Int']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  fee?: Maybe<Scalars['Float']['output']>;
  /** Currency of transfer */
  feeCurrency?: Maybe<BitqueryCurrency>;
  feeDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  /** Gas Used */
  gasUsed: Scalars['BitqueryBigInt']['output'];
  /** Gas Wanted */
  gasWanted: Scalars['BitqueryBigInt']['output'];
  /** Hash of the transactions */
  hash?: Maybe<Scalars['String']['output']>;
  /** Index of the transaction in block */
  index?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Memo */
  memo?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Raw Tx */
  rawTx?: Maybe<Scalars['String']['output']>;
  /** Transaction Signer */
  signer?: Maybe<BitqueryAddress>;
  /** Succeeded or failed */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Type of the transactions */
  type?: Maybe<Scalars['String']['output']>;
};


/** Transaction in Cosmos blockchain */
export type BitqueryCosmosTransactionAnyArgs = {
  of: BitqueryCosmosTransactionMeasurable;
};


/** Transaction in Cosmos blockchain */
export type BitqueryCosmosTransactionCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  code?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryAmountSelector>;
  gasUsed?: InputMaybe<BitqueryIntegerSelector>;
  gasWanted?: InputMaybe<BitqueryIntegerSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  memo?: InputMaybe<BitqueryStringSelector>;
  signer?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryCosmosTransactionUniq>;
};


/** Transaction in Cosmos blockchain */
export type BitqueryCosmosTransactionCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  code?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryAmountSelector>;
  gasUsed?: InputMaybe<BitqueryIntegerSelector>;
  gasWanted?: InputMaybe<BitqueryIntegerSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  memo?: InputMaybe<BitqueryStringSelector>;
  signer?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryCosmosTransactionUniq>;
};


/** Transaction in Cosmos blockchain */
export type BitqueryCosmosTransactionExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transaction in Cosmos blockchain */
export type BitqueryCosmosTransactionFeeArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  code?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryAmountSelector>;
  gasUsed?: InputMaybe<BitqueryIntegerSelector>;
  gasWanted?: InputMaybe<BitqueryIntegerSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  memo?: InputMaybe<BitqueryStringSelector>;
  signer?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Transaction in Cosmos blockchain */
export type BitqueryCosmosTransactionFeeDecimalArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  code?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryAmountSelector>;
  gasUsed?: InputMaybe<BitqueryIntegerSelector>;
  gasWanted?: InputMaybe<BitqueryIntegerSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  memo?: InputMaybe<BitqueryStringSelector>;
  signer?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Transaction in Cosmos blockchain */
export type BitqueryCosmosTransactionGasUsedArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  code?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryAmountSelector>;
  gasUsed?: InputMaybe<BitqueryIntegerSelector>;
  gasWanted?: InputMaybe<BitqueryIntegerSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  memo?: InputMaybe<BitqueryStringSelector>;
  signer?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Transaction in Cosmos blockchain */
export type BitqueryCosmosTransactionGasWantedArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  code?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryAmountSelector>;
  gasUsed?: InputMaybe<BitqueryIntegerSelector>;
  gasWanted?: InputMaybe<BitqueryIntegerSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  memo?: InputMaybe<BitqueryStringSelector>;
  signer?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Transaction in Cosmos blockchain */
export type BitqueryCosmosTransactionMaximumArgs = {
  get?: InputMaybe<BitqueryCosmosTransactionMeasurable>;
  of: BitqueryCosmosTransactionMeasurable;
};


/** Transaction in Cosmos blockchain */
export type BitqueryCosmosTransactionMinimumArgs = {
  get?: InputMaybe<BitqueryCosmosTransactionMeasurable>;
  of: BitqueryCosmosTransactionMeasurable;
};

/** Information about transaction */
export type BitqueryCosmosTransactionDimension = {
  __typename?: 'BitqueryCosmosTransactionDimension';
  /** Hash of the transactions */
  hash?: Maybe<Scalars['String']['output']>;
  /** Index of the transaction in block */
  index?: Maybe<Scalars['Int']['output']>;
  /** Transaction Signer */
  signer?: Maybe<BitqueryAddress>;
};

export type BitqueryCosmosTransactionFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  code?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryAmountSelector>;
  gasUsed?: InputMaybe<BitqueryIntegerSelector>;
  gasWanted?: InputMaybe<BitqueryIntegerSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  memo?: InputMaybe<BitqueryStringSelector>;
  signer?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};

export enum BitqueryCosmosTransactionMeasurable {
  /** Hash of the block */
  BlockHash = 'block_hash',
  /** Number of block in the blockhains */
  BlockHeight = 'block_height',
  /** Transaction Code */
  Code = 'code',
  /** Date */
  Date = 'date',
  /** Transaction Fee */
  Fee = 'fee',
  /** Hash of the transaction */
  Hash = 'hash',
  /** Transaction Index */
  Index = 'index',
  /** Transaction Memo */
  Memo = 'memo',
  /** Raw Transaction */
  RawTx = 'rawTx',
  /** Transaction Signer */
  Signer = 'signer',
  /** Time */
  Time = 'time',
  /** Type of the transaction */
  Type = 'type'
}

export enum BitqueryCosmosTransactionUniq {
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique timecodes */
  Codes = 'codes',
  /** Unique date count */
  Dates = 'dates',
  /** Unique hashes */
  Hashes = 'hashes',
  /** Unique indices */
  Indices = 'indices',
  /** Unique memos */
  Memos = 'memos',
  /** Unique signers */
  Signers = 'signers',
  /** Unique time */
  Times = 'times',
  /** Unique types */
  Types = 'types'
}

export type BitqueryCosmosTransferFilter = {
  block?: InputMaybe<BitqueryBlockSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  currency?: InputMaybe<BitqueryCosmosCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  senders?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSigner?: InputMaybe<BitqueryAddressSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  typeTransfer?: InputMaybe<BitqueryBooleanSelector>;
  value?: InputMaybe<BitqueryAmountSelector>;
};

export enum BitqueryCosmosTransferUniq {
  /** Unique block hashes */
  BlockHashes = 'blockHashes',
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique currencies */
  Currencies = 'currencies',
  /** Unique dates */
  Dates = 'dates',
  /** Unique message indices */
  MessageIndices = 'messageIndices',
  /** Unique message types */
  MessageTypes = 'messageTypes',
  /** Unique time */
  Receiver = 'receiver',
  /** Unique senders (field sender) */
  Sender = 'sender',
  /** Unique senders (field senders) */
  Senders = 'senders',
  /** Unique times */
  Times = 'times',
  /** Unique transaction hashes */
  TransactionHashes = 'transactionHashes',
  /** Unique transaction indices */
  TransactionIndices = 'transactionIndices',
  /** Unique transaction signers */
  TransactionSigners = 'transactionSigners',
  /** Unique transfer types */
  Types = 'types'
}

/** Transfers in Cosmos  blockchain */
export type BitqueryCosmosTransfers = {
  __typename?: 'BitqueryCosmosTransfers';
  any?: Maybe<Scalars['String']['output']>;
  /** Block info where transaction included */
  block?: Maybe<BitqueryCosmosBlockDimension>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of the transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  /** Is delegated */
  delegated?: Maybe<Scalars['Boolean']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Index in tx */
  messageIndex: Scalars['Int']['output'];
  /** Type of the message */
  messageType?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Transfer receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Transfer sender */
  sender?: Maybe<BitqueryAddress>;
  /** Message sender(s) */
  senders?: Maybe<Scalars['String']['output']>;
  /** Transaction info where message included */
  transaction?: Maybe<BitqueryCosmosTransactionDimension>;
  /** Type of the Transfer */
  type?: Maybe<Scalars['String']['output']>;
  value?: Maybe<Scalars['Float']['output']>;
  valueDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
};


/** Transfers in Cosmos  blockchain */
export type BitqueryCosmosTransfersAnyArgs = {
  of: BitqueryCosmosTransfersMeasurable;
};


/** Transfers in Cosmos  blockchain */
export type BitqueryCosmosTransfersCountArgs = {
  block?: InputMaybe<BitqueryBlockSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  currency?: InputMaybe<BitqueryCosmosCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  senders?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSigner?: InputMaybe<BitqueryAddressSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  typeTransfer?: InputMaybe<BitqueryBooleanSelector>;
  uniq?: InputMaybe<BitqueryCosmosTransferUniq>;
  value?: InputMaybe<BitqueryAmountSelector>;
};


/** Transfers in Cosmos  blockchain */
export type BitqueryCosmosTransfersCountBigIntArgs = {
  block?: InputMaybe<BitqueryBlockSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  currency?: InputMaybe<BitqueryCosmosCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  senders?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSigner?: InputMaybe<BitqueryAddressSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  typeTransfer?: InputMaybe<BitqueryBooleanSelector>;
  uniq?: InputMaybe<BitqueryCosmosTransferUniq>;
  value?: InputMaybe<BitqueryAmountSelector>;
};


/** Transfers in Cosmos  blockchain */
export type BitqueryCosmosTransfersExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transfers in Cosmos  blockchain */
export type BitqueryCosmosTransfersMaximumArgs = {
  get?: InputMaybe<BitqueryCosmosTransfersMeasurable>;
  of: BitqueryCosmosTransfersMeasurable;
};


/** Transfers in Cosmos  blockchain */
export type BitqueryCosmosTransfersMinimumArgs = {
  get?: InputMaybe<BitqueryCosmosTransfersMeasurable>;
  of: BitqueryCosmosTransfersMeasurable;
};


/** Transfers in Cosmos  blockchain */
export type BitqueryCosmosTransfersValueArgs = {
  block?: InputMaybe<BitqueryBlockSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<BitqueryCosmosCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  senders?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSigner?: InputMaybe<BitqueryAddressSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  typeTransfer?: InputMaybe<BitqueryBooleanSelector>;
  value?: InputMaybe<BitqueryAmountSelector>;
};


/** Transfers in Cosmos  blockchain */
export type BitqueryCosmosTransfersValueDecimalArgs = {
  block?: InputMaybe<BitqueryBlockSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<BitqueryCosmosCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  senders?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSigner?: InputMaybe<BitqueryAddressSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  typeTransfer?: InputMaybe<BitqueryBooleanSelector>;
  value?: InputMaybe<BitqueryAmountSelector>;
};

export enum BitqueryCosmosTransfersMeasurable {
  /** Hash of the block */
  BlockHash = 'blockHash',
  /** Currency Address */
  CurrencyAddress = 'currency_address',
  /** Currency Symbol */
  CurrencySymbol = 'currency_symbol',
  /** Date */
  Date = 'date',
  /** Number of block in the blockhains */
  Height = 'height',
  /** Message index in transaction */
  MessageIndex = 'messageIndex',
  /** Type of message */
  MessageType = 'messageType',
  /** Transfer To */
  Receiver = 'receiver',
  /** Transfer From */
  Sender = 'sender',
  /** Message senders */
  Senders = 'senders',
  /** Time */
  Time = 'time',
  /** Token ID */
  TokenId = 'token_id',
  /** Token Type */
  TokenType = 'token_type',
  /** Hash of the transaction */
  TransactionHash = 'transactionHash',
  /** Index of the transaction */
  TransactionIndex = 'transactionIndex',
  /** Transaction Signer */
  TransactionSigner = 'transactionSigner',
  /** Type of transfer */
  Type = 'type',
  /** Transfer value */
  Value = 'value'
}

/** Crypto currency ( token, coin, currency ) */
export type BitqueryCurrency = {
  __typename?: 'BitqueryCurrency';
  /** Token Smart Contract Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Decimals */
  decimals: Scalars['Int']['output'];
  /** Currency name */
  name?: Maybe<Scalars['String']['output']>;
  /** Properties */
  properties?: Maybe<Scalars['String']['output']>;
  /** Currency symbol */
  symbol: Scalars['String']['output'];
  /** Token ID */
  tokenId?: Maybe<Scalars['String']['output']>;
  /** Token Type */
  tokenType?: Maybe<Scalars['String']['output']>;
};

/** Currency selector */
export type BitqueryCurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Currency not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Instruction Data */
export type BitqueryData = {
  __typename?: 'BitqueryData';
  base58: Scalars['String']['output'];
  hex: Scalars['String']['output'];
};

/** Date */
export type BitqueryDate = {
  __typename?: 'BitqueryDate';
  /** String date representation with default format as YYYY-MM-DD */
  date: Scalars['String']['output'];
  /** Day of month (1-31) */
  dayOfMonth: Scalars['Int']['output'];
  /** Day of week  (Monday is 1, and Sunday is 7) */
  dayOfWeek: Scalars['Int']['output'];
  /** Month number (1-12) */
  month: Scalars['Int']['output'];
  /**
   * Returns start of date interval ,
   *     date representation with default format as YYYY-MM-DD. Example is start of interval for 3 weeks each,
   *   starting on wednesdays will read as: 'startOfInterval(unit: week, interval: 3, offset: 2)'
   */
  startOfInterval: Scalars['String']['output'];
  /** Year number */
  year: Scalars['Int']['output'];
};


/** Date */
export type BitqueryDateDateArgs = {
  format?: InputMaybe<Scalars['String']['input']>;
};


/** Date */
export type BitqueryDateStartOfIntervalArgs = {
  format?: InputMaybe<Scalars['String']['input']>;
  interval?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  unit: BitqueryDateInterval;
};

export enum BitqueryDateInterval {
  /** Day */
  Day = 'day',
  /** Month */
  Month = 'month',
  /** Week */
  Week = 'week',
  /** Year */
  Year = 'year'
}

/** Selecting the date in a range, list or just date */
export type BitqueryDateSelector = {
  /** After date */
  after?: InputMaybe<Scalars['BitqueryISO8601DateTime']['input']>;
  /** Before date */
  before?: InputMaybe<Scalars['BitqueryISO8601DateTime']['input']>;
  /** Range of dates */
  between?: InputMaybe<Array<Scalars['BitqueryISO8601DateTime']['input']>>;
  /** In dates */
  in?: InputMaybe<Array<Scalars['BitqueryISO8601DateTime']['input']>>;
  /** Date equals */
  is?: InputMaybe<Scalars['BitqueryISO8601DateTime']['input']>;
  /** Date not equals */
  not?: InputMaybe<Scalars['BitqueryISO8601DateTime']['input']>;
  /** Not in dates */
  notIn?: InputMaybe<Array<Scalars['BitqueryISO8601DateTime']['input']>>;
  /** Since date */
  since?: InputMaybe<Scalars['BitqueryISO8601DateTime']['input']>;
  /** Till date */
  till?: InputMaybe<Scalars['BitqueryISO8601DateTime']['input']>;
};

/** Date and Time */
export type BitqueryDateTime = {
  __typename?: 'BitqueryDateTime';
  /** Day of month (1-31) */
  dayOfMonth: Scalars['Int']['output'];
  /** Day of week  (Monday is 1, and Sunday is 7) */
  dayOfWeek: Scalars['Int']['output'];
  /** Hour (0-23) */
  hour: Scalars['Int']['output'];
  /** ISO8601 date time such as '2020-03-02T13:30:41+00:00' */
  iso8601: Scalars['BitqueryISO8601DateTime']['output'];
  /** Minute (0-59) */
  minute: Scalars['Int']['output'];
  /** Month number (1-12) */
  month: Scalars['Int']['output'];
  /** Second (0-59) */
  second: Scalars['Int']['output'];
  /** String date representation with default format as YYYY-MM-DD */
  time: Scalars['String']['output'];
  /** Unix timestamp */
  unixtime: Scalars['Int']['output'];
  /** Year number */
  year: Scalars['Int']['output'];
};


/** Date and Time */
export type BitqueryDateTimeTimeArgs = {
  format?: InputMaybe<Scalars['String']['input']>;
};

/** Selecting the time in a range, list or just time */
export type BitqueryDateTimeSelector = {
  /** After time */
  after?: InputMaybe<Scalars['BitqueryISO8601DateTime']['input']>;
  /** Before time */
  before?: InputMaybe<Scalars['BitqueryISO8601DateTime']['input']>;
  /** Range of time */
  between?: InputMaybe<Array<Scalars['BitqueryISO8601DateTime']['input']>>;
  /** In times */
  in?: InputMaybe<Array<Scalars['BitqueryISO8601DateTime']['input']>>;
  /** Time equals */
  is?: InputMaybe<Scalars['BitqueryISO8601DateTime']['input']>;
  /** Time not equals */
  not?: InputMaybe<Scalars['BitqueryISO8601DateTime']['input']>;
  /** Not in times */
  notIn?: InputMaybe<Array<Scalars['BitqueryISO8601DateTime']['input']>>;
  /** Since time */
  since?: InputMaybe<Scalars['BitqueryISO8601DateTime']['input']>;
  /** Till time */
  till?: InputMaybe<Scalars['BitqueryISO8601DateTime']['input']>;
};

export enum BitqueryDiemNetwork {
  /** Diem Testnet */
  DiemTestnet = 'diem_testnet',
  /** Libra Testnet */
  LibraTestnet = 'libra_testnet'
}

/** Elrond Chain */
export type BitqueryElrond = {
  __typename?: 'BitqueryElrond';
  /** Basic information about address */
  address: Array<BitqueryElrondAddressInfoWithBalance>;
  /** Information about validators of the block */
  blockValidators?: Maybe<Array<BitqueryElrondBlockValidator>>;
  /** Information about blocks */
  blocks?: Maybe<Array<BitqueryElrondBlock>>;
  /** Information about calls */
  callResults?: Maybe<Array<BitqueryElrondCallResult>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryElrondCoinpath>>;
  /** Information about Event */
  events?: Maybe<Array<BitqueryElrondEvent>>;
  /** Information about miniblocks */
  miniblocks?: Maybe<Array<BitqueryElrondMiniblock>>;
  /** Information about notarized block */
  notarizedBlock?: Maybe<Array<BitqueryElrondNotarizedBlock>>;
  /** Information about Token Operations */
  operations?: Maybe<Array<BitqueryElrondOperation>>;
  /** Information about transactions */
  transactions?: Maybe<Array<BitqueryElrondTransaction>>;
  /** Information about transactions */
  transfers?: Maybe<Array<BitqueryElrondTransfer>>;
};


/** Elrond Chain */
export type BitqueryElrondAddressArgs = {
  address: Array<BitqueryAddressSelectorIn>;
};


/** Elrond Chain */
export type BitqueryElrondBlockValidatorsArgs = {
  any?: InputMaybe<Array<BitqueryElrondBlockValidatorFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  validator?: InputMaybe<BitqueryHashSelector>;
};


/** Elrond Chain */
export type BitqueryElrondBlocksArgs = {
  any?: InputMaybe<Array<BitqueryElrondBlockFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
};


/** Elrond Chain */
export type BitqueryElrondCallResultsArgs = {
  any?: InputMaybe<Array<BitqueryElrondCallResultFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  callResultData?: InputMaybe<BitqueryStringSelector>;
  callResultDataOperation?: InputMaybe<BitqueryStringSelector>;
  callResultGasLimit?: InputMaybe<BitqueryFloatSelector>;
  callResultGasPrice?: InputMaybe<BitqueryFloatSelector>;
  callResultHash?: InputMaybe<BitqueryHashSelector>;
  callResultIndex?: InputMaybe<BitqueryIntegerSelector>;
  callResultNonce?: InputMaybe<BitqueryIntegerSelector>;
  callResultReceiver?: InputMaybe<BitqueryHashSelector>;
  callResultRelayedValue?: InputMaybe<BitqueryFloatSelector>;
  callResultSender?: InputMaybe<BitqueryHashSelector>;
  callResultType?: InputMaybe<BitqueryStringSelector>;
  callResultValue?: InputMaybe<BitqueryFloatSelector>;
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  previousTxHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  relayed?: InputMaybe<BitqueryStringSelector>;
  returnMessage?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Elrond Chain */
export type BitqueryElrondCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCoinpathOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Elrond Chain */
export type BitqueryElrondEventsArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  any?: InputMaybe<Array<BitqueryElrondEventFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  callResultPath?: InputMaybe<BitqueryStringSelector>;
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  eventIndex?: InputMaybe<BitqueryIntegerSelector>;
  eventType?: InputMaybe<BitqueryEventTypeSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  identifier?: InputMaybe<BitqueryStringSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  txFunction?: InputMaybe<BitqueryStringSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Elrond Chain */
export type BitqueryElrondMiniblocksArgs = {
  any?: InputMaybe<Array<BitqueryElrondMiniblockFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  receiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  receiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Elrond Chain */
export type BitqueryElrondNotarizedBlockArgs = {
  any?: InputMaybe<Array<BitqueryElrondNotarizedBlockFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  notarizedBlockHash?: InputMaybe<BitqueryHashSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
};


/** Elrond Chain */
export type BitqueryElrondOperationsArgs = {
  any?: InputMaybe<Array<BitqueryElrondOperationFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  operationAction?: InputMaybe<BitqueryStringSelector>;
  operationData?: InputMaybe<BitqueryStringSelector>;
  operationIndex?: InputMaybe<BitqueryIntegerSelector>;
  operationReceiver?: InputMaybe<BitqueryAddressSelector>;
  operationSender?: InputMaybe<BitqueryAddressSelector>;
  operationType?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  txFunction?: InputMaybe<BitqueryStringSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Elrond Chain */
export type BitqueryElrondTransactionsArgs = {
  actionCategory?: InputMaybe<BitqueryStringSelector>;
  actionDescription?: InputMaybe<BitqueryStringSelector>;
  actionName?: InputMaybe<BitqueryStringSelector>;
  any?: InputMaybe<Array<BitqueryElrondTransactionFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  function?: InputMaybe<BitqueryStringSelector>;
  gasLimit?: InputMaybe<BitqueryFloatSelector>;
  gasPrice?: InputMaybe<BitqueryFloatSelector>;
  gasUsed?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txNonce?: InputMaybe<BitqueryIntegerSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txValue?: InputMaybe<BitqueryFloatSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Elrond Chain */
export type BitqueryElrondTransfersArgs = {
  action?: InputMaybe<BitqueryActionSelector>;
  any?: InputMaybe<Array<BitqueryElrondTransferFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  esdtType?: InputMaybe<BitqueryStringSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  transferReceiver?: InputMaybe<BitqueryAddressSelector>;
  transferSender?: InputMaybe<BitqueryAddressSelector>;
  transferType?: InputMaybe<BitqueryStringSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};

/** Blockchain address hash */
export type BitqueryElrondAddressHash = {
  __typename?: 'BitqueryElrondAddressHash';
  /** String hex address representation */
  hex: Scalars['String']['output'];
};

/** Address detailed information for Elrond network */
export type BitqueryElrondAddressInfoWithBalance = {
  __typename?: 'BitqueryElrondAddressInfoWithBalance';
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Native currency balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** Extra information abount address from node */
  extraInfo?: Maybe<BitqueryElrondExtraInfo>;
  /** Staked EGLD */
  staking?: Maybe<Scalars['Float']['output']>;
  /** Tokens Info */
  tokensInfo?: Maybe<Array<BitqueryElrondTokensInfo>>;
};


/** Address detailed information for Elrond network */
export type BitqueryElrondAddressInfoWithBalanceBalanceArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Address detailed information for Elrond network */
export type BitqueryElrondAddressInfoWithBalanceStakingArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};

/** Blocks in Elrond  blockchain */
export type BitqueryElrondBlock = {
  __typename?: 'BitqueryElrondBlock';
  any?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  /** Epoch */
  epoch?: Maybe<Scalars['Int']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Hash of the the block */
  hash?: Maybe<Scalars['String']['output']>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Block Height */
  nonce?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The block hash of this block`s parent */
  previousBlockHash?: Maybe<Scalars['String']['output']>;
  /** Proposer block hash */
  proposer?: Maybe<BitqueryElrondAddressHash>;
  /** Public Key Bitmap */
  publicKeyBitmap?: Maybe<Scalars['String']['output']>;
  /** Round */
  round?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Shard number of block */
  shard?: Maybe<Scalars['String']['output']>;
  /** Size */
  size?: Maybe<Scalars['Int']['output']>;
  /** Size Tx */
  sizeTxs?: Maybe<Scalars['Int']['output']>;
  /** State root hash */
  stateRootHash?: Maybe<Scalars['String']['output']>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Count of transactions in this block */
  transactionCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
};


/** Blocks in Elrond  blockchain */
export type BitqueryElrondBlockAnyArgs = {
  of: BitqueryElrondBlocksMeasureable;
};


/** Blocks in Elrond  blockchain */
export type BitqueryElrondBlockCountArgs = {
  uniq?: InputMaybe<BitqueryElrondBlockUniq>;
};


/** Blocks in Elrond  blockchain */
export type BitqueryElrondBlockCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryElrondBlockUniq>;
};


/** Blocks in Elrond  blockchain */
export type BitqueryElrondBlockExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Blocks in Elrond  blockchain */
export type BitqueryElrondBlockMaximumArgs = {
  get?: InputMaybe<BitqueryElrondBlocksMeasureable>;
  of: BitqueryElrondBlocksMeasureable;
};


/** Blocks in Elrond  blockchain */
export type BitqueryElrondBlockMinimumArgs = {
  get?: InputMaybe<BitqueryElrondBlocksMeasureable>;
  of: BitqueryElrondBlocksMeasureable;
};

/** Information about block */
export type BitqueryElrondBlockDimension = {
  __typename?: 'BitqueryElrondBlockDimension';
  /** Epoch */
  epoch?: Maybe<Scalars['Int']['output']>;
  /** Hash of the block */
  hash?: Maybe<Scalars['String']['output']>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Block Height */
  nonce?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The block hash of this block`s parent */
  previousBlockHash?: Maybe<Scalars['String']['output']>;
  /** Proposer block hash */
  proposer?: Maybe<BitqueryElrondAddressHash>;
  /** Public Key Bitmap */
  publicKeyBitmap?: Maybe<Scalars['String']['output']>;
  /** Round */
  round?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Shard number of block */
  shard?: Maybe<Scalars['String']['output']>;
  /** Size */
  size?: Maybe<Scalars['Int']['output']>;
  /** Size Tx */
  sizeTxs?: Maybe<Scalars['Int']['output']>;
  /** State root hash */
  stateRootHash?: Maybe<Scalars['String']['output']>;
  /** Count of transactions in this block */
  transactionCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
};

export type BitqueryElrondBlockFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
};

export enum BitqueryElrondBlockUniq {
  /** Unique Number of Shards in the blockchains */
  BlockShard = 'block_shard',
  /** Unique date count */
  Dates = 'dates',
  /** Unique Number of block in the blockchains */
  Height = 'height',
  /** Unique time */
  Times = 'times'
}

/** BlockValidators in Elrond  blockchain */
export type BitqueryElrondBlockValidator = {
  __typename?: 'BitqueryElrondBlockValidator';
  any?: Maybe<Scalars['String']['output']>;
  /** Information about blocks notarized block */
  block?: Maybe<BitqueryElrondBlockDimension>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Hash of validator */
  validator?: Maybe<BitqueryElrondAddressHash>;
};


/** BlockValidators in Elrond  blockchain */
export type BitqueryElrondBlockValidatorAnyArgs = {
  of: BitqueryElrondBlockValidatorsMeasureable;
};


/** BlockValidators in Elrond  blockchain */
export type BitqueryElrondBlockValidatorBlockArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
};


/** BlockValidators in Elrond  blockchain */
export type BitqueryElrondBlockValidatorCountArgs = {
  uniq?: InputMaybe<BitqueryElrondBlockValidatorUniq>;
};


/** BlockValidators in Elrond  blockchain */
export type BitqueryElrondBlockValidatorCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryElrondBlockValidatorUniq>;
};


/** BlockValidators in Elrond  blockchain */
export type BitqueryElrondBlockValidatorMaximumArgs = {
  get?: InputMaybe<BitqueryElrondBlockValidatorsMeasureable>;
  of: BitqueryElrondBlockValidatorsMeasureable;
};


/** BlockValidators in Elrond  blockchain */
export type BitqueryElrondBlockValidatorMinimumArgs = {
  get?: InputMaybe<BitqueryElrondBlockValidatorsMeasureable>;
  of: BitqueryElrondBlockValidatorsMeasureable;
};

export type BitqueryElrondBlockValidatorFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  validator?: InputMaybe<BitqueryHashSelector>;
};

export enum BitqueryElrondBlockValidatorUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique Number of block in the blockchains */
  Height = 'height',
  /** Unique time */
  Times = 'times',
  /** Unique number of validators */
  Validators = 'validators'
}

export enum BitqueryElrondBlockValidatorsMeasureable {
  /** Date */
  Date = 'date',
  /** Block epoch */
  Epoch = 'epoch',
  /** Hash of the the block */
  Hash = 'hash',
  /** Number of block in the blockhains */
  Height = 'height',
  /** Block nonce */
  Nonce = 'nonce',
  /** The block hash of this block`s parent */
  PreviousBlockHash = 'previous_block_hash',
  /** Block proposer */
  Proposer = 'proposer',
  /** Block public key bitmap */
  PublicKeyBitmap = 'public_key_bitmap',
  /** Block round */
  Round = 'round',
  /** Shard number of block */
  Shard = 'shard',
  /** Block size */
  Size = 'size',
  /** Block size txs */
  SizeTxs = 'size_txs',
  /** State root hash */
  StateRootHash = 'state_root_hash',
  /** Time */
  Time = 'time',
  /** Count of transactions in this block */
  TransactionCount = 'transaction_count',
  /** Hash of the validator */
  Validator = 'validator'
}

export enum BitqueryElrondBlocksMeasureable {
  /** Date */
  Date = 'date',
  /** Block epoch */
  Epoch = 'epoch',
  /** Hash of the the block */
  Hash = 'hash',
  /** Number of block in the blockhains */
  Height = 'height',
  /** Block nonce */
  Nonce = 'nonce',
  /** The block hash of this block`s parent */
  PreviousBlockHash = 'previous_block_hash',
  /** Block proposer */
  Proposer = 'proposer',
  /** Block public key bitmap */
  PublicKeyBitmap = 'public_key_bitmap',
  /** Block round */
  Round = 'round',
  /** Shard number of block */
  Shard = 'shard',
  /** Block size */
  Size = 'size',
  /** Block size txs */
  SizeTxs = 'size_txs',
  /** State root hash */
  StateRootHash = 'state_root_hash',
  /** Time */
  Time = 'time',
  /** Count of transactions in this block */
  TransactionCount = 'transaction_count'
}

/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResult = {
  __typename?: 'BitqueryElrondCallResult';
  any?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Call result data */
  data?: Maybe<Scalars['String']['output']>;
  /** Call result data operation */
  dataOperation?: Maybe<Scalars['String']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Call result gas limit */
  gasLimit?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Call result gas price */
  gasPrice?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Hash of the call result */
  hash?: Maybe<Scalars['String']['output']>;
  /** Call result index */
  index?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Information about calls miniblock */
  miniblock?: Maybe<BitqueryMiniblockElrond>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Nonce of the call result */
  nonce?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Hash of the previous transaction */
  previousTxHash?: Maybe<Scalars['String']['output']>;
  /** Call result receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Call result relayed */
  relayed?: Maybe<Scalars['String']['output']>;
  relayedValue?: Maybe<Scalars['Float']['output']>;
  /** Call result return message */
  returnMessage?: Maybe<Scalars['String']['output']>;
  /** Call result sender */
  sender?: Maybe<BitqueryAddress>;
  /** Information about calls block */
  senderBlock?: Maybe<BitqueryElrondBlockDimension>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Information about calls transaction */
  transaction?: Maybe<BitqueryTransactionElrond>;
  /** Call result type */
  type?: Maybe<Scalars['String']['output']>;
  value?: Maybe<Scalars['Float']['output']>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultAnyArgs = {
  of: BitqueryElrondCallResultsMeasureable;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultCountArgs = {
  uniq?: InputMaybe<BitqueryElrondCallResultUniq>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryElrondCallResultUniq>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultDataArgs = {
  callResultData?: InputMaybe<BitqueryStringSelector>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultDataOperationArgs = {
  callResultDataOperation?: InputMaybe<BitqueryStringSelector>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultExpressionArgs = {
  get: Scalars['String']['input'];
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultGasLimitArgs = {
  callResultGasLimit?: InputMaybe<BitqueryIntegerSelector>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultGasPriceArgs = {
  callResultGasPrice?: InputMaybe<BitqueryIntegerSelector>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultHashArgs = {
  callResultHash?: InputMaybe<BitqueryHashSelector>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultIndexArgs = {
  callResultIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultMaximumArgs = {
  get?: InputMaybe<BitqueryElrondCallResultsMeasureable>;
  of: BitqueryElrondCallResultsMeasureable;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultMiniblockArgs = {
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultMinimumArgs = {
  get?: InputMaybe<BitqueryElrondCallResultsMeasureable>;
  of: BitqueryElrondCallResultsMeasureable;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultNonceArgs = {
  callResultNonce?: InputMaybe<BitqueryIntegerSelector>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultPreviousTxHashArgs = {
  previousTxHash?: InputMaybe<BitqueryHashSelector>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultReceiverArgs = {
  callResultReceiver?: InputMaybe<BitqueryHashSelector>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultRelayedArgs = {
  relayed?: InputMaybe<BitqueryStringSelector>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultRelayedValueArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  callResultData?: InputMaybe<BitqueryStringSelector>;
  callResultDataOperation?: InputMaybe<BitqueryStringSelector>;
  callResultGasLimit?: InputMaybe<BitqueryFloatSelector>;
  callResultGasPrice?: InputMaybe<BitqueryFloatSelector>;
  callResultHash?: InputMaybe<BitqueryHashSelector>;
  callResultIndex?: InputMaybe<BitqueryIntegerSelector>;
  callResultNonce?: InputMaybe<BitqueryIntegerSelector>;
  callResultReceiver?: InputMaybe<BitqueryHashSelector>;
  callResultRelayedValue?: InputMaybe<BitqueryFloatSelector>;
  callResultSender?: InputMaybe<BitqueryHashSelector>;
  callResultType?: InputMaybe<BitqueryStringSelector>;
  callResultValue?: InputMaybe<BitqueryFloatSelector>;
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  previousTxHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  relayed?: InputMaybe<BitqueryStringSelector>;
  returnMessage?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultReturnMessageArgs = {
  returnMessage?: InputMaybe<BitqueryStringSelector>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultSenderArgs = {
  callResultSender?: InputMaybe<BitqueryHashSelector>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultSenderBlockArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultTransactionArgs = {
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  txFunction?: InputMaybe<BitqueryStringSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultTypeArgs = {
  callResultType?: InputMaybe<BitqueryStringSelector>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultValueArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  callResultData?: InputMaybe<BitqueryStringSelector>;
  callResultDataOperation?: InputMaybe<BitqueryStringSelector>;
  callResultGasLimit?: InputMaybe<BitqueryFloatSelector>;
  callResultGasPrice?: InputMaybe<BitqueryFloatSelector>;
  callResultHash?: InputMaybe<BitqueryHashSelector>;
  callResultIndex?: InputMaybe<BitqueryIntegerSelector>;
  callResultNonce?: InputMaybe<BitqueryIntegerSelector>;
  callResultReceiver?: InputMaybe<BitqueryHashSelector>;
  callResultRelayedValue?: InputMaybe<BitqueryFloatSelector>;
  callResultSender?: InputMaybe<BitqueryHashSelector>;
  callResultType?: InputMaybe<BitqueryStringSelector>;
  callResultValue?: InputMaybe<BitqueryFloatSelector>;
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  previousTxHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  relayed?: InputMaybe<BitqueryStringSelector>;
  returnMessage?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryElrondCallResultFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  callResultData?: InputMaybe<BitqueryStringSelector>;
  callResultDataOperation?: InputMaybe<BitqueryStringSelector>;
  callResultGasLimit?: InputMaybe<BitqueryFloatSelector>;
  callResultGasPrice?: InputMaybe<BitqueryFloatSelector>;
  callResultHash?: InputMaybe<BitqueryHashSelector>;
  callResultIndex?: InputMaybe<BitqueryIntegerSelector>;
  callResultNonce?: InputMaybe<BitqueryIntegerSelector>;
  callResultReceiver?: InputMaybe<BitqueryHashSelector>;
  callResultRelayedValue?: InputMaybe<BitqueryFloatSelector>;
  callResultSender?: InputMaybe<BitqueryHashSelector>;
  callResultType?: InputMaybe<BitqueryStringSelector>;
  callResultValue?: InputMaybe<BitqueryFloatSelector>;
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  previousTxHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  relayed?: InputMaybe<BitqueryStringSelector>;
  returnMessage?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};

export enum BitqueryElrondCallResultUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique Number of block in the blockchains */
  Height = 'height',
  /** Unique Number of call results */
  Index = 'index',
  /** Unique time */
  Times = 'times',
  /** Unique count of transactions */
  Txs = 'txs'
}

export enum BitqueryElrondCallResultsMeasureable {
  /** Hash of the the block */
  BlockHash = 'block_hash',
  /** Data of the call result */
  CallResultData = 'call_result_data',
  /** Hash of the call result */
  CallResultHash = 'call_result_hash',
  /** Index of the call result */
  CallResultIndex = 'call_result_index',
  /** Receiver of the call result */
  CallResultReceiver = 'call_result_receiver',
  /** Sender of the call result */
  CallResultSender = 'call_result_sender',
  /** Data */
  Data = 'data',
  /** Date */
  Date = 'date',
  /** Gas Limit */
  GasLimit = 'gas_limit',
  /** Gas Price */
  GasPrice = 'gas_price',
  /** Gas Used */
  GasUsed = 'gas_used',
  /** Number of block in the blockhains */
  Height = 'height',
  /** Hash of the miniblock */
  MiniblockHash = 'miniblock_hash',
  /** Hash of the miniblocks receiver block */
  MiniblockReceiverBlockHash = 'miniblock_receiver_block_hash',
  /** Miniblock receiver shard */
  MiniblockReceiverShard = 'miniblock_receiver_shard',
  /** The block hash of this block`s parent */
  PreviousBlockHash = 'previous_block_hash',
  /** Previous transaction hash of the call result */
  PreviousTxHash = 'previous_tx_hash',
  /** Time */
  Time = 'time',
  /** The block hash of this block`s parent */
  TransactionCount = 'transaction_count',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Receiver hash */
  TxReceiver = 'tx_receiver',
  /** Shard number of the receiver */
  TxReceiverShard = 'tx_receiver_shard',
  /** Sender hash */
  TxSender = 'tx_sender',
  /** Shard number of the sender */
  TxSenderShard = 'tx_sender_shard',
  /** Value */
  TxValue = 'tx_value',
  /** Type of miniblock */
  Type = 'type'
}

/** Elrond Coinpath */
export type BitqueryElrondCoinpath = {
  __typename?: 'BitqueryElrondCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<BitqueryElrondTransactionValueDimension>;
};


/** Elrond Coinpath */
export type BitqueryElrondCoinpathAmountArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Elrond Coinpath */
export type BitqueryElrondCoinpathAnyArgs = {
  of: BitqueryElrondCoinpathMeasureable;
};


/** Elrond Coinpath */
export type BitqueryElrondCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryElrondCoinpathMeasureable>;
  of: BitqueryElrondCoinpathMeasureable;
};


/** Elrond Coinpath */
export type BitqueryElrondCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryElrondCoinpathMeasureable>;
  of: BitqueryElrondCoinpathMeasureable;
};

export enum BitqueryElrondCoinpathMeasureable {
  /** Block */
  Block = 'block',
  /** Depth */
  Depth = 'depth',
  /** Receiver */
  Receiver = 'receiver',
  /** Sender */
  Sender = 'sender',
  /** Time */
  Time = 'time',
  /** Version */
  TxHash = 'tx_hash'
}

/** Events in Elrond blockchain */
export type BitqueryElrondEvent = {
  __typename?: 'BitqueryElrondEvent';
  /** Address */
  address?: Maybe<BitqueryAddress>;
  any?: Maybe<Scalars['String']['output']>;
  /** Call Result Path */
  callResultPath?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Identifier */
  identifier?: Maybe<Scalars['String']['output']>;
  /** Index */
  index?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Information about miniblock */
  miniblock?: Maybe<BitqueryMiniblockElrond>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Information about calls block */
  senderBlock?: Maybe<BitqueryElrondBlockDimension>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Data */
  topics?: Maybe<Array<Scalars['String']['output']>>;
  /** Information about transactions */
  transaction?: Maybe<BitqueryTransactionElrond>;
  /** Type */
  type?: Maybe<Scalars['String']['output']>;
  value?: Maybe<Scalars['Float']['output']>;
};


/** Events in Elrond blockchain */
export type BitqueryElrondEventAnyArgs = {
  of: BitqueryElrondEventsMeasureable;
};


/** Events in Elrond blockchain */
export type BitqueryElrondEventCountArgs = {
  uniq?: InputMaybe<BitqueryElrondEventUniq>;
};


/** Events in Elrond blockchain */
export type BitqueryElrondEventCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryElrondEventUniq>;
};


/** Events in Elrond blockchain */
export type BitqueryElrondEventExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Events in Elrond blockchain */
export type BitqueryElrondEventMaximumArgs = {
  get?: InputMaybe<BitqueryElrondEventsMeasureable>;
  of: BitqueryElrondEventsMeasureable;
};


/** Events in Elrond blockchain */
export type BitqueryElrondEventMiniblockArgs = {
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Events in Elrond blockchain */
export type BitqueryElrondEventMinimumArgs = {
  get?: InputMaybe<BitqueryElrondEventsMeasureable>;
  of: BitqueryElrondEventsMeasureable;
};


/** Events in Elrond blockchain */
export type BitqueryElrondEventSenderBlockArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
};


/** Events in Elrond blockchain */
export type BitqueryElrondEventTransactionArgs = {
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  txFunction?: InputMaybe<BitqueryStringSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
};


/** Events in Elrond blockchain */
export type BitqueryElrondEventValueArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  callResultPath?: InputMaybe<BitqueryStringSelector>;
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  eventIndex?: InputMaybe<BitqueryIntegerSelector>;
  eventType?: InputMaybe<BitqueryEventTypeSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  identifier?: InputMaybe<BitqueryStringSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  txFunction?: InputMaybe<BitqueryStringSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryElrondEventFilter = {
  address?: InputMaybe<BitqueryAddressSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  callResultPath?: InputMaybe<BitqueryStringSelector>;
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  eventIndex?: InputMaybe<BitqueryIntegerSelector>;
  eventType?: InputMaybe<BitqueryEventTypeSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  identifier?: InputMaybe<BitqueryStringSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  txFunction?: InputMaybe<BitqueryStringSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};

export enum BitqueryElrondEventUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique count of block in the blockchains */
  Height = 'height',
  /** Unique time */
  Times = 'times',
  /** Unique count of transactions */
  Txs = 'txs'
}

export enum BitqueryElrondEventsMeasureable {
  /** Address */
  Address = 'address',
  /** Hash of the the block */
  BlockHash = 'block_hash',
  /** Call Result Path */
  CallResultPath = 'call_result_path',
  /** Data */
  Data = 'data',
  /** Date */
  Date = 'date',
  /** Event Index */
  EventIndex = 'event_index',
  /** Event Type */
  EventType = 'event_type',
  /** Gas Limit */
  GasLimit = 'gas_limit',
  /** Gas Price */
  GasPrice = 'gas_price',
  /** Gas Used */
  GasUsed = 'gas_used',
  /** Number of block in the blockhains */
  Height = 'height',
  /** Identifier */
  Identifier = 'identifier',
  /** Hash of the miniblock */
  MiniblockHash = 'miniblock_hash',
  /** Hash of the miniblocks receiver block */
  MiniblockReceiverBlockHash = 'miniblock_receiver_block_hash',
  /** Miniblock receiver shard */
  MiniblockReceiverShard = 'miniblock_receiver_shard',
  /** The block hash of this block`s parent */
  PreviousBlockHash = 'previous_block_hash',
  /** Time */
  Time = 'time',
  /** The block hash of this block`s parent */
  TransactionCount = 'transaction_count',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Receiver hash */
  TxReceiver = 'tx_receiver',
  /** Shard number of the receiver */
  TxReceiverShard = 'tx_receiver_shard',
  /** Sender hash */
  TxSender = 'tx_sender',
  /** Shard number of the sender */
  TxSenderShard = 'tx_sender_shard',
  /** Value */
  TxValue = 'tx_value',
  /** Type of miniblock */
  Type = 'type'
}

export type BitqueryElrondExtraInfo = {
  __typename?: 'BitqueryElrondExtraInfo';
  /** Root Hash */
  rootHash?: Maybe<Scalars['String']['output']>;
  /** Shard */
  shard?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Transactions Count */
  txCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
};

/** Miniblocks in Elrond  blockchain */
export type BitqueryElrondMiniblock = {
  __typename?: 'BitqueryElrondMiniblock';
  any?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Miniblock hash */
  hash?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Hash of the receiver block */
  receiverBlockHash?: Maybe<Scalars['String']['output']>;
  /** Number of the receiver shard */
  receiverShard?: Maybe<Scalars['String']['output']>;
  /** Information about miniblocks block */
  senderBlock?: Maybe<BitqueryElrondBlockDimension>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Miniblock type */
  type?: Maybe<Scalars['String']['output']>;
};


/** Miniblocks in Elrond  blockchain */
export type BitqueryElrondMiniblockAnyArgs = {
  of: BitqueryElrondMiniblocksMeasureable;
};


/** Miniblocks in Elrond  blockchain */
export type BitqueryElrondMiniblockCountArgs = {
  uniq?: InputMaybe<BitqueryElrondMiniblockUniq>;
};


/** Miniblocks in Elrond  blockchain */
export type BitqueryElrondMiniblockCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryElrondMiniblockUniq>;
};


/** Miniblocks in Elrond  blockchain */
export type BitqueryElrondMiniblockExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Miniblocks in Elrond  blockchain */
export type BitqueryElrondMiniblockMaximumArgs = {
  get?: InputMaybe<BitqueryElrondMiniblocksMeasureable>;
  of: BitqueryElrondMiniblocksMeasureable;
};


/** Miniblocks in Elrond  blockchain */
export type BitqueryElrondMiniblockMinimumArgs = {
  get?: InputMaybe<BitqueryElrondMiniblocksMeasureable>;
  of: BitqueryElrondMiniblocksMeasureable;
};

export type BitqueryElrondMiniblockFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  receiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  receiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};

export enum BitqueryElrondMiniblockUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique Number of block in the blockchains */
  Height = 'height',
  /** Unique time */
  Times = 'times'
}

export enum BitqueryElrondMiniblocksMeasureable {
  /** Hash of the the block */
  BlockHash = 'block_hash',
  /** Date */
  Date = 'date',
  /** Hash of the miniblock */
  Hash = 'hash',
  /** Number of block in the blockhains */
  Height = 'height',
  /** The block hash of this block`s parent */
  PreviousBlockHash = 'previous_block_hash',
  /** Hash of the miniblocks receiver block */
  ReceiverBlockHash = 'receiver_block_hash',
  /** Miniblock receiver shard */
  ReceiverShard = 'receiver_shard',
  /** Time */
  Time = 'time',
  /** Count of transactions */
  TransactionCount = 'transaction_count',
  /** Type of miniblock */
  Type = 'type'
}

export enum BitqueryElrondNetwork {
  /** Elrond mainnet */
  Elrond = 'elrond'
}

/** NotarizedBlocks in Elrond blockchain */
export type BitqueryElrondNotarizedBlock = {
  __typename?: 'BitqueryElrondNotarizedBlock';
  any?: Maybe<Scalars['String']['output']>;
  /** Information about blocks notarized block */
  block?: Maybe<BitqueryElrondBlockDimension>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Hash of the notarized block */
  notarizedBlockHash?: Maybe<Scalars['String']['output']>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
};


/** NotarizedBlocks in Elrond blockchain */
export type BitqueryElrondNotarizedBlockAnyArgs = {
  of: BitqueryElrondNotarizedBlocksMeasureable;
};


/** NotarizedBlocks in Elrond blockchain */
export type BitqueryElrondNotarizedBlockCountArgs = {
  uniq?: InputMaybe<BitqueryElrondNotarizedBlockUniq>;
};


/** NotarizedBlocks in Elrond blockchain */
export type BitqueryElrondNotarizedBlockCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryElrondNotarizedBlockUniq>;
};


/** NotarizedBlocks in Elrond blockchain */
export type BitqueryElrondNotarizedBlockExpressionArgs = {
  get: Scalars['String']['input'];
};


/** NotarizedBlocks in Elrond blockchain */
export type BitqueryElrondNotarizedBlockMaximumArgs = {
  get?: InputMaybe<BitqueryElrondNotarizedBlocksMeasureable>;
  of: BitqueryElrondNotarizedBlocksMeasureable;
};


/** NotarizedBlocks in Elrond blockchain */
export type BitqueryElrondNotarizedBlockMinimumArgs = {
  get?: InputMaybe<BitqueryElrondNotarizedBlocksMeasureable>;
  of: BitqueryElrondNotarizedBlocksMeasureable;
};

export type BitqueryElrondNotarizedBlockFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  notarizedBlockHash?: InputMaybe<BitqueryHashSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
};

export enum BitqueryElrondNotarizedBlockUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique Number of block in the blockchains */
  Height = 'height',
  /** Unique hash of notarized block */
  NotarizedBlockHash = 'notarized_block_hash',
  /** Unique time */
  Times = 'times'
}

export enum BitqueryElrondNotarizedBlocksMeasureable {
  /** Date */
  Date = 'date',
  /** Block epoch */
  Epoch = 'epoch',
  /** Hash of the the block */
  Hash = 'hash',
  /** Number of block in the blockhains */
  Height = 'height',
  /** Block nonce */
  Nonce = 'nonce',
  /** Notarized block hash */
  NotarizedBlockHash = 'notarized_block_hash',
  /** The block hash of this block`s parent */
  PreviousBlockHash = 'previous_block_hash',
  /** Block proposer */
  Proposer = 'proposer',
  /** Block public key bitmap */
  PublicKeyBitmap = 'public_key_bitmap',
  /** Block round */
  Round = 'round',
  /** Shard number of block */
  Shard = 'shard',
  /** Block size */
  Size = 'size',
  /** Block size txs */
  SizeTxs = 'size_txs',
  /** State root hash */
  StateRootHash = 'state_root_hash',
  /** Time */
  Time = 'time',
  /** Count of transactions in this block */
  TransactionCount = 'transaction_count'
}

/** Operations in Elrond blockchain */
export type BitqueryElrondOperation = {
  __typename?: 'BitqueryElrondOperation';
  /** Action */
  action?: Maybe<Scalars['String']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Data */
  data?: Maybe<Scalars['String']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Index */
  index?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Message */
  message?: Maybe<Scalars['String']['output']>;
  /** Information about calls miniblock */
  miniblock?: Maybe<BitqueryMiniblockElrond>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Sender */
  sender?: Maybe<BitqueryAddress>;
  /** Information about calls block */
  senderBlock?: Maybe<BitqueryElrondBlockDimension>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Information about calls transaction */
  transaction?: Maybe<BitqueryTransactionElrond>;
  /** Type */
  type?: Maybe<Scalars['String']['output']>;
};


/** Operations in Elrond blockchain */
export type BitqueryElrondOperationAnyArgs = {
  of: BitqueryElrondOperationsMeasureable;
};


/** Operations in Elrond blockchain */
export type BitqueryElrondOperationCountArgs = {
  uniq?: InputMaybe<BitqueryElrondOperationUniq>;
};


/** Operations in Elrond blockchain */
export type BitqueryElrondOperationCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryElrondOperationUniq>;
};


/** Operations in Elrond blockchain */
export type BitqueryElrondOperationExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Operations in Elrond blockchain */
export type BitqueryElrondOperationMaximumArgs = {
  get?: InputMaybe<BitqueryElrondOperationsMeasureable>;
  of: BitqueryElrondOperationsMeasureable;
};


/** Operations in Elrond blockchain */
export type BitqueryElrondOperationMiniblockArgs = {
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Operations in Elrond blockchain */
export type BitqueryElrondOperationMinimumArgs = {
  get?: InputMaybe<BitqueryElrondOperationsMeasureable>;
  of: BitqueryElrondOperationsMeasureable;
};


/** Operations in Elrond blockchain */
export type BitqueryElrondOperationSenderBlockArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
};


/** Operations in Elrond blockchain */
export type BitqueryElrondOperationTransactionArgs = {
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  txFunction?: InputMaybe<BitqueryStringSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
};

export type BitqueryElrondOperationFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  operationAction?: InputMaybe<BitqueryStringSelector>;
  operationData?: InputMaybe<BitqueryStringSelector>;
  operationIndex?: InputMaybe<BitqueryIntegerSelector>;
  operationReceiver?: InputMaybe<BitqueryAddressSelector>;
  operationSender?: InputMaybe<BitqueryAddressSelector>;
  operationType?: InputMaybe<BitqueryStringSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  txFunction?: InputMaybe<BitqueryStringSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};

export enum BitqueryElrondOperationUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique count of block in the blockchains */
  Height = 'height',
  /** Unique count of operations */
  Operations = 'operations',
  /** Unique time */
  Times = 'times',
  /** Unique count of transactions */
  Txs = 'txs'
}

export enum BitqueryElrondOperationsMeasureable {
  /** Hash of the the block */
  BlockHash = 'block_hash',
  /** Data */
  Data = 'data',
  /** Date */
  Date = 'date',
  /** Gas Limit */
  GasLimit = 'gas_limit',
  /** Gas Price */
  GasPrice = 'gas_price',
  /** Gas Used */
  GasUsed = 'gas_used',
  /** Number of block in the blockhains */
  Height = 'height',
  /** Hash of the miniblock */
  MiniblockHash = 'miniblock_hash',
  /** Hash of the miniblocks receiver block */
  MiniblockReceiverBlockHash = 'miniblock_receiver_block_hash',
  /** Miniblock receiver shard */
  MiniblockReceiverShard = 'miniblock_receiver_shard',
  /** Operation Action */
  OperationAction = 'operation_action',
  /** Operation data */
  OperationData = 'operation_data',
  /** Operation Index */
  OperationIndex = 'operation_index',
  /** Operation message */
  OperationMessage = 'operation_message',
  /** Operation receiver */
  OperationReceiver = 'operation_receiver',
  /** Operation sender */
  OperationSender = 'operation_sender',
  /** Operation type */
  OperationType = 'operation_type',
  /** The block hash of this block`s parent */
  PreviousBlockHash = 'previous_block_hash',
  /** Time */
  Time = 'time',
  /** The block hash of this block`s parent */
  TransactionCount = 'transaction_count',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Receiver hash */
  TxReceiver = 'tx_receiver',
  /** Shard number of the receiver */
  TxReceiverShard = 'tx_receiver_shard',
  /** Sender hash */
  TxSender = 'tx_sender',
  /** Shard number of the sender */
  TxSenderShard = 'tx_sender_shard',
  /** Value */
  TxValue = 'tx_value',
  /** Type of miniblock */
  Type = 'type'
}

/** Tokens Info */
export type BitqueryElrondTokensInfo = {
  __typename?: 'BitqueryElrondTokensInfo';
  /** Token Balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** Currency Info */
  currency?: Maybe<BitqueryCurrency>;
};

/** Transactions in Elrond blockchain */
export type BitqueryElrondTransaction = {
  __typename?: 'BitqueryElrondTransaction';
  /** Transaction Action */
  action?: Maybe<BitqueryElrondTransactionAction>;
  any?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Data */
  data?: Maybe<Scalars['String']['output']>;
  /** Data operation */
  dataOperation?: Maybe<Scalars['String']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  fee?: Maybe<Scalars['Float']['output']>;
  /** Tx function */
  function?: Maybe<Scalars['String']['output']>;
  /** Number of gas limit */
  gasLimit?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Number of gas price */
  gasPrice?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Number of gas used */
  gasUsed?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Transaction hash */
  hash?: Maybe<Scalars['String']['output']>;
  /** Transaction index */
  index?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Information about transactions miniblock */
  miniblock?: Maybe<BitqueryMiniblockElrond>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Transaction nonce */
  nonce?: Maybe<Scalars['Int']['output']>;
  /** TX  receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Shard number of receiver */
  receiverShard?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Hash of the sender */
  sender?: Maybe<BitqueryAddress>;
  /** Information about transactions block */
  senderBlock?: Maybe<BitqueryElrondBlockDimension>;
  /** Shard number of sender */
  senderShard?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Signature */
  signature?: Maybe<Scalars['String']['output']>;
  /** Tx Status */
  status?: Maybe<Scalars['String']['output']>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  value?: Maybe<Scalars['Float']['output']>;
};


/** Transactions in Elrond blockchain */
export type BitqueryElrondTransactionAnyArgs = {
  of: BitqueryElrondTransactionsMeasureable;
};


/** Transactions in Elrond blockchain */
export type BitqueryElrondTransactionCountArgs = {
  uniq?: InputMaybe<BitqueryElrondTransactionUniq>;
};


/** Transactions in Elrond blockchain */
export type BitqueryElrondTransactionCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryElrondTransactionUniq>;
};


/** Transactions in Elrond blockchain */
export type BitqueryElrondTransactionExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transactions in Elrond blockchain */
export type BitqueryElrondTransactionFeeArgs = {
  actionCategory?: InputMaybe<BitqueryStringSelector>;
  actionDescription?: InputMaybe<BitqueryStringSelector>;
  actionName?: InputMaybe<BitqueryStringSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  function?: InputMaybe<BitqueryStringSelector>;
  gasLimit?: InputMaybe<BitqueryFloatSelector>;
  gasPrice?: InputMaybe<BitqueryFloatSelector>;
  gasUsed?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txNonce?: InputMaybe<BitqueryIntegerSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txValue?: InputMaybe<BitqueryFloatSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Transactions in Elrond blockchain */
export type BitqueryElrondTransactionMaximumArgs = {
  get?: InputMaybe<BitqueryElrondTransactionsMeasureable>;
  of: BitqueryElrondTransactionsMeasureable;
};


/** Transactions in Elrond blockchain */
export type BitqueryElrondTransactionMinimumArgs = {
  get?: InputMaybe<BitqueryElrondTransactionsMeasureable>;
  of: BitqueryElrondTransactionsMeasureable;
};


/** Transactions in Elrond blockchain */
export type BitqueryElrondTransactionValueArgs = {
  actionCategory?: InputMaybe<BitqueryStringSelector>;
  actionDescription?: InputMaybe<BitqueryStringSelector>;
  actionName?: InputMaybe<BitqueryStringSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  function?: InputMaybe<BitqueryStringSelector>;
  gasLimit?: InputMaybe<BitqueryFloatSelector>;
  gasPrice?: InputMaybe<BitqueryFloatSelector>;
  gasUsed?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txNonce?: InputMaybe<BitqueryIntegerSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txValue?: InputMaybe<BitqueryFloatSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};

/** Action of transction information */
export type BitqueryElrondTransactionAction = {
  __typename?: 'BitqueryElrondTransactionAction';
  /** Category */
  category?: Maybe<Scalars['String']['output']>;
  /** Description */
  description?: Maybe<Scalars['String']['output']>;
  /** Name */
  name?: Maybe<Scalars['String']['output']>;
};

export type BitqueryElrondTransactionFilter = {
  actionCategory?: InputMaybe<BitqueryStringSelector>;
  actionDescription?: InputMaybe<BitqueryStringSelector>;
  actionName?: InputMaybe<BitqueryStringSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  function?: InputMaybe<BitqueryStringSelector>;
  gasLimit?: InputMaybe<BitqueryFloatSelector>;
  gasPrice?: InputMaybe<BitqueryFloatSelector>;
  gasUsed?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txNonce?: InputMaybe<BitqueryIntegerSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txValue?: InputMaybe<BitqueryFloatSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};

export enum BitqueryElrondTransactionUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique Number of block in the blockchains */
  Height = 'height',
  /** Unique time */
  Times = 'times'
}

/** Blockchain transaction with value */
export type BitqueryElrondTransactionValueDimension = {
  __typename?: 'BitqueryElrondTransactionValueDimension';
  /** Transaction hash */
  hash: Scalars['String']['output'];
  /** Transaction value */
  value: Scalars['Float']['output'];
};

export enum BitqueryElrondTransactionsMeasureable {
  /** Action Category */
  ActionCategory = 'action_category',
  /** Action Description */
  ActionDescription = 'action_description',
  /** Action Name */
  ActionName = 'action_name',
  /** Hash of the the block */
  BlockHash = 'block_hash',
  /** Data */
  Data = 'data',
  /** Date */
  Date = 'date',
  /** Action Function */
  Function = 'function',
  /** Gas Limit */
  GasLimit = 'gas_limit',
  /** Gas Price */
  GasPrice = 'gas_price',
  /** Gas Used */
  GasUsed = 'gas_used',
  /** Transaction hash */
  Hash = 'hash',
  /** Number of block in the blockhains */
  Height = 'height',
  /** Hash of the miniblock */
  MiniblockHash = 'miniblock_hash',
  /** Hash of the miniblocks receiver block */
  MiniblockReceiverBlockHash = 'miniblock_receiver_block_hash',
  /** Miniblock receiver shard */
  MiniblockReceiverShard = 'miniblock_receiver_shard',
  /** The block hash of this block`s parent */
  PreviousBlockHash = 'previous_block_hash',
  /** Time */
  Time = 'time',
  /** The block hash of this block`s parent */
  TransactionCount = 'transaction_count',
  /** Receiver hash */
  TxReceiver = 'tx_receiver',
  /** Shard number of the receiver */
  TxReceiverShard = 'tx_receiver_shard',
  /** Sender hash */
  TxSender = 'tx_sender',
  /** Shard number of the sender */
  TxSenderShard = 'tx_sender_shard',
  /** Type of miniblock */
  Type = 'type',
  /** Value */
  Value = 'value'
}

/** Transfers of Smart Contract Calls and Events */
export type BitqueryElrondTransfer = {
  __typename?: 'BitqueryElrondTransfer';
  /** Action */
  action?: Maybe<Scalars['String']['output']>;
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  /** Entity ID */
  entityId?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Esdt Type */
  esdtType?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Information about arguments miniblock */
  miniblock?: Maybe<BitqueryMiniblockElrond>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver account address */
  receiver?: Maybe<BitqueryAddress>;
  /** Sender account address */
  sender?: Maybe<BitqueryAddress>;
  /** Information about arguments block */
  senderBlock?: Maybe<BitqueryElrondBlockDimension>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Information about arguments transaction */
  transaction?: Maybe<BitqueryTransactionElrond>;
  /** Type */
  type?: Maybe<Scalars['String']['output']>;
};


/** Transfers of Smart Contract Calls and Events */
export type BitqueryElrondTransferAmountArgs = {
  action?: InputMaybe<BitqueryActionSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  esdtType?: InputMaybe<BitqueryStringSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  transferReceiver?: InputMaybe<BitqueryAddressSelector>;
  transferSender?: InputMaybe<BitqueryAddressSelector>;
  transferType?: InputMaybe<BitqueryStringSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Transfers of Smart Contract Calls and Events */
export type BitqueryElrondTransferAnyArgs = {
  of: BitqueryElrondTransfersMeasureable;
};


/** Transfers of Smart Contract Calls and Events */
export type BitqueryElrondTransferCountArgs = {
  uniq?: InputMaybe<BitqueryElrondTransferUniq>;
};


/** Transfers of Smart Contract Calls and Events */
export type BitqueryElrondTransferCountBigIntArgs = {
  action?: InputMaybe<BitqueryActionSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  esdtType?: InputMaybe<BitqueryStringSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  transferReceiver?: InputMaybe<BitqueryAddressSelector>;
  transferSender?: InputMaybe<BitqueryAddressSelector>;
  transferType?: InputMaybe<BitqueryStringSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryElrondTransferUniq>;
};


/** Transfers of Smart Contract Calls and Events */
export type BitqueryElrondTransferCurrencyArgs = {
  currency?: InputMaybe<BitqueryCurrencySelector>;
};


/** Transfers of Smart Contract Calls and Events */
export type BitqueryElrondTransferExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transfers of Smart Contract Calls and Events */
export type BitqueryElrondTransferMaximumArgs = {
  get?: InputMaybe<BitqueryElrondTransfersMeasureable>;
  of: BitqueryElrondTransfersMeasureable;
};


/** Transfers of Smart Contract Calls and Events */
export type BitqueryElrondTransferMiniblockArgs = {
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Transfers of Smart Contract Calls and Events */
export type BitqueryElrondTransferMinimumArgs = {
  get?: InputMaybe<BitqueryElrondTransfersMeasureable>;
  of: BitqueryElrondTransfersMeasureable;
};


/** Transfers of Smart Contract Calls and Events */
export type BitqueryElrondTransferSenderBlockArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transfers of Smart Contract Calls and Events */
export type BitqueryElrondTransferTransactionArgs = {
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  txFunction?: InputMaybe<BitqueryStringSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
};

export type BitqueryElrondTransferFilter = {
  action?: InputMaybe<BitqueryActionSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  esdtType?: InputMaybe<BitqueryStringSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  transferReceiver?: InputMaybe<BitqueryAddressSelector>;
  transferSender?: InputMaybe<BitqueryAddressSelector>;
  transferType?: InputMaybe<BitqueryStringSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};

export enum BitqueryElrondTransferUniq {
  /** Unique Number of block in the blockchains */
  BlockHeight = 'block_height',
  /** Unique date count */
  Dates = 'dates',
  /** Unique Transaction Hash */
  Signature = 'signature',
  /** Unique time */
  Times = 'times',
  /** Unique count of transfers type */
  TransferType = 'transferType',
  /** Unique count of transactions */
  Txs = 'txs'
}

export enum BitqueryElrondTransfersMeasureable {
  /** Action */
  Action = 'action',
  /** Transfer Amount */
  Amount = 'amount',
  /** Hash of the the block */
  BlockHash = 'block_hash',
  /** Token address */
  CurrencyAddress = 'currency_address',
  /** Currency symbol */
  CurrencySymbol = 'currency_symbol',
  /** Data */
  Data = 'data',
  /** Date */
  Date = 'date',
  /** Entity ID */
  EntityId = 'entity_id',
  /** ESDT Type */
  EsdtType = 'esdtType',
  /** Gas Limit */
  GasLimit = 'gas_limit',
  /** Gas Price */
  GasPrice = 'gas_price',
  /** Gas Used */
  GasUsed = 'gas_used',
  /** Number of block in the blockhains */
  Height = 'height',
  /** Hash of the miniblock */
  MiniblockHash = 'miniblock_hash',
  /** Hash of the miniblocks receiver block */
  MiniblockReceiverBlockHash = 'miniblock_receiver_block_hash',
  /** Miniblock receiver shard */
  MiniblockReceiverShard = 'miniblock_receiver_shard',
  /** The block hash of this block`s parent */
  PreviousBlockHash = 'previous_block_hash',
  /** Receiver */
  Receiver = 'receiver',
  /** Sender */
  Sender = 'sender',
  /** Time */
  Time = 'time',
  /** Token ID */
  TokenId = 'token_id',
  /** Token type */
  TokenType = 'token_type',
  /** The block hash of this block`s parent */
  TransactionCount = 'transaction_count',
  /** Transfer Type */
  TransferType = 'transferType',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Receiver hash */
  TxReceiver = 'tx_receiver',
  /** Shard number of the receiver */
  TxReceiverShard = 'tx_receiver_shard',
  /** Sender hash */
  TxSender = 'tx_sender',
  /** Shard number of the sender */
  TxSenderShard = 'tx_sender_shard',
  /** Value */
  TxValue = 'tx_value',
  /** Type of miniblock */
  Type = 'type'
}

/** Entity */
export type BitqueryEntity = {
  __typename?: 'BitqueryEntity';
  /** Entity ID */
  id: Scalars['String']['output'];
  /** Entity number */
  num: Scalars['Int']['output'];
  /** Entity realm ID */
  realmId: Scalars['Int']['output'];
  /** Entity shard ID */
  shardId: Scalars['Int']['output'];
  /** Entity Type */
  type: Scalars['String']['output'];
};


/** Entity */
export type BitqueryEntityIdArgs = {
  entityId?: InputMaybe<Scalars['String']['input']>;
};

/** Selector of entity ID for NFT  tokens */
export type BitqueryEntitySelector = {
  /** EntityID in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** EntityID is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** EntityID not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** EntityID not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export enum BitqueryEntityTypeEnum {
  /** account */
  Account = 'account',
  /** contract */
  Contract = 'contract',
  /** file */
  File = 'file',
  /** schedule */
  Schedule = 'schedule',
  /** token */
  Token = 'token',
  /** topic */
  Topic = 'topic'
}

/** Select by entity type */
export type BitqueryEntityTypeSelector = {
  /** Type in the list */
  in?: InputMaybe<Array<BitqueryEntityTypeEnum>>;
  /** Type is */
  is?: InputMaybe<BitqueryEntityTypeEnum>;
  /** Type not */
  not?: InputMaybe<BitqueryEntityTypeEnum>;
  /** Type not in the list */
  notIn?: InputMaybe<Array<BitqueryEntityTypeEnum>>;
};

/** EOS Chain */
export type BitqueryEos = {
  __typename?: 'BitqueryEos';
  /** Basic information about address ( or smart contract ) */
  address: Array<BitqueryEosAddressInfo>;
  /** Blockchain Address Statistics */
  addressStats?: Maybe<Array<BitqueryEosAddressStats>>;
  /** Blockchain Blocks */
  blocks?: Maybe<Array<BitqueryEosBlocks>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryEosCoinpath>>;
  /** Smart Contract Calls */
  smartContractCalls?: Maybe<Array<BitqueryEosSmartContractCalls>>;
  /** Blockchain Transactions */
  transactions?: Maybe<Array<BitqueryEosTransactions>>;
  /** Currency Transfers */
  transfers?: Maybe<Array<BitqueryEosTransfers>>;
};


/** EOS Chain */
export type BitqueryEosAddressArgs = {
  address: Array<BitqueryAddressSelectorIn>;
};


/** EOS Chain */
export type BitqueryEosAddressStatsArgs = {
  address: BitqueryAddressSelector;
  options?: InputMaybe<BitqueryQueryOptions>;
};


/** EOS Chain */
export type BitqueryEosBlocksArgs = {
  any?: InputMaybe<Array<BitqueryEosBlockFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  proposer?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** EOS Chain */
export type BitqueryEosCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<BitqueryEosCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCoinpathOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** EOS Chain */
export type BitqueryEosSmartContractCallsArgs = {
  any?: InputMaybe<Array<BitqueryEosSmartContractCallFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  scheduled?: InputMaybe<Scalars['Boolean']['input']>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** EOS Chain */
export type BitqueryEosTransactionsArgs = {
  any?: InputMaybe<Array<BitqueryEosTransactionFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  scheduled?: InputMaybe<Scalars['Boolean']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
};


/** EOS Chain */
export type BitqueryEosTransfersArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  any?: InputMaybe<Array<BitqueryEosTransferFilter>>;
  currency?: InputMaybe<BitqueryEosCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};

/** Address detailed information for EOS network */
export type BitqueryEosAddressInfo = {
  __typename?: 'BitqueryEosAddressInfo';
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<BitqueryEosSmartContractInfo>;
};

/** Address with statistics */
export type BitqueryEosAddressStat = {
  __typename?: 'BitqueryEosAddressStat';
  /** Address */
  address?: Maybe<BitqueryAddress>;
  /** Balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** Call Tx Count */
  callTxCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Called Tx Count */
  calledTxCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Days with received */
  daysWithReceived?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Days with sent */
  daysWithSent?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Days with transactions */
  daysWithTransactions?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Days with transfers */
  daysWithTransfers?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** First transfer at */
  firstTransferAt?: Maybe<BitqueryDateTime>;
  /** First tx at */
  firstTxAt?: Maybe<BitqueryDateTime>;
  /** Last transfer at */
  lastTransferAt?: Maybe<BitqueryDateTime>;
  /** Last tx at */
  lastTxAt?: Maybe<BitqueryDateTime>;
  /** Other Tx Count */
  otherTxCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Receive Amount */
  receiveAmount?: Maybe<Scalars['Float']['output']>;
  /** Receive from Count */
  receiveFromCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Receive from currencies */
  receiveFromCurrencies?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Receive tx Count */
  receiveTxCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Send Amount */
  sendAmount?: Maybe<Scalars['Float']['output']>;
  /** Send to count */
  sendToCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Send to currencies */
  sendToCurrencies?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Send tx count */
  sendTxCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
};

/** AddressStat */
export type BitqueryEosAddressStats = {
  __typename?: 'BitqueryEosAddressStats';
  /** Address With Statistics */
  address?: Maybe<BitqueryEosAddressStat>;
};

export type BitqueryEosBlockFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  proposer?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

/** Blocks in EOS blockchain */
export type BitqueryEosBlocks = {
  __typename?: 'BitqueryEosBlocks';
  any?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Block hash */
  hash: Scalars['String']['output'];
  /** Block number (height) in blockchain */
  height: Scalars['Int']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Block producer */
  producer?: Maybe<BitqueryAddress>;
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
};


/** Blocks in EOS blockchain */
export type BitqueryEosBlocksAnyArgs = {
  of: BitqueryEosBlocksMeasureable;
};


/** Blocks in EOS blockchain */
export type BitqueryEosBlocksCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  proposer?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryEosBlocksUniq>;
};


/** Blocks in EOS blockchain */
export type BitqueryEosBlocksCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  proposer?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryEosBlocksUniq>;
};


/** Blocks in EOS blockchain */
export type BitqueryEosBlocksExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Blocks in EOS blockchain */
export type BitqueryEosBlocksHashArgs = {
  blockHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Blocks in EOS blockchain */
export type BitqueryEosBlocksHeightArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Blocks in EOS blockchain */
export type BitqueryEosBlocksMaximumArgs = {
  get?: InputMaybe<BitqueryEosBlocksMeasureable>;
  of: BitqueryEosBlocksMeasureable;
};


/** Blocks in EOS blockchain */
export type BitqueryEosBlocksMinimumArgs = {
  get?: InputMaybe<BitqueryEosBlocksMeasureable>;
  of: BitqueryEosBlocksMeasureable;
};


/** Blocks in EOS blockchain */
export type BitqueryEosBlocksProducerArgs = {
  producer?: InputMaybe<BitqueryAddressSelector>;
};


/** Blocks in EOS blockchain */
export type BitqueryEosBlocksTimestampArgs = {
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

export enum BitqueryEosBlocksMeasureable {
  /** Block */
  Block = 'block',
  /** Block hash */
  BlockHash = 'block_hash',
  /** Date */
  Date = 'date',
  /** Block Proposer */
  Proposer = 'proposer',
  /** Time */
  Time = 'time'
}

export enum BitqueryEosBlocksUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique proposer count */
  Proposers = 'proposers'
}

export enum BitqueryEosCallsMeasureable {
  /** Block */
  Block = 'block',
  /** Call depth */
  CallDepth = 'call_depth',
  /** Date */
  Date = 'date',
  /** Smart Contract Method Signature */
  Signature = 'signature',
  /** Smart Contract Method Signature Hash */
  SignatureHash = 'signature_hash',
  /** Smart Contract Method Name */
  SignatureName = 'signature_name',
  /** Smart Contract */
  SmartContract = 'smart_contract',
  /** Time */
  Time = 'time',
  /** Action From */
  TxFrom = 'tx_from',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Sender */
  TxSender = 'tx_sender',
  /** Action To */
  TxTo = 'tx_to'
}

/** Coinpath */
export type BitqueryEosCoinpath = {
  __typename?: 'BitqueryEosCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryEosCoinpathAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryEosCoinpathAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<BitqueryTransactionHashValueTime>;
};


/** Coinpath */
export type BitqueryEosCoinpathAmountArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Coinpath */
export type BitqueryEosCoinpathAnyArgs = {
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryEosCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryEosCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};

/** Address detailed information for Eos network */
export type BitqueryEosCoinpathAddress = {
  __typename?: 'BitqueryEosCoinpathAddress';
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  amountIn?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  amountOut?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  balance?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Smart Contract if exists on the address */
  firstTxAt?: Maybe<BitqueryDateTime>;
  /** Smart Contract if exists on the address */
  lastTxAt?: Maybe<BitqueryDateTime>;
  receiversCount?: Maybe<Scalars['Int']['output']>;
  sendersCount?: Maybe<Scalars['Int']['output']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<BitqueryEosSmartContractInfo>;
  /** Address type */
  type?: Maybe<Scalars['String']['output']>;
};

/**
 * Currency selector in EOS blockchain.
 * Token identified by address of contract ( eosio.token for main EOS token )
 */
export type BitqueryEosCurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Currency not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export enum BitqueryEosNetwork {
  /** EOS mainnet */
  Eos = 'eos'
}

/** Eos smart contract */
export type BitqueryEosSmartContract = {
  __typename?: 'BitqueryEosSmartContract';
  /** Smart Contract Address */
  address: BitqueryAddress;
  /** Smart Contract Type */
  contractType?: Maybe<BitquerySmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<BitqueryScCurrency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']['output']>;
};

export type BitqueryEosSmartContractCallFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  scheduled?: InputMaybe<Scalars['Boolean']['input']>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};

/** Smart Contract Calls */
export type BitqueryEosSmartContractCalls = {
  __typename?: 'BitqueryEosSmartContractCalls';
  /** Actors */
  actors?: Maybe<Scalars['String']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callDepth?: Maybe<Scalars['String']['output']>;
  /** Console */
  console?: Maybe<Scalars['String']['output']>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']['output']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Error Code */
  errorCode?: Maybe<Scalars['Int']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** External call executed explicitly by tx sender. Internal calls executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Permissions */
  permissions?: Maybe<Scalars['String']['output']>;
  /** Receivers */
  receivers?: Maybe<Scalars['String']['output']>;
  /** True if call scheduled */
  scheduled?: Maybe<Scalars['Boolean']['output']>;
  /** Smart contract being called */
  smartContract?: Maybe<BitqueryEosSmartContract>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<BitqueryMethod>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Action from address */
  txFrom?: Maybe<BitqueryAddress>;
  /** Transaction hash where transfer happened */
  txHash?: Maybe<Scalars['String']['output']>;
  /** Action to address */
  txTo?: Maybe<BitqueryAddress>;
};


/** Smart Contract Calls */
export type BitqueryEosSmartContractCallsAnyArgs = {
  of: BitqueryEosCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryEosSmartContractCallsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Smart Contract Calls */
export type BitqueryEosSmartContractCallsCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  scheduled?: InputMaybe<Scalars['Boolean']['input']>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type BitqueryEosSmartContractCallsCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  scheduled?: InputMaybe<Scalars['Boolean']['input']>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type BitqueryEosSmartContractCallsErrorCodeArgs = {
  errorCode?: InputMaybe<BitqueryIntIdSelector>;
};


/** Smart Contract Calls */
export type BitqueryEosSmartContractCallsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Smart Contract Calls */
export type BitqueryEosSmartContractCallsExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Smart Contract Calls */
export type BitqueryEosSmartContractCallsMaximumArgs = {
  get?: InputMaybe<BitqueryEosCallsMeasureable>;
  of: BitqueryEosCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryEosSmartContractCallsMinimumArgs = {
  get?: InputMaybe<BitqueryEosCallsMeasureable>;
  of: BitqueryEosCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryEosSmartContractCallsScheduledArgs = {
  scheduled?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};


/** Smart Contract Calls */
export type BitqueryEosSmartContractCallsSmartContractArgs = {
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
};


/** Smart Contract Calls */
export type BitqueryEosSmartContractCallsSmartContractMethodArgs = {
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
};


/** Smart Contract Calls */
export type BitqueryEosSmartContractCallsSuccessArgs = {
  success?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};


/** Smart Contract Calls */
export type BitqueryEosSmartContractCallsTxFromArgs = {
  txFrom?: InputMaybe<BitqueryAddressSelector>;
};


/** Smart Contract Calls */
export type BitqueryEosSmartContractCallsTxHashArgs = {
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Smart Contract Calls */
export type BitqueryEosSmartContractCallsTxToArgs = {
  txTo?: InputMaybe<BitqueryAddressSelector>;
};

/** Blockchain smart contract */
export type BitqueryEosSmartContractInfo = {
  __typename?: 'BitqueryEosSmartContractInfo';
  /** Smart Contract Type */
  contractType?: Maybe<BitquerySmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<BitqueryScCurrency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']['output']>;
};

export type BitqueryEosTransactionFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  scheduled?: InputMaybe<Scalars['Boolean']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
};

/** Transactions in EOS blockchain */
export type BitqueryEosTransactions = {
  __typename?: 'BitqueryEosTransactions';
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BitqueryBlock>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  cpuUsageUs?: Maybe<Scalars['Int']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction index in block, 0 based */
  index?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  netUsageWords?: Maybe<Scalars['Int']['output']>;
  /** Success */
  scheduled?: Maybe<Scalars['Boolean']['output']>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
};


/** Transactions in EOS blockchain */
export type BitqueryEosTransactionsAnyArgs = {
  of: BitqueryEosTransactionsMeasureable;
};


/** Transactions in EOS blockchain */
export type BitqueryEosTransactionsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transactions in EOS blockchain */
export type BitqueryEosTransactionsCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  scheduled?: InputMaybe<Scalars['Boolean']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  uniq?: InputMaybe<BitqueryEosTransactionsUniq>;
};


/** Transactions in EOS blockchain */
export type BitqueryEosTransactionsCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  scheduled?: InputMaybe<Scalars['Boolean']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  uniq?: InputMaybe<BitqueryEosTransactionsUniq>;
};


/** Transactions in EOS blockchain */
export type BitqueryEosTransactionsCpuUsageUsArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  scheduled?: InputMaybe<Scalars['Boolean']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
};


/** Transactions in EOS blockchain */
export type BitqueryEosTransactionsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transactions in EOS blockchain */
export type BitqueryEosTransactionsHashArgs = {
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Transactions in EOS blockchain */
export type BitqueryEosTransactionsIndexArgs = {
  txIndex?: InputMaybe<Array<BitqueryTxIndexSelector>>;
};


/** Transactions in EOS blockchain */
export type BitqueryEosTransactionsMaximumArgs = {
  get?: InputMaybe<BitqueryEosTransactionsMeasureable>;
  of: BitqueryEosTransactionsMeasureable;
};


/** Transactions in EOS blockchain */
export type BitqueryEosTransactionsMinimumArgs = {
  get?: InputMaybe<BitqueryEosTransactionsMeasureable>;
  of: BitqueryEosTransactionsMeasureable;
};


/** Transactions in EOS blockchain */
export type BitqueryEosTransactionsNetUsageWordsArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  scheduled?: InputMaybe<Scalars['Boolean']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
};


/** Transactions in EOS blockchain */
export type BitqueryEosTransactionsScheduledArgs = {
  scheduled?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Transactions in EOS blockchain */
export type BitqueryEosTransactionsSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum BitqueryEosTransactionsMeasureable {
  /** Block */
  Block = 'block',
  /** CPU Usage */
  CpuUsageUs = 'cpu_usage_us',
  /** Date */
  Date = 'date',
  /** Net Usage */
  NetUsageWords = 'net_usage_words',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

export enum BitqueryEosTransactionsUniq {
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates'
}

export type BitqueryEosTransferFilter = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<BitqueryEosCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};

/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfers = {
  __typename?: 'BitqueryEosTransfers';
  /** Actors */
  actors?: Maybe<Scalars['String']['output']>;
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BitqueryBlock>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Entity identifier ( for ERC-721 NFT tokens ) */
  entityId?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Memo */
  memo?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Transfer receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Transfer sender */
  sender?: Maybe<BitqueryAddress>;
  /** Transfer succeeded */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Action from address */
  txFrom?: Maybe<BitqueryAddress>;
  /** Transaction hash where transfer happened */
  txHash?: Maybe<Scalars['String']['output']>;
  /** Action to address */
  txTo?: Maybe<BitqueryAddress>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfersAmountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<BitqueryEosCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfersAnyArgs = {
  of: BitqueryEosTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfersBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfersCountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<BitqueryEosCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryTransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfersCountBigIntArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<BitqueryEosCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryTransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfersCurrencyArgs = {
  currency?: InputMaybe<BitqueryEosCurrencySelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfersEntityIdArgs = {
  entityId?: InputMaybe<BitqueryEntitySelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfersExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfersExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfersMaximumArgs = {
  get?: InputMaybe<BitqueryEosTransfersMeasureable>;
  of: BitqueryEosTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfersMinimumArgs = {
  get?: InputMaybe<BitqueryEosTransfersMeasureable>;
  of: BitqueryEosTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfersReceiverArgs = {
  receiver?: InputMaybe<BitqueryAddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfersSenderArgs = {
  sender?: InputMaybe<BitqueryAddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfersSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfersTxFromArgs = {
  txFrom?: InputMaybe<BitqueryAddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfersTxHashArgs = {
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfersTxToArgs = {
  txTo?: InputMaybe<BitqueryAddressSelector>;
};

export enum BitqueryEosTransfersMeasureable {
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Token address */
  CurrencyAddress = 'currency_address',
  /** Currency symbol */
  CurrencySymbol = 'currency_symbol',
  /** Date */
  Date = 'date',
  /** Receiver */
  Receiver = 'receiver',
  /** Sender */
  Sender = 'sender',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

/** Ethereum Chain */
export type BitqueryEthereum = {
  __typename?: 'BitqueryEthereum';
  /** Ethereum Active Addresses */
  activeAddresses?: Maybe<Array<BitqueryEthereumActiveAddress>>;
  /** Basic information about address ( or smart contract ) */
  address: Array<BitqueryEthereumAddressInfoWithBalance>;
  /** Blockchain Address Statistics */
  addressStats?: Maybe<Array<BitqueryEthereumAddressStats>>;
  /** Arguments of Smart Contract Calls and Events */
  arguments?: Maybe<Array<BitqueryEthereumArguments>>;
  /** Blockchain Blocks */
  blocks?: Maybe<Array<BitqueryEthereumBlocks>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryEthereumCoinpath>>;
  /** Trades on Ethereum DEX Smart Contracts */
  dexTrades?: Maybe<Array<BitqueryEthereumDexTrades>>;
  /** References of Smart Contract Calls and Events */
  references?: Maybe<Array<BitqueryEthereumReferencess>>;
  /** Smart Contract Calls */
  smartContractCalls?: Maybe<Array<BitqueryEthereumSmartContractCalls>>;
  /** Smart Contract Events */
  smartContractEvents?: Maybe<Array<BitqueryEthereumSmartContractEvent>>;
  /** Blockchain Transactions */
  transactions?: Maybe<Array<BitqueryEthereumTransactions>>;
  /** Currency Transfers */
  transfers?: Maybe<Array<BitqueryEthereumTransfers>>;
};


/** Ethereum Chain */
export type BitqueryEthereumActiveAddressesArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  receiver?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Ethereum Chain */
export type BitqueryEthereumAddressArgs = {
  address: Array<BitqueryEthereumAddressSelectorIn>;
};


/** Ethereum Chain */
export type BitqueryEthereumAddressStatsArgs = {
  address: BitqueryEthereumAddressSelector;
  options?: InputMaybe<BitqueryQueryOptions>;
};


/** Ethereum Chain */
export type BitqueryEthereumArgumentsArgs = {
  any?: InputMaybe<Array<BitqueryEthereumArgumentFilter>>;
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Ethereum Chain */
export type BitqueryEthereumBlocksArgs = {
  any?: InputMaybe<Array<BitqueryEthereumBlockFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  options?: InputMaybe<BitqueryQueryOptions>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Ethereum Chain */
export type BitqueryEthereumCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryEthereumAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryEthereumAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCoinpathOptions>;
  receiver?: InputMaybe<BitqueryEthereumAddressSelector>;
  sender?: InputMaybe<BitqueryEthereumAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Ethereum Chain */
export type BitqueryEthereumDexTradesArgs = {
  any?: InputMaybe<Array<BitqueryEthereumDexTradeFilter>>;
  baseCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  makerSmartContractType?: InputMaybe<Array<BitquerySmartContractTypeSelector>>;
  options?: InputMaybe<BitqueryQueryOptions>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  takerSmartContractType?: InputMaybe<Array<BitquerySmartContractTypeSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Ethereum Chain */
export type BitqueryEthereumReferencesArgs = {
  any?: InputMaybe<Array<BitqueryEthereumReferencesFilter>>;
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Ethereum Chain */
export type BitqueryEthereumSmartContractCallsArgs = {
  any?: InputMaybe<Array<BitqueryEthereumSmartContractCallFilter>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  smartContractType?: InputMaybe<BitquerySmartContractTypeSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Ethereum Chain */
export type BitqueryEthereumSmartContractEventsArgs = {
  any?: InputMaybe<Array<BitqueryEthereumSmartContractEventFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractType?: InputMaybe<BitquerySmartContractTypeSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Ethereum Chain */
export type BitqueryEthereumTransactionsArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  any?: InputMaybe<Array<BitqueryEthereumTransactionFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  feePayer?: InputMaybe<Array<BitqueryStringSelector>>;
  feeRatio?: InputMaybe<BitqueryTxIndexSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  gasValue?: InputMaybe<Array<BitqueryAmountSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCreates?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txType?: InputMaybe<Array<BitqueryStringSelector>>;
};


/** Ethereum Chain */
export type BitqueryEthereumTransfersArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  any?: InputMaybe<Array<BitqueryEthereumTransferFilter>>;
  currency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  receiver?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};

/** Ethereum v 2.0 Baecon Chain */
export type BitqueryEthereum2 = {
  __typename?: 'BitqueryEthereum2';
  /** Attestations in block */
  attestations?: Maybe<Array<BitqueryEthereum2Attestation>>;
  /** Attester Slashings */
  attesterSlashings?: Maybe<Array<BitqueryEthereum2AttesterSlashing>>;
  /** Blockchain Blocks */
  blocks?: Maybe<Array<BitqueryEthereum2Blocks>>;
  /** Attestations of blocks */
  deposits?: Maybe<Array<BitqueryEthereum2Deposit>>;
  /** Proposer Slashings */
  proposerSlashings?: Maybe<Array<BitqueryEthereum2ProposerSlashing>>;
  /** Validator Updates */
  validatorUpdates?: Maybe<Array<BitqueryEthereum2ValidatorUpdates>>;
  /** Voluntary Exits */
  voluntaryExits?: Maybe<Array<BitqueryEthereum2VoluntaryExit>>;
};


/** Ethereum v 2.0 Baecon Chain */
export type BitqueryEthereum2AttestationsArgs = {
  any?: InputMaybe<Array<BitqueryEthereum2Filter>>;
  attestationEpoch?: InputMaybe<Array<BitqueryIntegerSelector>>;
  attestationSlot?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  committeeIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Ethereum v 2.0 Baecon Chain */
export type BitqueryEthereum2AttesterSlashingsArgs = {
  any?: InputMaybe<Array<BitqueryEthereum2Filter>>;
  attestationEpoch?: InputMaybe<Array<BitqueryIntegerSelector>>;
  attestationSlot?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Ethereum v 2.0 Baecon Chain */
export type BitqueryEthereum2BlocksArgs = {
  any?: InputMaybe<Array<BitqueryEthereum2Filter>>;
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Ethereum v 2.0 Baecon Chain */
export type BitqueryEthereum2DepositsArgs = {
  any?: InputMaybe<Array<BitqueryEthereum2Filter>>;
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Ethereum v 2.0 Baecon Chain */
export type BitqueryEthereum2ProposerSlashingsArgs = {
  any?: InputMaybe<Array<BitqueryEthereum2Filter>>;
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  slashingEpoch?: InputMaybe<Array<BitqueryIntegerSelector>>;
  slashingProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  slashingSlot?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Ethereum v 2.0 Baecon Chain */
export type BitqueryEthereum2ValidatorUpdatesArgs = {
  any?: InputMaybe<Array<BitqueryEthereum2ValidatorUpdatesFilter>>;
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockProposerPubkey?: InputMaybe<Array<BitqueryHashSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<Array<BitqueryStringSelector>>;
  eth1BlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  eth1DepositCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  eth1DepositRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  stateRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  validatorActivationEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorBalance?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorBalanceChange?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorEffectiveBalance?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorExitEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  validatorPubkey?: InputMaybe<Array<BitqueryHashSelector>>;
  validatorSlashed?: InputMaybe<Array<BitqueryBooleanSelector>>;
  validatorStatus?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorWithdrawableEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorWithdrawalCredentials?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Ethereum v 2.0 Baecon Chain */
export type BitqueryEthereum2VoluntaryExitsArgs = {
  any?: InputMaybe<Array<BitqueryEthereum2Filter>>;
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  voluntaryExitEpoch?: InputMaybe<Array<BitqueryIntegerSelector>>;
};

/** Attestations in Ethereum v2.0 blockchain */
export type BitqueryEthereum2Attestation = {
  __typename?: 'BitqueryEthereum2Attestation';
  aggregationBits: Scalars['String']['output'];
  any?: Maybe<Scalars['String']['output']>;
  attestation: BitqueryEthereum2AttestationInfo;
  /** Attestation Index (0 based ) in block */
  attestationIndex: Scalars['Int']['output'];
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Block root hash */
  blockRoot: Scalars['String']['output'];
  /** Committee index for attestation */
  committeeIndex: Scalars['Int']['output'];
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Block Eth1 information */
  eth1: BitqueryEthereum2Eth1Info;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Block parent hash */
  parentRoot: Scalars['String']['output'];
  /** Block proposer */
  proposer?: Maybe<BitqueryEthereum2ValidatorInfo>;
  /** Block state root hash */
  stateRoot: Scalars['String']['output'];
  /** Validator */
  validator: BitqueryEthereum2ValidatorInfo;
  /** Sequential index of validator in committee ( 0-based) */
  validatorInCommitteeIndex: Scalars['Int']['output'];
};


/** Attestations in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttestationAnyArgs = {
  of: BitqueryEthereum2AttestationsMeasureable;
};


/** Attestations in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttestationBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Attestations in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttestationBlockRootArgs = {
  blockRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Attestations in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttestationCountArgs = {
  attestationEpoch?: InputMaybe<Array<BitqueryIntegerSelector>>;
  attestationSlot?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  committeeIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryEthereum2AttestationsUniq>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Attestations in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttestationCountBigIntArgs = {
  attestationEpoch?: InputMaybe<Array<BitqueryIntegerSelector>>;
  attestationSlot?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  committeeIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryEthereum2AttestationsUniq>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Attestations in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttestationExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Attestations in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttestationMaximumArgs = {
  get?: InputMaybe<BitqueryEthereum2AttestationsMeasureable>;
  of: BitqueryEthereum2AttestationsMeasureable;
};


/** Attestations in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttestationMinimumArgs = {
  get?: InputMaybe<BitqueryEthereum2AttestationsMeasureable>;
  of: BitqueryEthereum2AttestationsMeasureable;
};


/** Attestations in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttestationProposerArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
};

/** AttestationFieldInfo for Ethereum v 2.0 network */
export type BitqueryEthereum2AttestationFieldInfo = {
  __typename?: 'BitqueryEthereum2AttestationFieldInfo';
  epoch: Scalars['Int']['output'];
  /** Root Hash */
  root: Scalars['String']['output'];
};

/** AttestationInfo for Ethereum v 2.0 network */
export type BitqueryEthereum2AttestationInfo = {
  __typename?: 'BitqueryEthereum2AttestationInfo';
  beaconBlockRoot: Scalars['String']['output'];
  epoch: Scalars['Int']['output'];
  signature: Scalars['String']['output'];
  slot: Scalars['Int']['output'];
  source: BitqueryEthereum2AttestationFieldInfo;
  target: BitqueryEthereum2AttestationFieldInfo;
};

export enum BitqueryEthereum2AttestationsMeasureable {
  /** Block */
  Block = 'block',
  /** Block Proposer */
  BlockProposer = 'block_proposer',
  /** Block hash */
  BlockRootHash = 'block_root_hash',
  /** Committee Index */
  Committee = 'committee',
  /** Date */
  Date = 'date',
  /** Time */
  Time = 'time',
  /** Validator index */
  Validator = 'validator'
}

export enum BitqueryEthereum2AttestationsUniq {
  /** Unique attestation epochs */
  AttestationEpochs = 'attestation_epochs',
  /** Unique attestation slots */
  AttestationSlots = 'attestation_slots',
  /** Unique attestations */
  Attestations = 'attestations',
  /** Unique block proposers */
  BlockProposers = 'block_proposers',
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique commitees */
  Committees = 'committees',
  /** Unique date count */
  Dates = 'dates',
  /** Unique validators */
  Validators = 'validators'
}

/** Attester Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttesterSlashing = {
  __typename?: 'BitqueryEthereum2AttesterSlashing';
  any?: Maybe<Scalars['String']['output']>;
  attestation: BitqueryEthereum2AttestationInfo;
  /** Attestation slashing sequential number */
  attestationOrder: Scalars['Int']['output'];
  /** Attester Slashing Index (0 based ) in block */
  attesterSlashingIndex: Scalars['Int']['output'];
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Block root hash */
  blockRoot: Scalars['String']['output'];
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Block Eth1 information */
  eth1: BitqueryEthereum2Eth1Info;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Block parent hash */
  parentRoot: Scalars['String']['output'];
  /** Block proposer */
  proposer?: Maybe<BitqueryEthereum2ValidatorInfo>;
  /** Block state root hash */
  stateRoot: Scalars['String']['output'];
  /** Validator */
  validator: BitqueryEthereum2ValidatorInfo;
  /** Validator index in slashing sequential numbern */
  validatorInAttestationIndex: Scalars['Int']['output'];
};


/** Attester Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttesterSlashingAnyArgs = {
  of: BitqueryEthereum2AttesterSlashingMeasureable;
};


/** Attester Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttesterSlashingBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Attester Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttesterSlashingBlockRootArgs = {
  blockRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Attester Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttesterSlashingCountArgs = {
  attestationEpoch?: InputMaybe<Array<BitqueryIntegerSelector>>;
  attestationSlot?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryEthereum2AttesterSlashingsUniq>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Attester Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttesterSlashingCountBigIntArgs = {
  attestationEpoch?: InputMaybe<Array<BitqueryIntegerSelector>>;
  attestationSlot?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryEthereum2AttesterSlashingsUniq>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Attester Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttesterSlashingMaximumArgs = {
  get?: InputMaybe<BitqueryEthereum2AttesterSlashingMeasureable>;
  of: BitqueryEthereum2AttesterSlashingMeasureable;
};


/** Attester Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttesterSlashingMinimumArgs = {
  get?: InputMaybe<BitqueryEthereum2AttesterSlashingMeasureable>;
  of: BitqueryEthereum2AttesterSlashingMeasureable;
};


/** Attester Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttesterSlashingProposerArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
};

export enum BitqueryEthereum2AttesterSlashingMeasureable {
  /** Block */
  Block = 'block',
  /** Block Proposer */
  BlockProposer = 'block_proposer',
  /** Block hash */
  BlockRootHash = 'block_root_hash',
  /** Date */
  Date = 'date',
  /** Time */
  Time = 'time',
  /** Validator index */
  Validator = 'validator'
}

export enum BitqueryEthereum2AttesterSlashingsUniq {
  /** Unique slashing epochs */
  AttestationEpochs = 'attestation_epochs',
  /** Unique slashing slots */
  AttestationSlots = 'attestation_slots',
  /** Unique block proposers */
  BlockProposers = 'block_proposers',
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates',
  /** Unique validators */
  Validators = 'validators'
}

/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2Blocks = {
  __typename?: 'BitqueryEthereum2Blocks';
  any?: Maybe<Scalars['String']['output']>;
  attestationsCount?: Maybe<Scalars['Int']['output']>;
  attestationsCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  attesterSlashingsCount?: Maybe<Scalars['Int']['output']>;
  attesterSlashingsCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Block root hash */
  blockRoot: Scalars['String']['output'];
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  depositsCount?: Maybe<Scalars['Int']['output']>;
  depositsCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Epoch in blockchain */
  epoch: Scalars['Int']['output'];
  /** Block Eth1 information */
  eth1: BitqueryEthereum2Eth1Info;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Graffiti */
  graffiti: Scalars['String']['output'];
  /** Block number (height) in blockchain */
  height: Scalars['Int']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Block parent hash */
  parentRoot: Scalars['String']['output'];
  /** Block proposer */
  proposer?: Maybe<BitqueryEthereum2ValidatorInfo>;
  proposerSlashingsCount?: Maybe<Scalars['Int']['output']>;
  proposerSlashingsCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Randao Reveal */
  randaoReveal: Scalars['String']['output'];
  /** Block signature */
  signature: Scalars['String']['output'];
  /** Block state root hash */
  stateRoot: Scalars['String']['output'];
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  voluntaryExitsCount?: Maybe<Scalars['Int']['output']>;
  voluntaryExitsCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksAnyArgs = {
  of: BitqueryEthereum2BlocksMeasureable;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksAttestationsCountArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksAttestationsCountBigIntArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksAttesterSlashingsCountArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksAttesterSlashingsCountBigIntArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksBlockRootArgs = {
  blockRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksCountArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryEthereum2BlocksUniq>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksCountBigIntArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryEthereum2BlocksUniq>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksDepositsCountArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksDepositsCountBigIntArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksHeightArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksMaximumArgs = {
  get?: InputMaybe<BitqueryEthereum2BlocksMeasureable>;
  of: BitqueryEthereum2BlocksMeasureable;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksMinimumArgs = {
  get?: InputMaybe<BitqueryEthereum2BlocksMeasureable>;
  of: BitqueryEthereum2BlocksMeasureable;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksProposerArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksProposerSlashingsCountArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksProposerSlashingsCountBigIntArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksTimestampArgs = {
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksVoluntaryExitsCountArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksVoluntaryExitsCountBigIntArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

export enum BitqueryEthereum2BlocksMeasureable {
  /** Block */
  Block = 'block',
  /** Block Miner */
  BlockProposer = 'block_proposer',
  /** Block hash */
  BlockRootHash = 'block_root_hash',
  /** Date */
  Date = 'date',
  /** Time */
  Time = 'time'
}

export enum BitqueryEthereum2BlocksUniq {
  /** Unique proposers */
  BlockProposers = 'block_proposers',
  /** Unique date count */
  Dates = 'dates'
}

/** Deposit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2Deposit = {
  __typename?: 'BitqueryEthereum2Deposit';
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Block root hash */
  blockRoot: Scalars['String']['output'];
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Deposit Index (0 based ) in block */
  depositIndex: Scalars['Int']['output'];
  /** Block Eth1 information */
  eth1: BitqueryEthereum2Eth1Info;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Block parent hash */
  parentRoot: Scalars['String']['output'];
  proof: Scalars['String']['output'];
  /** Block proposer */
  proposer?: Maybe<BitqueryEthereum2ValidatorInfo>;
  signature: Scalars['String']['output'];
  /** Block state root hash */
  stateRoot: Scalars['String']['output'];
  /** Validator */
  validator: BitqueryEthereum2ValidatorInfo;
};


/** Deposit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2DepositAmountArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Deposit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2DepositAnyArgs = {
  of: BitqueryEthereum2DepositsMeasureable;
};


/** Deposit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2DepositBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Deposit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2DepositBlockRootArgs = {
  blockRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Deposit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2DepositCountArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryEthereum2DepositsUniq>;
};


/** Deposit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2DepositCountBigIntArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryEthereum2DepositsUniq>;
};


/** Deposit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2DepositExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Deposit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2DepositMaximumArgs = {
  get?: InputMaybe<BitqueryEthereum2DepositsMeasureable>;
  of: BitqueryEthereum2DepositsMeasureable;
};


/** Deposit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2DepositMinimumArgs = {
  get?: InputMaybe<BitqueryEthereum2DepositsMeasureable>;
  of: BitqueryEthereum2DepositsMeasureable;
};


/** Deposit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2DepositProposerArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
};

export enum BitqueryEthereum2DepositsMeasureable {
  /** Block */
  Block = 'block',
  /** Block Proposer */
  BlockProposer = 'block_proposer',
  /** Block hash */
  BlockRootHash = 'block_root_hash',
  /** Date */
  Date = 'date',
  /** Time */
  Time = 'time',
  /** Validator index */
  Validator = 'validator'
}

export enum BitqueryEthereum2DepositsUniq {
  /** Unique block proposers */
  BlockProposers = 'block_proposers',
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates',
  /** Unique validators */
  Validators = 'validators'
}

/** Eth1 attributes for Ethereum v 2.0 network */
export type BitqueryEthereum2Eth1Info = {
  __typename?: 'BitqueryEthereum2Eth1Info';
  /** Block Eth1 block hash */
  blockHash: Scalars['String']['output'];
  /** Block Eth1 deposit count */
  depositCount: Scalars['Int']['output'];
  /** Block Eth1 deposit root hash */
  depositRootHash: Scalars['String']['output'];
};

export type BitqueryEthereum2Filter = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

export enum BitqueryEthereum2Network {
  /** Beacon Chain Ethereum 2.0 */
  Eth2 = 'eth2',
  /** Medalla Ethereum 2.0 Beacon Testnet */
  Medalla = 'medalla'
}

/** Proposer attributes for Ethereum v 2.0 network */
export type BitqueryEthereum2ProposerInfo = {
  __typename?: 'BitqueryEthereum2ProposerInfo';
  /** Proposer Index as Integer */
  index: Scalars['Int']['output'];
  /** Proposer Pub Key */
  pubkey: Scalars['String']['output'];
};

/** Proposer Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ProposerSlashing = {
  __typename?: 'BitqueryEthereum2ProposerSlashing';
  any?: Maybe<Scalars['String']['output']>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Block root hash */
  blockRoot: Scalars['String']['output'];
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Block Eth1 information */
  eth1: BitqueryEthereum2Eth1Info;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Header slashing sequential numbern */
  headerOrder: Scalars['Int']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Block parent hash */
  parentRoot: Scalars['String']['output'];
  /** Block proposer */
  proposer?: Maybe<BitqueryEthereum2ValidatorInfo>;
  /** Proposer Slashing Index (0 based ) in block */
  proposerSlashingIndex: Scalars['Int']['output'];
  slashing: BitqueryEthereum2SlashingInfo;
  /** Block state root hash */
  stateRoot: Scalars['String']['output'];
};


/** Proposer Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ProposerSlashingAnyArgs = {
  of: BitqueryEthereum2ProposerSlashingMeasureable;
};


/** Proposer Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ProposerSlashingBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Proposer Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ProposerSlashingBlockRootArgs = {
  blockRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Proposer Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ProposerSlashingCountArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  slashingEpoch?: InputMaybe<Array<BitqueryIntegerSelector>>;
  slashingProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  slashingSlot?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryEthereum2ProposerSlashingsUniq>;
};


/** Proposer Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ProposerSlashingCountBigIntArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  slashingEpoch?: InputMaybe<Array<BitqueryIntegerSelector>>;
  slashingProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  slashingSlot?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryEthereum2ProposerSlashingsUniq>;
};


/** Proposer Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ProposerSlashingExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Proposer Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ProposerSlashingMaximumArgs = {
  get?: InputMaybe<BitqueryEthereum2ProposerSlashingMeasureable>;
  of: BitqueryEthereum2ProposerSlashingMeasureable;
};


/** Proposer Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ProposerSlashingMinimumArgs = {
  get?: InputMaybe<BitqueryEthereum2ProposerSlashingMeasureable>;
  of: BitqueryEthereum2ProposerSlashingMeasureable;
};


/** Proposer Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ProposerSlashingProposerArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
};

export enum BitqueryEthereum2ProposerSlashingMeasureable {
  /** Block */
  Block = 'block',
  /** Block Proposer */
  BlockProposer = 'block_proposer',
  /** Block hash */
  BlockRootHash = 'block_root_hash',
  /** Date */
  Date = 'date',
  /** Slashed Proposer */
  Proposer = 'proposer',
  /** Time */
  Time = 'time'
}

export enum BitqueryEthereum2ProposerSlashingsUniq {
  /** Unique block proposers */
  BlockProposers = 'block_proposers',
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates',
  /** Unique slashing epochs */
  SlashingEpochs = 'slashing_epochs',
  /** Unique slashing proposers */
  SlashingProposers = 'slashing_proposers',
  /** Unique slashing slots */
  SlashingSlots = 'slashing_slots'
}

/** SlashingInfo for Ethereum v 2.0 network */
export type BitqueryEthereum2SlashingInfo = {
  __typename?: 'BitqueryEthereum2SlashingInfo';
  /** Block body hash */
  bodyRoot: Scalars['String']['output'];
  epoch: Scalars['Int']['output'];
  /** Block parent hash */
  parentRoot: Scalars['String']['output'];
  /** Block proposer */
  proposer?: Maybe<BitqueryEthereum2ValidatorInfo>;
  signature: Scalars['String']['output'];
  slot: Scalars['Int']['output'];
  /** Block state root hash */
  stateRoot: Scalars['String']['output'];
};

/** Validator attributes for Ethereum v 2.0 network */
export type BitqueryEthereum2ValidatorInfo = {
  __typename?: 'BitqueryEthereum2ValidatorInfo';
  /** Validator Index as Integer */
  index: Scalars['Int']['output'];
  /** Validator Pub Key */
  pubkey: Scalars['String']['output'];
};

/** Validator Updates in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ValidatorUpdates = {
  __typename?: 'BitqueryEthereum2ValidatorUpdates';
  any?: Maybe<Scalars['String']['output']>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Block root hash */
  blockRootHash: Scalars['String']['output'];
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Epoch */
  epoch: Scalars['BitqueryBigInt']['output'];
  /** Block Eth1 information */
  eth1: BitqueryEthereum2Eth1Info;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Block parent hash */
  parentRootHash: Scalars['String']['output'];
  /** Block proposer */
  proposer?: Maybe<BitqueryEthereum2ProposerInfo>;
  /** Block state root hash */
  stateRootHash: Scalars['String']['output'];
  /** Time date */
  time?: Maybe<BitqueryDateTime>;
  /** Block validator */
  validator?: Maybe<BitqueryEthereum2ValidatorInfo>;
  /** Validator activation epoch */
  validatorActivationEpoch: Scalars['BitqueryBigInt']['output'];
  /** Validator balance */
  validatorBalance?: Maybe<Scalars['Float']['output']>;
  /** Validator balance change */
  validatorBalanceChange: Scalars['Float']['output'];
  /** Validator effective balance */
  validatorEffectiveBalance: Scalars['Float']['output'];
  /** Validator exit epoch */
  validatorExitEpoch: Scalars['BitqueryBigInt']['output'];
  /** Validator Slashed */
  validatorSlashed: Scalars['Boolean']['output'];
  /** Validator Status */
  validatorStatus: Scalars['String']['output'];
  /** Validator withdrawable epoch */
  validatorWithdrawableEpoch: Scalars['BitqueryBigInt']['output'];
  /** Validator Withdrawal Credentials */
  validatorWithdrawalCredentials: Scalars['String']['output'];
};


/** Validator Updates in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ValidatorUpdatesAnyArgs = {
  of: BitqueryEthereum2ValidatorUpdatesMeasureable;
};


/** Validator Updates in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ValidatorUpdatesCountArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockProposerPubkey?: InputMaybe<Array<BitqueryHashSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<Array<BitqueryStringSelector>>;
  eth1BlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  eth1DepositCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  eth1DepositRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  stateRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryEthereum2ValidatorUpdatesUniq>;
  validatorActivationEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorBalance?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorBalanceChange?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorEffectiveBalance?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorExitEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  validatorPubkey?: InputMaybe<Array<BitqueryHashSelector>>;
  validatorSlashed?: InputMaybe<Array<BitqueryBooleanSelector>>;
  validatorStatus?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorWithdrawableEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorWithdrawalCredentials?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Validator Updates in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ValidatorUpdatesCountBigIntArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockProposerPubkey?: InputMaybe<Array<BitqueryHashSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<Array<BitqueryStringSelector>>;
  eth1BlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  eth1DepositCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  eth1DepositRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  stateRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryEthereum2ValidatorUpdatesUniq>;
  validatorActivationEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorBalance?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorBalanceChange?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorEffectiveBalance?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorExitEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  validatorPubkey?: InputMaybe<Array<BitqueryHashSelector>>;
  validatorSlashed?: InputMaybe<Array<BitqueryBooleanSelector>>;
  validatorStatus?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorWithdrawableEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorWithdrawalCredentials?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Validator Updates in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ValidatorUpdatesExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Validator Updates in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ValidatorUpdatesMaximumArgs = {
  get?: InputMaybe<BitqueryEthereum2ValidatorUpdatesMeasureable>;
  of: BitqueryEthereum2ValidatorUpdatesMeasureable;
};


/** Validator Updates in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ValidatorUpdatesMinimumArgs = {
  get?: InputMaybe<BitqueryEthereum2ValidatorUpdatesMeasureable>;
  of: BitqueryEthereum2ValidatorUpdatesMeasureable;
};


/** Validator Updates in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ValidatorUpdatesValidatorBalanceArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockProposerPubkey?: InputMaybe<Array<BitqueryHashSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<Array<BitqueryStringSelector>>;
  eth1BlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  eth1DepositCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  eth1DepositRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  stateRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  validatorActivationEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorBalance?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorBalanceChange?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorEffectiveBalance?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorExitEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  validatorPubkey?: InputMaybe<Array<BitqueryHashSelector>>;
  validatorSlashed?: InputMaybe<Array<BitqueryBooleanSelector>>;
  validatorStatus?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorWithdrawableEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorWithdrawalCredentials?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Validator Updates in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ValidatorUpdatesValidatorBalanceChangeArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockProposerPubkey?: InputMaybe<Array<BitqueryHashSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<Array<BitqueryStringSelector>>;
  eth1BlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  eth1DepositCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  eth1DepositRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  stateRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  validatorActivationEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorBalance?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorBalanceChange?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorEffectiveBalance?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorExitEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  validatorPubkey?: InputMaybe<Array<BitqueryHashSelector>>;
  validatorSlashed?: InputMaybe<Array<BitqueryBooleanSelector>>;
  validatorStatus?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorWithdrawableEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorWithdrawalCredentials?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Validator Updates in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ValidatorUpdatesValidatorEffectiveBalanceArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockProposerPubkey?: InputMaybe<Array<BitqueryHashSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<Array<BitqueryStringSelector>>;
  eth1BlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  eth1DepositCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  eth1DepositRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  stateRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  validatorActivationEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorBalance?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorBalanceChange?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorEffectiveBalance?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorExitEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  validatorPubkey?: InputMaybe<Array<BitqueryHashSelector>>;
  validatorSlashed?: InputMaybe<Array<BitqueryBooleanSelector>>;
  validatorStatus?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorWithdrawableEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorWithdrawalCredentials?: InputMaybe<Array<BitqueryHashSelector>>;
};

export type BitqueryEthereum2ValidatorUpdatesFilter = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockProposerPubkey?: InputMaybe<Array<BitqueryHashSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<Array<BitqueryStringSelector>>;
  eth1BlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  eth1DepositCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  eth1DepositRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  stateRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  validatorActivationEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorBalance?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorBalanceChange?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorEffectiveBalance?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorExitEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  validatorPubkey?: InputMaybe<Array<BitqueryHashSelector>>;
  validatorSlashed?: InputMaybe<Array<BitqueryBooleanSelector>>;
  validatorStatus?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorWithdrawableEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorWithdrawalCredentials?: InputMaybe<Array<BitqueryHashSelector>>;
};

export enum BitqueryEthereum2ValidatorUpdatesMeasureable {
  /** Block */
  Block = 'block',
  /** Block hash */
  BlockRootHash = 'block_root_hash',
  /** Date */
  Date = 'date',
  /** Epoch */
  Epoch = 'epoch',
  /** Eth1 block hash */
  Eth1BlockHash = 'eth1_block_hash',
  /** Eth1 deposit count */
  Eth1DepositCount = 'eth1_deposit_count',
  /** Eth1 deposit root hash */
  Eth1DepositRootHash = 'eth1_deposit_root_hash',
  /** Parent root hash */
  ParentRootHash = 'parent_root_hash',
  /** Proposer index */
  ProposerIndex = 'proposer_index',
  /** Proposer pubkey hash */
  ProposerPubkeyHash = 'proposer_pubkey_hash',
  /** State root hash */
  StateRootHash = 'state_root_hash',
  /** Time */
  Time = 'time',
  /** Validator activation epoch */
  ValidatorActivationEpoch = 'validator_activation_epoch',
  /** Validator balance */
  ValidatorBalance = 'validator_balance',
  /** Validator balance change */
  ValidatorBalanceChange = 'validator_balance_change',
  /** Validator effective balance */
  ValidatorEffectiveBalance = 'validator_effective_balance',
  /** Validator exit epoch */
  ValidatorExitEpoch = 'validator_exit_epoch',
  /** Validator index */
  ValidatorIndex = 'validator_index',
  /** Validator pubkey hash */
  ValidatorPubkeyHash = 'validator_pubkey_hash',
  /** Validator slashed */
  ValidatorSlashed = 'validator_slashed',
  /** Validator withdrawable epoch */
  ValidatorWithdrawableEpoch = 'validator_withdrawable_epoch'
}

export enum BitqueryEthereum2ValidatorUpdatesUniq {
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates',
  /** Unique epochs */
  Epochs = 'epochs',
  /** Unique proposers */
  Proposers = 'proposers',
  /** Unique validators */
  Validators = 'validators'
}

/** Voluntary Exit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2VoluntaryExit = {
  __typename?: 'BitqueryEthereum2VoluntaryExit';
  any?: Maybe<Scalars['String']['output']>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Block root hash */
  blockRoot: Scalars['String']['output'];
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Block Eth1 information */
  eth1: BitqueryEthereum2Eth1Info;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Block parent hash */
  parentRoot: Scalars['String']['output'];
  /** Block proposer */
  proposer?: Maybe<BitqueryEthereum2ValidatorInfo>;
  /** Signature */
  signature: Scalars['String']['output'];
  /** Block state root hash */
  stateRoot: Scalars['String']['output'];
  /** Validator */
  validator: BitqueryEthereum2ValidatorInfo;
  voluntaryExitEpoch: Scalars['Int']['output'];
  /** Voluntary Exit Index (0 based ) in block */
  voluntaryExitIndex: Scalars['Int']['output'];
};


/** Voluntary Exit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2VoluntaryExitAnyArgs = {
  of: BitqueryEthereum2VoluntaryExitsMeasureable;
};


/** Voluntary Exit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2VoluntaryExitBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Voluntary Exit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2VoluntaryExitBlockRootArgs = {
  blockRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Voluntary Exit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2VoluntaryExitCountArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryEthereum2VoluntaryExitsUniq>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  voluntaryExitEpoch?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Voluntary Exit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2VoluntaryExitCountBigIntArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryEthereum2VoluntaryExitsUniq>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  voluntaryExitEpoch?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Voluntary Exit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2VoluntaryExitExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Voluntary Exit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2VoluntaryExitMaximumArgs = {
  get?: InputMaybe<BitqueryEthereum2VoluntaryExitsMeasureable>;
  of: BitqueryEthereum2VoluntaryExitsMeasureable;
};


/** Voluntary Exit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2VoluntaryExitMinimumArgs = {
  get?: InputMaybe<BitqueryEthereum2VoluntaryExitsMeasureable>;
  of: BitqueryEthereum2VoluntaryExitsMeasureable;
};


/** Voluntary Exit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2VoluntaryExitProposerArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
};

export enum BitqueryEthereum2VoluntaryExitsMeasureable {
  /** Block */
  Block = 'block',
  /** Block Proposer */
  BlockProposer = 'block_proposer',
  /** Block hash */
  BlockRootHash = 'block_root_hash',
  /** Date */
  Date = 'date',
  /** Time */
  Time = 'time',
  /** Validator index */
  Validator = 'validator'
}

export enum BitqueryEthereum2VoluntaryExitsUniq {
  /** Unique block proposers */
  BlockProposers = 'block_proposers',
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates',
  /** Unique validators */
  Validators = 'validators'
}

/** Address that have been active in transfers */
export type BitqueryEthereumActiveAddress = {
  __typename?: 'BitqueryEthereumActiveAddress';
  /** Transfer address */
  address?: Maybe<BitqueryEthereumAddressInfo>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
};


/** Address that have been active in transfers */
export type BitqueryEthereumActiveAddressCountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq: BitqueryActiveAddress;
};


/** Address that have been active in transfers */
export type BitqueryEthereumActiveAddressCountBigIntArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq: BitqueryActiveAddress;
};

/** Address detailed information for Ethereum network */
export type BitqueryEthereumAddressInfo = {
  __typename?: 'BitqueryEthereumAddressInfo';
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<BitqueryEthereumSmartContractInfo>;
};

/** Blockchain address */
export type BitqueryEthereumAddressInfoWithBalance = {
  __typename?: 'BitqueryEthereumAddressInfoWithBalance';
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** DEPRECATED Current address balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** DEPRECATED Balances by currencies for the address */
  balances?: Maybe<Array<BitqueryEthereumBalance>>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<BitqueryEthereumSmartContractInfoWithAttributes>;
};


/** Blockchain address */
export type BitqueryEthereumAddressInfoWithBalanceBalanceArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Blockchain address */
export type BitqueryEthereumAddressInfoWithBalanceBalancesArgs = {
  currency?: InputMaybe<BitqueryEthereumCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelectorRange>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

/**
 * Address should start from 0x and contain hex digits.
 *   If digits are case sensitive, address is checked against checksum according to EIP-55.
 */
export type BitqueryEthereumAddressSelector = {
  /** In the list of Addresses */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Equal to Address */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Not Equal to Address */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Not in the list of Addresses */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/**
 * Address should start from 0x and contain hex digits.
 *   If digits are case sensitive, address is checked against checksum according to EIP-55.
 */
export type BitqueryEthereumAddressSelectorIn = {
  /** In the list of Addresses */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Equal to Address */
  is?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Counts and aggregates for the address, transfer count,
 *                   amount, number of distinct currencies,
 *                   times of the first and the last transactions
 */
export type BitqueryEthereumAddressStat = {
  __typename?: 'BitqueryEthereumAddressStat';
  /** Address */
  address?: Maybe<BitqueryAddress>;
  /** Balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** Call Tx Count */
  callTxCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Called Tx Count */
  calledTxCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Days with received */
  daysWithReceived?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Days with sent */
  daysWithSent?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Days with transactions */
  daysWithTransactions?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Days with transfers */
  daysWithTransfers?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Amount of paid fee */
  feeAmount?: Maybe<Scalars['Float']['output']>;
  /** First transfer at */
  firstTransferAt?: Maybe<BitqueryDateTime>;
  /** First tx at */
  firstTxAt?: Maybe<BitqueryDateTime>;
  /** Last transfer at */
  lastTransferAt?: Maybe<BitqueryDateTime>;
  /** Last tx at */
  lastTxAt?: Maybe<BitqueryDateTime>;
  /** Other Tx Count */
  otherTxCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Receive Amount */
  receiveAmount?: Maybe<Scalars['Float']['output']>;
  /** Receive from Count */
  receiveFromCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Receive from currencies */
  receiveFromCurrencies?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Receive tx Count */
  receiveTxCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Send Amount */
  sendAmount?: Maybe<Scalars['Float']['output']>;
  /** Send to count */
  sendToCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Send to currencies */
  sendToCurrencies?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Send tx count */
  sendTxCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
};

/** AddressStats */
export type BitqueryEthereumAddressStats = {
  __typename?: 'BitqueryEthereumAddressStats';
  /** Address With Statistics */
  address?: Maybe<BitqueryEthereumAddressStat>;
};

export type BitqueryEthereumArgumentFilter = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};

/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArguments = {
  __typename?: 'BitqueryEthereumArguments';
  any?: Maybe<Scalars['String']['output']>;
  /** Method or event argument */
  argument?: Maybe<BitqueryArgumentName>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callDepth?: Maybe<Scalars['String']['output']>;
  /** Caller of the method invocation ( tx sender or another smart contract ) */
  caller?: Maybe<BitqueryEthereumAddressInfo>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']['output']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** External call executed explicitly by tx sender. Internal calls executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']['output']>;
  /** Sequential index of value in array ( multi-dimensional) */
  index: Scalars['String']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  number?: Maybe<Scalars['Float']['output']>;
  /** @deprecated DEPRECATED! Please use ethereum { references } */
  reference?: Maybe<BitqueryEthereumAddressInfo>;
  /** Smart contract being called */
  smartContract?: Maybe<BitqueryEthereumSmartContract>;
  /** Contract method or event */
  smartContractSignature?: Maybe<BitquerySignature>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction where call happened */
  transaction?: Maybe<BitqueryEthereumTransactionInfo>;
  /** The Value of method or event argument */
  value?: Maybe<BitqueryArgumentValue>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArgumentsAnyArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  as?: InputMaybe<BitqueryEthereumArgumentsConvertable>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  of: BitqueryEthereumArgumentsMeasureable;
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArgumentsArgumentArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Scalars['String']['input']>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArgumentsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArgumentsCallerArgs = {
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArgumentsCountArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitquerySmartContractArgumentsUniq>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArgumentsCountBigIntArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitquerySmartContractArgumentsUniq>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArgumentsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArgumentsExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArgumentsMaximumArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  as?: InputMaybe<BitqueryEthereumArgumentsConvertable>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  get?: InputMaybe<BitqueryEthereumArgumentsMeasureable>;
  height?: InputMaybe<BitqueryBlockSelector>;
  of: BitqueryEthereumArgumentsMeasureable;
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArgumentsMinimumArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  as?: InputMaybe<BitqueryEthereumArgumentsConvertable>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  get?: InputMaybe<BitqueryEthereumArgumentsMeasureable>;
  height?: InputMaybe<BitqueryBlockSelector>;
  of: BitqueryEthereumArgumentsMeasureable;
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArgumentsNumberArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArgumentsReferenceArgs = {
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArgumentsSmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArgumentsSmartContractSignatureArgs = {
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArgumentsSuccessArgs = {
  success?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArgumentsTransactionArgs = {
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArgumentsValueArgs = {
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};

export enum BitqueryEthereumArgumentsConvertable {
  /** Token name */
  TokenName = 'token_name',
  /** Token symbol */
  TokenSymbol = 'token_symbol'
}

export enum BitqueryEthereumArgumentsMeasureable {
  /** Argument */
  Argument = 'argument',
  /** Argument index */
  ArgumentIndex = 'argument_index',
  /** Argument type */
  ArgumentType = 'argument_type',
  /** Argument value */
  ArgumentValue = 'argument_value',
  /** Block */
  Block = 'block',
  /** Call depth */
  CallDepth = 'call_depth',
  /** Caller */
  Caller = 'caller',
  /** Date */
  Date = 'date',
  /** Smart Contract Method Signature */
  Signature = 'signature',
  /** Smart Contract Method Signature Hash */
  SignatureHash = 'signature_hash',
  /** Smart Contract Method Name */
  SignatureName = 'signature_name',
  /** Smart Contract Method Signature */
  SignatureType = 'signature_type',
  /** Smart Contract */
  SmartContract = 'smart_contract',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

/** Balance in a currency */
export type BitqueryEthereumBalance = {
  __typename?: 'BitqueryEthereumBalance';
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** History of balance changes by currencies for the address */
  history?: Maybe<Array<BitqueryEthereumBalanceChange>>;
  value?: Maybe<Scalars['Float']['output']>;
};


/** Balance in a currency */
export type BitqueryEthereumBalanceValueArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};

/** Change of balance in a currency */
export type BitqueryEthereumBalanceChange = {
  __typename?: 'BitqueryEthereumBalanceChange';
  /** Block number (height) in blockchain */
  block: Scalars['Int']['output'];
  /** Block timestamp */
  timestamp?: Maybe<Scalars['BitqueryISO8601DateTime']['output']>;
  /** Transfer amount ( positive inbound, negative outbound) */
  transferAmount?: Maybe<Scalars['Float']['output']>;
  value?: Maybe<Scalars['Float']['output']>;
};

export type BitqueryEthereumBlockFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};

/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocks = {
  __typename?: 'BitqueryEthereumBlocks';
  any?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  difficulty?: Maybe<Scalars['Float']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  gasLimit?: Maybe<Scalars['Float']['output']>;
  gasUsed?: Maybe<Scalars['Float']['output']>;
  /** Block hash */
  hash: Scalars['String']['output'];
  /** Block number (height) in blockchain */
  height: Scalars['Int']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  /** Block miner */
  miner?: Maybe<BitqueryEthereumAddressInfo>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Block nonce */
  nonce: Scalars['Int']['output'];
  /** Parent block hash */
  parentHash: Scalars['String']['output'];
  reward?: Maybe<Scalars['Float']['output']>;
  /** Currency of reward */
  rewardCurrency?: Maybe<BitqueryCurrency>;
  size?: Maybe<Scalars['Int']['output']>;
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  totalDifficulty?: Maybe<Scalars['Float']['output']>;
  transactionCount?: Maybe<Scalars['Int']['output']>;
  transactionCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  uncleCount?: Maybe<Scalars['Int']['output']>;
  uncleCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksAnyArgs = {
  of: BitqueryEthereumBlocksMeasureable;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uniq?: InputMaybe<BitqueryEthereumBlocksUniq>;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uniq?: InputMaybe<BitqueryEthereumBlocksUniq>;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksDifficultyArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksGasLimitArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksGasUsedArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksHashArgs = {
  blockHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksHeightArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksMaximumArgs = {
  get?: InputMaybe<BitqueryEthereumBlocksMeasureable>;
  of: BitqueryEthereumBlocksMeasureable;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksMinerArgs = {
  miner?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksMinimumArgs = {
  get?: InputMaybe<BitqueryEthereumBlocksMeasureable>;
  of: BitqueryEthereumBlocksMeasureable;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksRewardArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  miner?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksSizeArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksTimestampArgs = {
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksTotalDifficultyArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksTransactionCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksTransactionCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksUncleCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksUncleCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};

export enum BitqueryEthereumBlocksMeasureable {
  /** Block */
  Block = 'block',
  /** Block hash */
  BlockHash = 'block_hash',
  /** Block Reward */
  BlockReward = 'block_reward',
  /** Date */
  Date = 'date',
  /** Block Miner */
  Miner = 'miner',
  /** Time */
  Time = 'time'
}

export enum BitqueryEthereumBlocksUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique miner count */
  Miners = 'miners'
}

export enum BitqueryEthereumCallsMeasureable {
  /** Block */
  Block = 'block',
  /** Call depth */
  CallDepth = 'call_depth',
  /** Caller */
  Caller = 'caller',
  /** Date */
  Date = 'date',
  /** Smart Contract Method Signature */
  Signature = 'signature',
  /** Smart Contract Method Signature Hash */
  SignatureHash = 'signature_hash',
  /** Smart Contract Method Name */
  SignatureName = 'signature_name',
  /** Smart Contract */
  SmartContract = 'smart_contract',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

/** Coinpath */
export type BitqueryEthereumCoinpath = {
  __typename?: 'BitqueryEthereumCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryEthereumCoinpathAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryEthereumCoinpathAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<BitqueryTransactionHashValueTime>;
  /** Attributes of transaction included in Coinpath result */
  transactions?: Maybe<Array<BitqueryCoinpathEntry>>;
};


/** Coinpath */
export type BitqueryEthereumCoinpathAmountArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Coinpath */
export type BitqueryEthereumCoinpathAnyArgs = {
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryEthereumCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryEthereumCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};

/** Address detailed information for Ethereum network */
export type BitqueryEthereumCoinpathAddress = {
  __typename?: 'BitqueryEthereumCoinpathAddress';
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  amountIn?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  amountOut?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  balance?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Smart Contract if exists on the address */
  firstTxAt?: Maybe<BitqueryDateTime>;
  /** Smart Contract if exists on the address */
  lastTxAt?: Maybe<BitqueryDateTime>;
  receiversCount?: Maybe<Scalars['Int']['output']>;
  sendersCount?: Maybe<Scalars['Int']['output']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<BitqueryEthereumSmartContractInfo>;
  /** Address type */
  type?: Maybe<Scalars['String']['output']>;
};

/**
 * Currency selector in Ethereum blockchain.
 *   Currencies supported are native ( ETH / ETC ), ERC20, ERC721 tokens.
 *   You can specify currency symbol or smart contract address. Symbols ETH/ETC are reserved for native currencies in Ethereum mainnet and classic.
 *   Ethereum Smart contract address should start from 0x and contain 40 hex digits.
 *   If digits are case sensitive, address is checked against checksum according to EIP-55.
 */
export type BitqueryEthereumCurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Currency not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Ethereum DEX attributes */
export type BitqueryEthereumDex = {
  __typename?: 'BitqueryEthereumDex';
  /** Address for DEX exchange identification */
  address: BitqueryAddress;
  /** Full name ( name for known, Protocol for unknown ) */
  fullName: Scalars['String']['output'];
  /** Full name ( name for known, Protocol / address for unknown ) */
  fullNameWithId: Scalars['String']['output'];
  /** Name for known exchanges */
  name?: Maybe<Scalars['String']['output']>;
};

export type BitqueryEthereumDexTradeFilter = {
  baseCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  makerSmartContractType?: InputMaybe<Array<BitquerySmartContractTypeSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  takerSmartContractType?: InputMaybe<Array<BitquerySmartContractTypeSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};

/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTrades = {
  __typename?: 'BitqueryEthereumDexTrades';
  /** Trader (maker or taker) */
  address?: Maybe<BitqueryAddress>;
  any?: Maybe<Scalars['String']['output']>;
  baseAmount?: Maybe<Scalars['Float']['output']>;
  /** Base currency */
  baseCurrency?: Maybe<BitqueryCurrency>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlockExtended>;
  buyAmount?: Maybe<Scalars['Float']['output']>;
  /** Maker buys this currency */
  buyCurrency?: Maybe<BitqueryCurrency>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Identification of admin / manager / factory of smart contract, executing trades */
  exchange?: Maybe<BitqueryEthereumDex>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  gas?: Maybe<Scalars['Float']['output']>;
  /** Gas price in Gwei */
  gasPrice: Scalars['Float']['output'];
  gasValue?: Maybe<Scalars['Float']['output']>;
  /** Trade 'maker' side */
  maker?: Maybe<BitqueryAddress>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  price?: Maybe<Scalars['Float']['output']>;
  /** Protocol name of the smart contract */
  protocol?: Maybe<Scalars['String']['output']>;
  /** For this metric works you need use "quoteCurrency{ tokenId }" dimension */
  quoteAmount?: Maybe<Scalars['Float']['output']>;
  /** Quote currency */
  quoteCurrency?: Maybe<BitqueryCurrency>;
  /** For this metric works you need use "quoteCurrency{ tokenId }" dimension */
  quotePrice?: Maybe<Scalars['Float']['output']>;
  sellAmount?: Maybe<Scalars['Float']['output']>;
  /** Maker sells this currency */
  sellCurrency?: Maybe<BitqueryCurrency>;
  /** Side of trade ( SELL / BUY ) */
  side?: Maybe<BitqueryTradeSide>;
  /** Smart contract being called */
  smartContract?: Maybe<BitqueryEthereumSmartContract>;
  /** Trade 'taker' side */
  taker?: Maybe<BitqueryAddress>;
  /** Time interval */
  timeInterval?: Maybe<BitqueryTimeInterval>;
  tradeAmount?: Maybe<Scalars['Float']['output']>;
  /** Index of trade in transaction, used to separate trades in transaction */
  tradeIndex?: Maybe<Scalars['String']['output']>;
  /** Transaction of DexTrade */
  transaction?: Maybe<BitqueryEthereumTransactionInfoExtended>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesAddressArgs = {
  makerOrTaker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesAnyArgs = {
  of: BitqueryEthereumDexTradesMeasureable;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesBaseAmountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesBaseCurrencyArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesBuyAmountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesBuyCurrencyArgs = {
  buyCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesCountArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  makerSmartContractType?: InputMaybe<Array<BitquerySmartContractTypeSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  takerSmartContractType?: InputMaybe<Array<BitquerySmartContractTypeSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  uniq?: InputMaybe<BitqueryEthereumDexTradesUniq>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesCountBigIntArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  makerSmartContractType?: InputMaybe<Array<BitquerySmartContractTypeSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  takerSmartContractType?: InputMaybe<Array<BitquerySmartContractTypeSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  uniq?: InputMaybe<BitqueryEthereumDexTradesUniq>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesExchangeArgs = {
  exchangeAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesGasArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  makerSmartContractType?: InputMaybe<Array<BitquerySmartContractTypeSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  takerSmartContractType?: InputMaybe<Array<BitquerySmartContractTypeSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesGasPriceArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  makerSmartContractType?: InputMaybe<Array<BitquerySmartContractTypeSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  takerSmartContractType?: InputMaybe<Array<BitquerySmartContractTypeSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesGasValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesMakerArgs = {
  maker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesMaximumArgs = {
  get?: InputMaybe<BitqueryEthereumDexTradesMeasureable>;
  of: BitqueryEthereumDexTradesMeasureable;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesMinimumArgs = {
  get?: InputMaybe<BitqueryEthereumDexTradesMeasureable>;
  of: BitqueryEthereumDexTradesMeasureable;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesPriceArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  calculate?: InputMaybe<BitqueryPriceAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  makerSmartContractType?: InputMaybe<Array<BitquerySmartContractTypeSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  takerSmartContractType?: InputMaybe<Array<BitquerySmartContractTypeSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesProtocolArgs = {
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesQuoteAmountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesQuoteCurrencyArgs = {
  quoteCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesQuotePriceArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  calculate?: InputMaybe<BitqueryPriceAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  makerSmartContractType?: InputMaybe<Array<BitquerySmartContractTypeSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  takerSmartContractType?: InputMaybe<Array<BitquerySmartContractTypeSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesSellAmountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesSellCurrencyArgs = {
  sellCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesSmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesTakerArgs = {
  taker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesTradeAmountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  in: BitqueryBaseCurrencyEnum;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesTradeIndexArgs = {
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesTransactionArgs = {
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};

export enum BitqueryEthereumDexTradesMeasureable {
  /** Block */
  Block = 'block',
  /** Buy Amount */
  BuyAmount = 'buy_amount',
  /** Buy Token address */
  BuyCurrencyAddress = 'buy_currency_address',
  /** Buy Currency symbol */
  BuyCurrencySymbol = 'buy_currency_symbol',
  /** Date */
  Date = 'date',
  /** Maker */
  Maker = 'maker',
  /** Price */
  Price = 'price',
  /** Quote Price */
  QuotePrice = 'quote_price',
  /** Sell Amount */
  SellAmount = 'sell_amount',
  /** Sell Token address */
  SellCurrencyAddress = 'sell_currency_address',
  /** Sell Currency symbol */
  SellCurrencySymbol = 'sell_currency_symbol',
  /** Taker */
  Taker = 'taker',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

export enum BitqueryEthereumDexTradesUniq {
  /** Unique makers & takers count */
  Address = 'address',
  /** Base currencies count */
  BaseCurrency = 'base_currency',
  /** Unique blocks */
  Blocks = 'blocks',
  /** Buy currencies count */
  BuyCurrency = 'buy_currency',
  /** Unique date count */
  Dates = 'dates',
  /** Unique makers count */
  Makers = 'makers',
  /** Unique protocols count */
  Protocols = 'protocols',
  /** Quote currencies count */
  QuoteCurrency = 'quote_currency',
  /** Sell currencies count */
  SellCurrency = 'sell_currency',
  /** Unique TX senders count */
  Senders = 'senders',
  /** Unique smart contract count */
  SmartContracts = 'smart_contracts',
  /** Unique makers count */
  Takers = 'takers',
  /** Unique transactions count */
  Txs = 'txs'
}

export enum BitqueryEthereumEventsMeasureable {
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Smart Contract Event Signature */
  Signature = 'signature',
  /** Smart Contract Event Signature Hash */
  SignatureHash = 'signature_hash',
  /** Smart Contract Event Name */
  SignatureName = 'signature_name',
  /** Smart Contract */
  SmartContract = 'smart_contract',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

export enum BitqueryEthereumNetwork {
  /** Avalanche C-chain */
  Avalanche = 'avalanche',
  /** Binance Smart Chain Mainnet */
  Bsc = 'bsc',
  /** Binance Smart Chain Testnet */
  BscTestnet = 'bsc_testnet',
  /** Celo Alfajores Testnet */
  CeloAlfajores = 'celo_alfajores',
  /** Celo Baklava Testnet */
  CeloBaklava = 'celo_baklava',
  /** Celo Mainnet */
  CeloMainnet = 'celo_mainnet',
  /** DEPRECATED. Use celo_mainnet */
  CeloRc1 = 'celo_rc1',
  /** Cronos Mainnet */
  Cronos = 'cronos',
  /** Ethereum Classic */
  Ethclassic = 'ethclassic',
  /** Ethereum Classic ( no reorg from block 10904146) */
  EthclassicReorg = 'ethclassic_reorg',
  /** Ethereum Mainnet */
  Ethereum = 'ethereum',
  /** Ethereum PoW */
  Ethpow = 'ethpow',
  /** Fantom Mainnet */
  Fantom = 'fantom',
  /** Goerli Ethereum Testnet */
  Goerli = 'goerli',
  /** Klaytn Mainnet */
  Klaytn = 'klaytn',
  /** Matic (Polygon) Mainnet */
  Matic = 'matic',
  /** Moonbeam Mainnet */
  Moonbeam = 'moonbeam',
  /** Velas Mainnet */
  Velas = 'velas',
  /** Velas Testnet */
  VelasTestnet = 'velas_testnet'
}

export type BitqueryEthereumReferencesFilter = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};

/** Address value of method or event argument */
export type BitqueryEthereumReferencess = {
  __typename?: 'BitqueryEthereumReferencess';
  any?: Maybe<Scalars['String']['output']>;
  /** Method or event argument */
  argument?: Maybe<BitqueryArgumentName>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callDepth?: Maybe<Scalars['String']['output']>;
  /** Caller of the method invocation ( tx sender or another smart contract ) */
  caller?: Maybe<BitqueryEthereumAddressInfo>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']['output']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** External call executed explicitly by tx sender. Internal calls executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']['output']>;
  /** Sequential index of value in array ( multi-dimensional) */
  index: Scalars['String']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  number?: Maybe<Scalars['Float']['output']>;
  /** Address value of method or event argument */
  reference?: Maybe<BitqueryEthereumAddressInfo>;
  /** Smart contract being called */
  smartContract?: Maybe<BitqueryEthereumSmartContract>;
  /** Contract method or event */
  smartContractSignature?: Maybe<BitquerySignature>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction where call happened */
  transaction?: Maybe<BitqueryEthereumTransactionInfo>;
};


/** Address value of method or event argument */
export type BitqueryEthereumReferencessAnyArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  as?: InputMaybe<BitqueryEthereumReferencessConvertable>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  of: BitqueryEthereumReferencessMeasureable;
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type BitqueryEthereumReferencessArgumentArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Scalars['String']['input']>;
};


/** Address value of method or event argument */
export type BitqueryEthereumReferencessBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Address value of method or event argument */
export type BitqueryEthereumReferencessCallerArgs = {
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Address value of method or event argument */
export type BitqueryEthereumReferencessCountArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitquerySmartContractArgumentsUniq>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type BitqueryEthereumReferencessCountBigIntArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitquerySmartContractArgumentsUniq>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type BitqueryEthereumReferencessExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Address value of method or event argument */
export type BitqueryEthereumReferencessExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Address value of method or event argument */
export type BitqueryEthereumReferencessMaximumArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  as?: InputMaybe<BitqueryEthereumReferencessConvertable>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  get?: InputMaybe<BitqueryEthereumReferencessMeasureable>;
  height?: InputMaybe<BitqueryBlockSelector>;
  of: BitqueryEthereumReferencessMeasureable;
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type BitqueryEthereumReferencessMinimumArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  as?: InputMaybe<BitqueryEthereumReferencessConvertable>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  get?: InputMaybe<BitqueryEthereumReferencessMeasureable>;
  height?: InputMaybe<BitqueryBlockSelector>;
  of: BitqueryEthereumReferencessMeasureable;
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type BitqueryEthereumReferencessNumberArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type BitqueryEthereumReferencessReferenceArgs = {
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Address value of method or event argument */
export type BitqueryEthereumReferencessSmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Address value of method or event argument */
export type BitqueryEthereumReferencessSmartContractSignatureArgs = {
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
};


/** Address value of method or event argument */
export type BitqueryEthereumReferencessSuccessArgs = {
  success?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};


/** Address value of method or event argument */
export type BitqueryEthereumReferencessTransactionArgs = {
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};

export enum BitqueryEthereumReferencessConvertable {
  /** Token name */
  TokenName = 'token_name',
  /** Token symbol */
  TokenSymbol = 'token_symbol'
}

export enum BitqueryEthereumReferencessMeasureable {
  /** Argument index */
  ArgumentIndex = 'argument_index',
  /** Argument type */
  ArgumentType = 'argument_type',
  /** Argument value */
  ArgumentValue = 'argument_value',
  /** Block */
  Block = 'block',
  /** Call depth */
  CallDepth = 'call_depth',
  /** Caller */
  Caller = 'caller',
  /** Date */
  Date = 'date',
  /** Smart Contract Method Signature */
  Signature = 'signature',
  /** Smart Contract Method Signature Hash */
  SignatureHash = 'signature_hash',
  /** Smart Contract Method Name */
  SignatureName = 'signature_name',
  /** Smart Contract Method Signature */
  SignatureType = 'signature_type',
  /** Smart Contract */
  SmartContract = 'smart_contract',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

/** Ethereum smart contract */
export type BitqueryEthereumSmartContract = {
  __typename?: 'BitqueryEthereumSmartContract';
  /** Smart Contract Address */
  address: BitqueryAddress;
  /** Smart Contract Type */
  contractType?: Maybe<BitquerySmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<BitqueryScCurrency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']['output']>;
};

export type BitqueryEthereumSmartContractCallFilter = {
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  smartContractType?: InputMaybe<BitquerySmartContractTypeSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};

/** Smart Contract Calls */
export type BitqueryEthereumSmartContractCalls = {
  __typename?: 'BitqueryEthereumSmartContractCalls';
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Call arguments */
  arguments?: Maybe<Array<BitqueryArgumentNameValue>>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callDepth?: Maybe<Scalars['String']['output']>;
  /** Caller of the method invocation ( tx sender or another smart contract ) */
  caller?: Maybe<BitqueryEthereumAddressInfo>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']['output']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** External call executed explicitly by tx sender. Internal calls executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']['output']>;
  /** Gas used for transaction in external call, or by methd in internal call */
  gasValue?: Maybe<Scalars['Float']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Smart contract being called */
  smartContract?: Maybe<BitqueryEthereumSmartContract>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<BitqueryMethod>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction where call happened */
  transaction?: Maybe<BitqueryEthereumTransactionInfo>;
};


/** Smart Contract Calls */
export type BitqueryEthereumSmartContractCallsAmountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  smartContractType?: InputMaybe<BitquerySmartContractTypeSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Smart Contract Calls */
export type BitqueryEthereumSmartContractCallsAnyArgs = {
  of: BitqueryEthereumCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryEthereumSmartContractCallsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Smart Contract Calls */
export type BitqueryEthereumSmartContractCallsCallerArgs = {
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Smart Contract Calls */
export type BitqueryEthereumSmartContractCallsCountArgs = {
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  smartContractType?: InputMaybe<BitquerySmartContractTypeSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type BitqueryEthereumSmartContractCallsCountBigIntArgs = {
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  smartContractType?: InputMaybe<BitquerySmartContractTypeSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type BitqueryEthereumSmartContractCallsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Smart Contract Calls */
export type BitqueryEthereumSmartContractCallsExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Smart Contract Calls */
export type BitqueryEthereumSmartContractCallsGasValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  smartContractType?: InputMaybe<BitquerySmartContractTypeSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Smart Contract Calls */
export type BitqueryEthereumSmartContractCallsMaximumArgs = {
  get?: InputMaybe<BitqueryEthereumCallsMeasureable>;
  of: BitqueryEthereumCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryEthereumSmartContractCallsMinimumArgs = {
  get?: InputMaybe<BitqueryEthereumCallsMeasureable>;
  of: BitqueryEthereumCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryEthereumSmartContractCallsSmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Smart Contract Calls */
export type BitqueryEthereumSmartContractCallsSmartContractMethodArgs = {
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
};


/** Smart Contract Calls */
export type BitqueryEthereumSmartContractCallsSuccessArgs = {
  success?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};


/** Smart Contract Calls */
export type BitqueryEthereumSmartContractCallsTransactionArgs = {
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};

/** Smart Contract Events */
export type BitqueryEthereumSmartContractEvent = {
  __typename?: 'BitqueryEthereumSmartContractEvent';
  any?: Maybe<Scalars['String']['output']>;
  /** Event arguments */
  arguments?: Maybe<Array<BitqueryArgumentNameValue>>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']['output']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Smart contract being called */
  smartContract?: Maybe<BitqueryEthereumSmartContract>;
  /** Contract event logged */
  smartContractEvent?: Maybe<BitqueryEvent>;
  /** Transaction where event happened */
  transaction?: Maybe<BitqueryEthereumTransactionInfo>;
};


/** Smart Contract Events */
export type BitqueryEthereumSmartContractEventAnyArgs = {
  of: BitqueryEthereumEventsMeasureable;
};


/** Smart Contract Events */
export type BitqueryEthereumSmartContractEventBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Smart Contract Events */
export type BitqueryEthereumSmartContractEventCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractType?: InputMaybe<BitquerySmartContractTypeSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Smart Contract Events */
export type BitqueryEthereumSmartContractEventCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractType?: InputMaybe<BitquerySmartContractTypeSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Smart Contract Events */
export type BitqueryEthereumSmartContractEventExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Smart Contract Events */
export type BitqueryEthereumSmartContractEventMaximumArgs = {
  get?: InputMaybe<BitqueryEthereumEventsMeasureable>;
  of: BitqueryEthereumEventsMeasureable;
};


/** Smart Contract Events */
export type BitqueryEthereumSmartContractEventMinimumArgs = {
  get?: InputMaybe<BitqueryEthereumEventsMeasureable>;
  of: BitqueryEthereumEventsMeasureable;
};


/** Smart Contract Events */
export type BitqueryEthereumSmartContractEventSmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Smart Contract Events */
export type BitqueryEthereumSmartContractEventSmartContractEventArgs = {
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
};


/** Smart Contract Events */
export type BitqueryEthereumSmartContractEventTransactionArgs = {
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};

export type BitqueryEthereumSmartContractEventFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractType?: InputMaybe<BitquerySmartContractTypeSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};

/** Blockchain smart contract */
export type BitqueryEthereumSmartContractInfo = {
  __typename?: 'BitqueryEthereumSmartContractInfo';
  /** Smart Contract Type */
  contractType?: Maybe<BitquerySmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<BitqueryScCurrency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']['output']>;
};

/** Blockchain smart contract */
export type BitqueryEthereumSmartContractInfoWithAttributes = {
  __typename?: 'BitqueryEthereumSmartContractInfoWithAttributes';
  /** Attributes from readonly methods */
  attributes?: Maybe<Array<BitquerySmartContractReadonlyAttribute>>;
  /** Smart Contract Type */
  contractType?: Maybe<BitquerySmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<BitqueryScCurrency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']['output']>;
};

export type BitqueryEthereumTransactionFilter = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  feePayer?: InputMaybe<Array<BitqueryStringSelector>>;
  feeRatio?: InputMaybe<BitqueryTxIndexSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  gasValue?: InputMaybe<Array<BitqueryAmountSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCreates?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txType?: InputMaybe<Array<BitqueryStringSelector>>;
};

/** Blockchain transaction info */
export type BitqueryEthereumTransactionInfo = {
  __typename?: 'BitqueryEthereumTransactionInfo';
  /** Gas consumed */
  gas: Scalars['Int']['output'];
  /** Gas price in Gwei */
  gasPrice: Scalars['Float']['output'];
  /** Gas value cost */
  gasValue: Scalars['Float']['output'];
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction from address */
  txFrom: BitqueryEthereumAddressInfo;
};

/** Blockchain Transaction Extended info */
export type BitqueryEthereumTransactionInfoExtended = {
  __typename?: 'BitqueryEthereumTransactionInfoExtended';
  /** Gas consumed */
  gas: Scalars['Int']['output'];
  /** Gas price in Gwei */
  gasPrice: Scalars['Float']['output'];
  /** Gas value cost */
  gasValue: Scalars['Float']['output'];
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction index in block, 0 based */
  index?: Maybe<Scalars['Int']['output']>;
  /** Transaction nonce */
  nonce?: Maybe<Scalars['Int']['output']>;
  /** Transaction receiver */
  to?: Maybe<BitqueryEthereumAddressInfo>;
  /** Transaction from address */
  txFrom: BitqueryEthereumAddressInfo;
};

/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactions = {
  __typename?: 'BitqueryEthereumTransactions';
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BitqueryBlock>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Created smart contract */
  creates?: Maybe<BitqueryEthereumAddressInfo>;
  /** Currency of amount */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Error message if any */
  error?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Fee payer */
  feePayer?: Maybe<Scalars['String']['output']>;
  /** Fee ratio */
  feeRatio?: Maybe<Scalars['Int']['output']>;
  gas?: Maybe<Scalars['Float']['output']>;
  /** Currency of gas */
  gasCurrency?: Maybe<BitqueryCurrency>;
  /** Gas price in Gwei */
  gasPrice: Scalars['Float']['output'];
  gasValue?: Maybe<Scalars['Float']['output']>;
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction index in block, 0 based */
  index?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Transaction nonce */
  nonce?: Maybe<Scalars['Int']['output']>;
  /** Transaction sender */
  sender?: Maybe<BitqueryEthereumAddressInfo>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction receiver */
  to?: Maybe<BitqueryEthereumAddressInfo>;
  /** Transaction type */
  txType?: Maybe<Scalars['String']['output']>;
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsAmountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feePayer?: InputMaybe<Array<BitqueryStringSelector>>;
  feeRatio?: InputMaybe<BitqueryTxIndexSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  gasValue?: InputMaybe<Array<BitqueryAmountSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCreates?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txType?: InputMaybe<Array<BitqueryStringSelector>>;
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsAnyArgs = {
  of: BitqueryEthereumTransactionsMeasureable;
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsCountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  feePayer?: InputMaybe<Array<BitqueryStringSelector>>;
  feeRatio?: InputMaybe<BitqueryTxIndexSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  gasValue?: InputMaybe<Array<BitqueryAmountSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCreates?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txType?: InputMaybe<Array<BitqueryStringSelector>>;
  uniq?: InputMaybe<BitqueryEthereumTransactionsUniq>;
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsCountBigIntArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  feePayer?: InputMaybe<Array<BitqueryStringSelector>>;
  feeRatio?: InputMaybe<BitqueryTxIndexSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  gasValue?: InputMaybe<Array<BitqueryAmountSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCreates?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txType?: InputMaybe<Array<BitqueryStringSelector>>;
  uniq?: InputMaybe<BitqueryEthereumTransactionsUniq>;
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsCreatesArgs = {
  txCreates?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsGasArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feePayer?: InputMaybe<Array<BitqueryStringSelector>>;
  feeRatio?: InputMaybe<BitqueryTxIndexSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  gasValue?: InputMaybe<Array<BitqueryAmountSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCreates?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txType?: InputMaybe<Array<BitqueryStringSelector>>;
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsGasCurrencyArgs = {
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsGasPriceArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feePayer?: InputMaybe<Array<BitqueryStringSelector>>;
  feeRatio?: InputMaybe<BitqueryTxIndexSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  gasValue?: InputMaybe<Array<BitqueryAmountSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCreates?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txType?: InputMaybe<Array<BitqueryStringSelector>>;
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsGasValueArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feePayer?: InputMaybe<Array<BitqueryStringSelector>>;
  feeRatio?: InputMaybe<BitqueryTxIndexSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  gasValue?: InputMaybe<Array<BitqueryAmountSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCreates?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txType?: InputMaybe<Array<BitqueryStringSelector>>;
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsHashArgs = {
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsIndexArgs = {
  txIndex?: InputMaybe<Array<BitqueryTxIndexSelector>>;
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsMaximumArgs = {
  get?: InputMaybe<BitqueryEthereumTransactionsMeasureable>;
  of: BitqueryEthereumTransactionsMeasureable;
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsMinimumArgs = {
  get?: InputMaybe<BitqueryEthereumTransactionsMeasureable>;
  of: BitqueryEthereumTransactionsMeasureable;
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsSenderArgs = {
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsToArgs = {
  txTo?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};

export enum BitqueryEthereumTransactionsMeasureable {
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Fee payer */
  FeePayer = 'fee_payer',
  /** Fee ratio */
  FeeRatio = 'fee_ratio',
  /** Gas used */
  Gas = 'gas',
  /** Gas price */
  GasPrice = 'gas_price',
  /** Gas value */
  GasValue = 'gas_value',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Transaction Sender */
  TxSender = 'tx_sender',
  /** Transaction type */
  TxType = 'tx_type'
}

export enum BitqueryEthereumTransactionsUniq {
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates',
  /** Unique fee payers count */
  FeePayers = 'fee_payers',
  /** Unique fee ratios count */
  FeeRatios = 'fee_ratios',
  /** Unique TX receivers count */
  Receivers = 'receivers',
  /** Unique TX senders count */
  Senders = 'senders',
  /** Unique TX types count */
  TxTypes = 'tx_types'
}

export type BitqueryEthereumTransferFilter = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};

/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEthereumTransfers = {
  __typename?: 'BitqueryEthereumTransfers';
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BitqueryBlock>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Entity identifier ( for ERC-721 NFT tokens ) */
  entityId?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']['output']>;
  gasValue?: Maybe<Scalars['Float']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Transfer receiver */
  receiver?: Maybe<BitqueryEthereumAddressInfo>;
  /** Transfer sender */
  sender?: Maybe<BitqueryEthereumAddressInfo>;
  /** Success flag */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction where transfer happened */
  transaction?: Maybe<BitqueryEthereumTransactionInfo>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEthereumTransfersAmountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  receiver?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEthereumTransfersAnyArgs = {
  of: BitqueryEthereumTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEthereumTransfersBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEthereumTransfersCountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryTransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEthereumTransfersCountBigIntArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryTransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEthereumTransfersCurrencyArgs = {
  currency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEthereumTransfersEntityIdArgs = {
  entityId?: InputMaybe<BitqueryEntitySelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEthereumTransfersExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEthereumTransfersExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEthereumTransfersGasValueArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  receiver?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEthereumTransfersMaximumArgs = {
  get?: InputMaybe<BitqueryEthereumTransfersMeasureable>;
  of: BitqueryEthereumTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEthereumTransfersMinimumArgs = {
  get?: InputMaybe<BitqueryEthereumTransfersMeasureable>;
  of: BitqueryEthereumTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEthereumTransfersReceiverArgs = {
  receiver?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEthereumTransfersSenderArgs = {
  sender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEthereumTransfersSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEthereumTransfersTransactionArgs = {
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};

export enum BitqueryEthereumTransfersMeasureable {
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Token address */
  CurrencyAddress = 'currency_address',
  /** Currency symbol */
  CurrencySymbol = 'currency_symbol',
  /** Date */
  Date = 'date',
  /** Entity ID */
  EntityId = 'entity_id',
  /** Receiver */
  Receiver = 'receiver',
  /** Sender */
  Sender = 'sender',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

/** Smart contract event */
export type BitqueryEvent = {
  __typename?: 'BitqueryEvent';
  /** Name */
  name?: Maybe<Scalars['String']['output']>;
  /** Signature */
  signature?: Maybe<Scalars['String']['output']>;
  /** Signature Hash */
  signatureHash: Scalars['String']['output'];
};

/** Smart contract event. In selector you can use the name, signature or hex hash */
export type BitqueryEventSelector = {
  /** Event signature in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Event signature is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Event signature not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Event signature not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export enum BitqueryEventType {
  /** Call Result */
  CallResult = 'call_result',
  /** Transaction */
  Transaction = 'transaction'
}

/** Select by event type */
export type BitqueryEventTypeSelector = {
  /** Eventy type in the list */
  in?: InputMaybe<Array<BitqueryEventType>>;
  /** Eventy type is */
  is?: InputMaybe<BitqueryEventType>;
  /** Eventy type not */
  not?: InputMaybe<BitqueryEventType>;
  /** Eventy type not in the list */
  notIn?: InputMaybe<Array<BitqueryEventType>>;
};

/** Everscale Chain */
export type BitqueryEverscale = {
  __typename?: 'BitqueryEverscale';
  /** Information about address */
  address: Array<BitqueryEverscaleAddressInfo>;
  /** Everscale Arguments */
  arguments?: Maybe<Array<BitqueryEverscaleArgument>>;
  /** Everscale Blocks */
  blocks?: Maybe<Array<BitqueryEverscaleBlock>>;
  /** Everscale Calls */
  calls?: Maybe<Array<BitqueryEverscaleCall>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryEverscaleCoinpath>>;
  /** Everscale Events */
  events?: Maybe<Array<BitqueryEverscaleEvent>>;
  /** Everscale Messages */
  messages?: Maybe<Array<BitqueryEverscaleMessage>>;
  /** Everscale Phases */
  phases?: Maybe<Array<BitqueryEverscalePhase>>;
  /** Everscale Transactions */
  transactions?: Maybe<Array<BitqueryEverscaleTransaction>>;
  /** Everscale Transfers */
  transfers?: Maybe<Array<BitqueryEverscaleTransfer>>;
};


/** Everscale Chain */
export type BitqueryEverscaleAddressArgs = {
  address: Array<BitqueryAddressSelectorIn>;
};


/** Everscale Chain */
export type BitqueryEverscaleArgumentsArgs = {
  any?: InputMaybe<Array<BitqueryEverscaleArgumentFilter>>;
  argumentField?: InputMaybe<BitqueryStringSelector>;
  argumentIndex?: InputMaybe<BitqueryIntegerSelector>;
  argumentType?: InputMaybe<BitqueryEverscaleArgumentTypeSelector>;
  argumentValue?: InputMaybe<BitqueryStringSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};


/** Everscale Chain */
export type BitqueryEverscaleBlocksArgs = {
  afterMerge?: InputMaybe<BitqueryBooleanSelector>;
  afterSplit?: InputMaybe<BitqueryBooleanSelector>;
  any?: InputMaybe<Array<BitqueryEverscaleBlockFilter>>;
  beforeSplit?: InputMaybe<BitqueryBooleanSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  catchainSeqno?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  globalId?: InputMaybe<BitqueryIntegerSelector>;
  logicalTimeEnd?: InputMaybe<BitqueryBigIntegerSelector>;
  logicalTimeStart?: InputMaybe<BitqueryBigIntegerSelector>;
  minimalReferenceMasterchainBlock?: InputMaybe<BitqueryBigIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  softwareCapabilities?: InputMaybe<BitqueryStringSelector>;
  softwareVersion?: InputMaybe<BitqueryIntegerSelector>;
  status?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCount?: InputMaybe<BitqueryIntegerSelector>;
  validatorListHastShort?: InputMaybe<BitqueryIntegerSelector>;
  valueFlowCreated?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowExported?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowFeesCollected?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowFeesImported?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowFromPreviousBlock?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowImported?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowMinted?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowToNextBlock?: InputMaybe<BitqueryBigIntegerSelector>;
  version?: InputMaybe<BitqueryBigIntegerSelector>;
  verticalSeqNo?: InputMaybe<BitqueryBigIntegerSelector>;
  wantMerge?: InputMaybe<BitqueryBooleanSelector>;
  wantSplit?: InputMaybe<BitqueryBooleanSelector>;
};


/** Everscale Chain */
export type BitqueryEverscaleCallsArgs = {
  any?: InputMaybe<Array<BitqueryEverscaleCallFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};


/** Everscale Chain */
export type BitqueryEverscaleCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCoinpathOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Everscale Chain */
export type BitqueryEverscaleEventsArgs = {
  any?: InputMaybe<Array<BitqueryEverscaleEventFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};


/** Everscale Chain */
export type BitqueryEverscaleMessagesArgs = {
  any?: InputMaybe<Array<BitqueryEverscaleMessageFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  messageBoc?: InputMaybe<BitqueryStringSelector>;
  messageBody?: InputMaybe<BitqueryStringSelector>;
  messageBodyHash?: InputMaybe<BitqueryStringSelector>;
  messageBounce?: InputMaybe<BitqueryBooleanSelector>;
  messageBounced?: InputMaybe<BitqueryBooleanSelector>;
  messageCreatedLogicalTime?: InputMaybe<BitqueryBigIntegerSelector>;
  messageData?: InputMaybe<BitqueryStringSelector>;
  messageDataHash?: InputMaybe<BitqueryStringSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageFwdFee?: InputMaybe<BitqueryFloatSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageIhrDisabled?: InputMaybe<BitqueryBooleanSelector>;
  messageIndex?: InputMaybe<BitqueryIntegerSelector>;
  messageIrbFee?: InputMaybe<BitqueryFloatSelector>;
  messageReceiver?: InputMaybe<BitqueryStringSelector>;
  messageSender?: InputMaybe<BitqueryStringSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};


/** Everscale Chain */
export type BitqueryEverscalePhasesArgs = {
  any?: InputMaybe<Array<BitqueryEverscalePhaseFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  phaseData?: InputMaybe<BitqueryStringSelector>;
  phaseFee?: InputMaybe<BitqueryFloatSelector>;
  phaseType?: InputMaybe<BitqueryStringSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};


/** Everscale Chain */
export type BitqueryEverscaleTransactionsArgs = {
  any?: InputMaybe<Array<BitqueryEverscaleTransactionFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  previousTxHash?: InputMaybe<BitqueryStringSelector>;
  previousTxLogicalTime?: InputMaybe<BitqueryBigIntegerSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryBooleanSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txAccountFees?: InputMaybe<BitqueryFloatSelector>;
  txCreditFirst?: InputMaybe<BitqueryBooleanSelector>;
  txDestroyed?: InputMaybe<BitqueryBooleanSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txExtInAndIhrInFees?: InputMaybe<BitqueryFloatSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txInMessageBounceFlag?: InputMaybe<BitqueryBooleanSelector>;
  txLogicalTime?: InputMaybe<BitqueryIntegerSelector>;
  txNewHash?: InputMaybe<BitqueryStringSelector>;
  txOldHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txOutMessagesCount?: InputMaybe<BitqueryIntegerSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};


/** Everscale Chain */
export type BitqueryEverscaleTransfersArgs = {
  any?: InputMaybe<Array<BitqueryEverscaleTransferFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryBigIntIdSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transferReceiver?: InputMaybe<BitqueryStringSelector>;
  transferSender?: InputMaybe<BitqueryStringSelector>;
  transferType?: InputMaybe<BitqueryEverscaleTransferTypeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};

export enum BitqueryEverscaleAccountStateEnum {
  /** The account`s code and data have been initialized as well. */
  Active = 'Active',
  /** The account`s code and data have been replaced by a hash, but the balance is still stored explicitly. The balance of a frozen account. */
  Frozen = 'Frozen',
  /** Initialized account. */
  NonExist = 'NonExist',
  /** The account only has a balance; its code and data have not yet been initialized. */
  Uninit = 'Uninit'
}

/** Select by account state */
export type BitqueryEverscaleAccountStateSelector = {
  /** Account state in the list */
  in?: InputMaybe<Array<BitqueryEverscaleAccountStateEnum>>;
  /** Account state is */
  is?: InputMaybe<BitqueryEverscaleAccountStateEnum>;
  /** Account state not */
  not?: InputMaybe<BitqueryEverscaleAccountStateEnum>;
  /** Account state not in the list */
  notIn?: InputMaybe<Array<BitqueryEverscaleAccountStateEnum>>;
};

/** Address balance information for Everscale network */
export type BitqueryEverscaleAddressBalance = {
  __typename?: 'BitqueryEverscaleAddressBalance';
  /** Currency */
  currency?: Maybe<BitqueryCurrency>;
  value?: Maybe<Scalars['Float']['output']>;
};


/** Address balance information for Everscale network */
export type BitqueryEverscaleAddressBalanceValueArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};

/** Address detailed information for Everscale network */
export type BitqueryEverscaleAddressInfo = {
  __typename?: 'BitqueryEverscaleAddressInfo';
  /** Address */
  address?: Maybe<BitqueryAddress>;
  /** Current address balances */
  balance?: Maybe<Array<BitqueryEverscaleAddressBalance>>;
};

/** Argument in Everscale blockchain */
export type BitqueryEverscaleArgument = {
  __typename?: 'BitqueryEverscaleArgument';
  any?: Maybe<Scalars['String']['output']>;
  /** Hash of the the block */
  blockHash?: Maybe<Scalars['String']['output']>;
  /** Shard number of block */
  blockShard?: Maybe<Scalars['String']['output']>;
  /** Proposer block hash */
  blockWorkchain?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Argument Field */
  field?: Maybe<Scalars['String']['output']>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Argument Index */
  index?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** messages */
  messages?: Maybe<BitqueryEverscaleMessageDimension>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Previous Block */
  previousBlock?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Sharded Block Information */
  shardedBlock?: Maybe<BitqueryEverscaleShardedBlockDimension>;
  /** smart contract address */
  smartContractAddress?: Maybe<BitqueryAddress>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<BitqueryMethod>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transactions */
  transactions?: Maybe<BitqueryEverscaleTransactionDimension>;
  /** Argument Type */
  type?: Maybe<Scalars['String']['output']>;
  /** Argument Vlaue */
  value?: Maybe<Scalars['String']['output']>;
};


/** Argument in Everscale blockchain */
export type BitqueryEverscaleArgumentAnyArgs = {
  of: BitqueryEverscaleArgumentMeasurable;
};


/** Argument in Everscale blockchain */
export type BitqueryEverscaleArgumentCountArgs = {
  argumentField?: InputMaybe<BitqueryStringSelector>;
  argumentIndex?: InputMaybe<BitqueryIntegerSelector>;
  argumentType?: InputMaybe<BitqueryEverscaleArgumentTypeSelector>;
  argumentValue?: InputMaybe<BitqueryStringSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryEverscaleArgumentUniq>;
};


/** Argument in Everscale blockchain */
export type BitqueryEverscaleArgumentCountBigIntArgs = {
  argumentField?: InputMaybe<BitqueryStringSelector>;
  argumentIndex?: InputMaybe<BitqueryIntegerSelector>;
  argumentType?: InputMaybe<BitqueryEverscaleArgumentTypeSelector>;
  argumentValue?: InputMaybe<BitqueryStringSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryEverscaleArgumentUniq>;
};


/** Argument in Everscale blockchain */
export type BitqueryEverscaleArgumentExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Argument in Everscale blockchain */
export type BitqueryEverscaleArgumentMaximumArgs = {
  get?: InputMaybe<BitqueryEverscaleArgumentMeasurable>;
  of: BitqueryEverscaleArgumentMeasurable;
};


/** Argument in Everscale blockchain */
export type BitqueryEverscaleArgumentMessagesArgs = {
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Argument in Everscale blockchain */
export type BitqueryEverscaleArgumentMinimumArgs = {
  get?: InputMaybe<BitqueryEverscaleArgumentMeasurable>;
  of: BitqueryEverscaleArgumentMeasurable;
};


/** Argument in Everscale blockchain */
export type BitqueryEverscaleArgumentShardedBlockArgs = {
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  shard?: InputMaybe<BitqueryStringIdSelector>;
  workchain?: InputMaybe<BitqueryBigIntIdSelector>;
};


/** Argument in Everscale blockchain */
export type BitqueryEverscaleArgumentSmartContractMethodArgs = {
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
};


/** Argument in Everscale blockchain */
export type BitqueryEverscaleArgumentTransactionsArgs = {
  txAborted?: InputMaybe<BitqueryBigIntIdSelector>;
  txAccount?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txType?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryEverscaleArgumentFilter = {
  argumentField?: InputMaybe<BitqueryStringSelector>;
  argumentIndex?: InputMaybe<BitqueryIntegerSelector>;
  argumentType?: InputMaybe<BitqueryEverscaleArgumentTypeSelector>;
  argumentValue?: InputMaybe<BitqueryStringSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};

export enum BitqueryEverscaleArgumentMeasurable {
  /** Date */
  Date = 'date',
  /** Hash of the the block */
  Hash = 'hash',
  /** Number of block in the blockhains */
  Height = 'height',
  /** Message direction */
  MessageDirection = 'message_direction',
  /** Message Hash */
  MessageHash = 'message_hash',
  /** Message receiver */
  MessageReceiver = 'message_receiver',
  /** Message sender */
  MessageSender = 'message_sender',
  /** Message type name */
  MessageTypeName = 'message_type_name',
  /** Message value */
  MessageValue = 'message_value',
  /** Previous Message */
  PreviousBlock = 'previous_block',
  /** Shard of block in the blockhains */
  Shard = 'shard',
  /** Number of sharded block block in the blockhains */
  ShardedBlock = 'sharded_block',
  /** Hash of the the sharded block block */
  ShardedBlockHash = 'sharded_block_hash',
  /** Shard of sharded block block in the blockhains */
  ShardedBlockShard = 'sharded_block_shard',
  /** Workchain of sharded block block in the blockhains */
  ShardedBlockWorkchain = 'sharded_block_workchain',
  /** Signature */
  Signature = 'signature',
  /** Signature Hash */
  SignatureHash = 'signature_hash',
  /** Signature Name */
  SignatureName = 'signature_name',
  /** Time */
  Time = 'time',
  /** Tx Aborted */
  TxAborted = 'tx_aborted',
  /** Tx Account */
  TxAccount = 'tx_account',
  /** Tx Hash */
  TxHash = 'tx_hash',
  /** Tx Type */
  TxType = 'tx_type',
  /** Workchain of block in the blockhains */
  Workchain = 'workchain'
}

export enum BitqueryEverscaleArgumentTypeEnum {
  /** Argument of call */
  Call = 'call',
  /** Argument of event */
  Event = 'event'
}

/** Select by argument type */
export type BitqueryEverscaleArgumentTypeSelector = {
  /** Argument type in the list */
  in?: InputMaybe<Array<BitqueryEverscaleArgumentTypeEnum>>;
  /** Argument type is */
  is?: InputMaybe<BitqueryEverscaleArgumentTypeEnum>;
  /** Argument type not */
  not?: InputMaybe<BitqueryEverscaleArgumentTypeEnum>;
  /** Argument type not in the list */
  notIn?: InputMaybe<Array<BitqueryEverscaleArgumentTypeEnum>>;
};

export enum BitqueryEverscaleArgumentUniq {
  /** Unique Number of Shards in the blockchains */
  BlockShard = 'block_shard',
  /** Unique Number of workchains in the blockchains */
  BlockWorkchain = 'block_workchain',
  /** Uniq dates count */
  Dates = 'dates',
  /** Unique Number of block in the blockchains */
  Height = 'height',
  /** Unique Number of messages */
  Messages = 'messages',
  /** Unique Number of sharded block shards in the blockchains */
  ShardedBlockShards = 'sharded_block_shards',
  /** Unique Number of sharded block workchains in the blockchains */
  ShardedBlockWorkchains = 'sharded_block_workchains',
  /** Unique Number of sharded blocks in the blockchains */
  ShardedBlocks = 'sharded_blocks',
  /** Unique Number of signatures */
  SmartContractMethods = 'smart_contract_methods',
  /** Unique Number of smart contracts */
  SmartContracts = 'smart_contracts',
  /** Uniq times count */
  Times = 'times',
  /** Unique Number of transactions */
  Txs = 'txs'
}

/** Block in Everscale blockchain */
export type BitqueryEverscaleBlock = {
  __typename?: 'BitqueryEverscaleBlock';
  /** After Merge */
  afterMerge?: Maybe<Scalars['Boolean']['output']>;
  /** After Split */
  afterSplit?: Maybe<Scalars['Boolean']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Before Split */
  beforeSplit?: Maybe<Scalars['Boolean']['output']>;
  /** Boc */
  boc?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Information about block general */
  general?: Maybe<BitqueryEverscaleGeneralDimension>;
  /** Global Id */
  globalId?: Maybe<Scalars['Int']['output']>;
  /** Hash of the the block */
  hash?: Maybe<Scalars['String']['output']>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Logical Time end */
  logicalTimeEnd?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Logical Time Start */
  logicalTimeStart?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Minimal Reference Masterchain Block */
  minimalReferenceMasterchainBlock?: Maybe<Scalars['BitqueryBigInt']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Previous Block */
  previousBlock?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Random Seed */
  randomSeed?: Maybe<Scalars['String']['output']>;
  /** Shard number of block */
  shard?: Maybe<Scalars['String']['output']>;
  /** Sharded Block Information */
  shardedBlock?: Maybe<BitqueryEverscaleShardedBlockDimension>;
  /** Status */
  status?: Maybe<Scalars['Int']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Tx Count */
  txCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  value?: Maybe<BitqueryEverscaleValueDimension>;
  /** Version */
  version?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Vertical Sequence */
  verticalSeqNo?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Want Merge */
  wantMerge?: Maybe<Scalars['Boolean']['output']>;
  /** Want Split */
  wantSplit?: Maybe<Scalars['Boolean']['output']>;
  /** Proposer block hash */
  workchain?: Maybe<Scalars['BitqueryBigInt']['output']>;
};


/** Block in Everscale blockchain */
export type BitqueryEverscaleBlockAnyArgs = {
  of: BitqueryEverscaleBlockMeasurable;
};


/** Block in Everscale blockchain */
export type BitqueryEverscaleBlockCountArgs = {
  afterMerge?: InputMaybe<BitqueryBooleanSelector>;
  afterSplit?: InputMaybe<BitqueryBooleanSelector>;
  beforeSplit?: InputMaybe<BitqueryBooleanSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  catchainSeqno?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  globalId?: InputMaybe<BitqueryIntegerSelector>;
  logicalTimeEnd?: InputMaybe<BitqueryBigIntegerSelector>;
  logicalTimeStart?: InputMaybe<BitqueryBigIntegerSelector>;
  minimalReferenceMasterchainBlock?: InputMaybe<BitqueryBigIntegerSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  softwareCapabilities?: InputMaybe<BitqueryStringSelector>;
  softwareVersion?: InputMaybe<BitqueryIntegerSelector>;
  status?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCount?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryEverscaleBlockUniq>;
  validatorListHastShort?: InputMaybe<BitqueryIntegerSelector>;
  valueFlowCreated?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowExported?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowFeesCollected?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowFeesImported?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowFromPreviousBlock?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowImported?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowMinted?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowToNextBlock?: InputMaybe<BitqueryBigIntegerSelector>;
  version?: InputMaybe<BitqueryBigIntegerSelector>;
  verticalSeqNo?: InputMaybe<BitqueryBigIntegerSelector>;
  wantMerge?: InputMaybe<BitqueryBooleanSelector>;
  wantSplit?: InputMaybe<BitqueryBooleanSelector>;
};


/** Block in Everscale blockchain */
export type BitqueryEverscaleBlockCountBigIntArgs = {
  afterMerge?: InputMaybe<BitqueryBooleanSelector>;
  afterSplit?: InputMaybe<BitqueryBooleanSelector>;
  beforeSplit?: InputMaybe<BitqueryBooleanSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  catchainSeqno?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  globalId?: InputMaybe<BitqueryIntegerSelector>;
  logicalTimeEnd?: InputMaybe<BitqueryBigIntegerSelector>;
  logicalTimeStart?: InputMaybe<BitqueryBigIntegerSelector>;
  minimalReferenceMasterchainBlock?: InputMaybe<BitqueryBigIntegerSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  softwareCapabilities?: InputMaybe<BitqueryStringSelector>;
  softwareVersion?: InputMaybe<BitqueryIntegerSelector>;
  status?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCount?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryEverscaleBlockUniq>;
  validatorListHastShort?: InputMaybe<BitqueryIntegerSelector>;
  valueFlowCreated?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowExported?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowFeesCollected?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowFeesImported?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowFromPreviousBlock?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowImported?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowMinted?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowToNextBlock?: InputMaybe<BitqueryBigIntegerSelector>;
  version?: InputMaybe<BitqueryBigIntegerSelector>;
  verticalSeqNo?: InputMaybe<BitqueryBigIntegerSelector>;
  wantMerge?: InputMaybe<BitqueryBooleanSelector>;
  wantSplit?: InputMaybe<BitqueryBooleanSelector>;
};


/** Block in Everscale blockchain */
export type BitqueryEverscaleBlockExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Block in Everscale blockchain */
export type BitqueryEverscaleBlockGeneralArgs = {
  catchainSeqno?: InputMaybe<BitqueryIntegerSelector>;
  softwareCapabilities?: InputMaybe<BitqueryStringSelector>;
  softwareVersion?: InputMaybe<BitqueryIntegerSelector>;
  validatorListHastShort?: InputMaybe<BitqueryIntegerSelector>;
};


/** Block in Everscale blockchain */
export type BitqueryEverscaleBlockMaximumArgs = {
  get?: InputMaybe<BitqueryEverscaleBlockMeasurable>;
  of: BitqueryEverscaleBlockMeasurable;
};


/** Block in Everscale blockchain */
export type BitqueryEverscaleBlockMinimumArgs = {
  get?: InputMaybe<BitqueryEverscaleBlockMeasurable>;
  of: BitqueryEverscaleBlockMeasurable;
};


/** Block in Everscale blockchain */
export type BitqueryEverscaleBlockShardedBlockArgs = {
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  shard?: InputMaybe<BitqueryStringIdSelector>;
  workchain?: InputMaybe<BitqueryBigIntIdSelector>;
};


/** Block in Everscale blockchain */
export type BitqueryEverscaleBlockValueArgs = {
  valueFlowCreated?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowExported?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowFeesCollected?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowFeesImported?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowFromPreviousBlock?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowImported?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowMinted?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowToNextBlock?: InputMaybe<BitqueryBigIntegerSelector>;
};

export type BitqueryEverscaleBlockFilter = {
  afterMerge?: InputMaybe<BitqueryBooleanSelector>;
  afterSplit?: InputMaybe<BitqueryBooleanSelector>;
  beforeSplit?: InputMaybe<BitqueryBooleanSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  catchainSeqno?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  globalId?: InputMaybe<BitqueryIntegerSelector>;
  logicalTimeEnd?: InputMaybe<BitqueryBigIntegerSelector>;
  logicalTimeStart?: InputMaybe<BitqueryBigIntegerSelector>;
  minimalReferenceMasterchainBlock?: InputMaybe<BitqueryBigIntegerSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  softwareCapabilities?: InputMaybe<BitqueryStringSelector>;
  softwareVersion?: InputMaybe<BitqueryIntegerSelector>;
  status?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCount?: InputMaybe<BitqueryIntegerSelector>;
  validatorListHastShort?: InputMaybe<BitqueryIntegerSelector>;
  valueFlowCreated?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowExported?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowFeesCollected?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowFeesImported?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowFromPreviousBlock?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowImported?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowMinted?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowToNextBlock?: InputMaybe<BitqueryBigIntegerSelector>;
  version?: InputMaybe<BitqueryBigIntegerSelector>;
  verticalSeqNo?: InputMaybe<BitqueryBigIntegerSelector>;
  wantMerge?: InputMaybe<BitqueryBooleanSelector>;
  wantSplit?: InputMaybe<BitqueryBooleanSelector>;
};

export enum BitqueryEverscaleBlockMeasurable {
  /** After Merge */
  AfterMerge = 'after_merge',
  /** After Split */
  AfterSplit = 'after_split',
  /** Before Split */
  BeforeSplit = 'before_split',
  /** Date */
  Date = 'date',
  /** Global ID */
  GlobalId = 'global_id',
  /** Hash of the the block */
  Hash = 'hash',
  /** Number of block in the blockhains */
  Height = 'height',
  /** Logical Time End */
  LogicalTimeEnd = 'logical_time_end',
  /** Logical Time Start */
  LogicalTimeStart = 'logical_time_start',
  /** Minimal Reference Masterchain Block */
  MinimalReferenceMasterchainBlock = 'minimal_reference_masterchain_block',
  /** Previous Block */
  PreviousBlock = 'previous_block',
  /** Shard of block in the blockhains */
  Shard = 'shard',
  /** Number of sharded block block in the blockhains */
  ShardedBlock = 'sharded_block',
  /** Hash of the the sharded block block */
  ShardedBlockHash = 'sharded_block_hash',
  /** Shard of sharded block block in the blockhains */
  ShardedBlockShard = 'sharded_block_shard',
  /** Workchain of sharded block block in the blockhains */
  ShardedBlockWorkchain = 'sharded_block_workchain',
  /** Status */
  Status = 'status',
  /** Time */
  Time = 'time',
  /** Count of transactions in this block */
  TxCount = 'tx_count',
  /** Value created */
  ValueFlowCreated = 'value_flow_created',
  /** Value Exported */
  ValueFlowExported = 'value_flow_exported',
  /** Value Fees collected */
  ValueFlowFeesCollected = 'value_flow_fees_collected',
  /** Value Fees imported */
  ValueFlowFeesImported = 'value_flow_fees_imported',
  /** Value From Previous Block */
  ValueFlowFromPreviousBlock = 'value_flow_from_previous_block',
  /** Value Imported */
  ValueFlowImported = 'value_flow_imported',
  /** Value minted */
  ValueFlowMinted = 'value_flow_minted',
  /** Value To Previous Block */
  ValueFlowToPreviousBlock = 'value_flow_to_previous_block',
  /** Version */
  Version = 'version',
  /** Vertical Sequence */
  VerticalSeqNo = 'vertical_seq_no',
  /** Want Merge */
  WantMerge = 'want_merge',
  /** Want Split */
  WantSplit = 'want_split',
  /** Workchain of block in the blockhains */
  Workchain = 'workchain'
}

export enum BitqueryEverscaleBlockUniq {
  /** Unique Number of Shards in the blockchains */
  BlockShard = 'block_shard',
  /** Unique Number of workchains in the blockchains */
  BlockWorkchain = 'block_workchain',
  /** Uniq dates count */
  Dates = 'dates',
  /** Unique Number of block in the blockchains */
  Height = 'height',
  /** Unique Number of sharded block shards in the blockchains */
  ShardedBlockShards = 'sharded_block_shards',
  /** Unique Number of sharded block workchains in the blockchains */
  ShardedBlockWorkchains = 'sharded_block_workchains',
  /** Unique Number of sharded blocks in the blockchains */
  ShardedBlocks = 'sharded_blocks',
  /** Uniq times count */
  Times = 'times'
}

/** Call in Everscale blockchain */
export type BitqueryEverscaleCall = {
  __typename?: 'BitqueryEverscaleCall';
  any?: Maybe<Scalars['String']['output']>;
  /** Hash of the the block */
  blockHash?: Maybe<Scalars['String']['output']>;
  /** Shard number of block */
  blockShard?: Maybe<Scalars['String']['output']>;
  /** Proposer block hash */
  blockWorkchain?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** messages */
  messages?: Maybe<BitqueryEverscaleMessageDimension>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Previous Block */
  previousBlock?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Sharded Block Information */
  shardedBlock?: Maybe<BitqueryEverscaleShardedBlockDimension>;
  /** smart contract address */
  smartContractAddress?: Maybe<BitqueryAddress>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<BitqueryMethod>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transactions */
  transactions?: Maybe<BitqueryEverscaleTransactionDimension>;
};


/** Call in Everscale blockchain */
export type BitqueryEverscaleCallAnyArgs = {
  of: BitqueryEverscaleCallMeasurable;
};


/** Call in Everscale blockchain */
export type BitqueryEverscaleCallCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryEverscaleCallUniq>;
};


/** Call in Everscale blockchain */
export type BitqueryEverscaleCallCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryEverscaleCallUniq>;
};


/** Call in Everscale blockchain */
export type BitqueryEverscaleCallExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Call in Everscale blockchain */
export type BitqueryEverscaleCallMaximumArgs = {
  get?: InputMaybe<BitqueryEverscaleCallMeasurable>;
  of: BitqueryEverscaleCallMeasurable;
};


/** Call in Everscale blockchain */
export type BitqueryEverscaleCallMessagesArgs = {
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Call in Everscale blockchain */
export type BitqueryEverscaleCallMinimumArgs = {
  get?: InputMaybe<BitqueryEverscaleCallMeasurable>;
  of: BitqueryEverscaleCallMeasurable;
};


/** Call in Everscale blockchain */
export type BitqueryEverscaleCallShardedBlockArgs = {
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  shard?: InputMaybe<BitqueryStringIdSelector>;
  workchain?: InputMaybe<BitqueryBigIntIdSelector>;
};


/** Call in Everscale blockchain */
export type BitqueryEverscaleCallSmartContractMethodArgs = {
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
};


/** Call in Everscale blockchain */
export type BitqueryEverscaleCallTransactionsArgs = {
  txAborted?: InputMaybe<BitqueryBigIntIdSelector>;
  txAccount?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txType?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryEverscaleCallFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};

export enum BitqueryEverscaleCallMeasurable {
  /** Date */
  Date = 'date',
  /** Hash of the the block */
  Hash = 'hash',
  /** Number of block in the blockhains */
  Height = 'height',
  /** Message direction */
  MessageDirection = 'message_direction',
  /** Message Hash */
  MessageHash = 'message_hash',
  /** Message receiver */
  MessageReceiver = 'message_receiver',
  /** Message sender */
  MessageSender = 'message_sender',
  /** Message type name */
  MessageTypeName = 'message_type_name',
  /** Message value */
  MessageValue = 'message_value',
  /** Previous Message */
  PreviousBlock = 'previous_block',
  /** Shard of block in the blockhains */
  Shard = 'shard',
  /** Number of sharded block block in the blockhains */
  ShardedBlock = 'sharded_block',
  /** Hash of the the sharded block block */
  ShardedBlockHash = 'sharded_block_hash',
  /** Shard of sharded block block in the blockhains */
  ShardedBlockShard = 'sharded_block_shard',
  /** Workchain of sharded block block in the blockhains */
  ShardedBlockWorkchain = 'sharded_block_workchain',
  /** Signature */
  Signature = 'signature',
  /** Signature Hash */
  SignatureHash = 'signature_hash',
  /** Signature Name */
  SignatureName = 'signature_name',
  /** Time */
  Time = 'time',
  /** Tx Aborted */
  TxAborted = 'tx_aborted',
  /** Tx Account */
  TxAccount = 'tx_account',
  /** Tx Hash */
  TxHash = 'tx_hash',
  /** Tx Type */
  TxType = 'tx_type',
  /** Workchain of block in the blockhains */
  Workchain = 'workchain'
}

export enum BitqueryEverscaleCallUniq {
  /** Unique Number of Shards in the blockchains */
  BlockShard = 'block_shard',
  /** Unique Number of workchains in the blockchains */
  BlockWorkchain = 'block_workchain',
  /** Uniq dates count */
  Dates = 'dates',
  /** Unique Number of block in the blockchains */
  Height = 'height',
  /** Unique Number of messages */
  Messages = 'messages',
  /** Unique Number of sharded block shards in the blockchains */
  ShardedBlockShards = 'sharded_block_shards',
  /** Unique Number of sharded block workchains in the blockchains */
  ShardedBlockWorkchains = 'sharded_block_workchains',
  /** Unique Number of sharded blocks in the blockchains */
  ShardedBlocks = 'sharded_blocks',
  /** Unique Number of signatures */
  SmartContractMethods = 'smart_contract_methods',
  /** Unique Number of smart contracts */
  SmartContracts = 'smart_contracts',
  /** Uniq times count */
  Times = 'times',
  /** Unique Number of transactions */
  Txs = 'txs'
}

/** Everscale Coinpath */
export type BitqueryEverscaleCoinpath = {
  __typename?: 'BitqueryEverscaleCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<BitqueryTransactionHashValueTime>;
};


/** Everscale Coinpath */
export type BitqueryEverscaleCoinpathAmountArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Everscale Coinpath */
export type BitqueryEverscaleCoinpathAnyArgs = {
  of: BitqueryEverscaleCoinpathMeasureable;
};


/** Everscale Coinpath */
export type BitqueryEverscaleCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryEverscaleCoinpathMeasureable>;
  of: BitqueryEverscaleCoinpathMeasureable;
};


/** Everscale Coinpath */
export type BitqueryEverscaleCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryEverscaleCoinpathMeasureable>;
  of: BitqueryEverscaleCoinpathMeasureable;
};

export enum BitqueryEverscaleCoinpathMeasureable {
  /** Block */
  Block = 'block',
  /** Depth */
  Depth = 'depth',
  /** Receiver */
  Receiver = 'receiver',
  /** Sender */
  Sender = 'sender',
  /** Time */
  Time = 'time',
  /** Version */
  TxHash = 'tx_hash'
}

/** Event in Everscale blockchain */
export type BitqueryEverscaleEvent = {
  __typename?: 'BitqueryEverscaleEvent';
  any?: Maybe<Scalars['String']['output']>;
  /** Hash of the the block */
  blockHash?: Maybe<Scalars['String']['output']>;
  /** Shard number of block */
  blockShard?: Maybe<Scalars['String']['output']>;
  /** Proposer block hash */
  blockWorkchain?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** messages */
  messages?: Maybe<BitqueryEverscaleMessageDimension>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Previous Block */
  previousBlock?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Sharded Block Information */
  shardedBlock?: Maybe<BitqueryEverscaleShardedBlockDimension>;
  /** smart contract address */
  smartContractAddress?: Maybe<BitqueryAddress>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<BitqueryMethod>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transactions */
  transactions?: Maybe<BitqueryEverscaleTransactionDimension>;
};


/** Event in Everscale blockchain */
export type BitqueryEverscaleEventAnyArgs = {
  of: BitqueryEverscaleEventMeasurable;
};


/** Event in Everscale blockchain */
export type BitqueryEverscaleEventCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryEverscaleEventUniq>;
};


/** Event in Everscale blockchain */
export type BitqueryEverscaleEventCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryEverscaleEventUniq>;
};


/** Event in Everscale blockchain */
export type BitqueryEverscaleEventExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Event in Everscale blockchain */
export type BitqueryEverscaleEventMaximumArgs = {
  get?: InputMaybe<BitqueryEverscaleEventMeasurable>;
  of: BitqueryEverscaleEventMeasurable;
};


/** Event in Everscale blockchain */
export type BitqueryEverscaleEventMessagesArgs = {
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Event in Everscale blockchain */
export type BitqueryEverscaleEventMinimumArgs = {
  get?: InputMaybe<BitqueryEverscaleEventMeasurable>;
  of: BitqueryEverscaleEventMeasurable;
};


/** Event in Everscale blockchain */
export type BitqueryEverscaleEventShardedBlockArgs = {
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  shard?: InputMaybe<BitqueryStringIdSelector>;
  workchain?: InputMaybe<BitqueryBigIntIdSelector>;
};


/** Event in Everscale blockchain */
export type BitqueryEverscaleEventSmartContractMethodArgs = {
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
};


/** Event in Everscale blockchain */
export type BitqueryEverscaleEventTransactionsArgs = {
  txAborted?: InputMaybe<BitqueryBigIntIdSelector>;
  txAccount?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txType?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryEverscaleEventFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};

export enum BitqueryEverscaleEventMeasurable {
  /** Date */
  Date = 'date',
  /** Hash of the the block */
  Hash = 'hash',
  /** Number of block in the blockhains */
  Height = 'height',
  /** Message direction */
  MessageDirection = 'message_direction',
  /** Message Hash */
  MessageHash = 'message_hash',
  /** Message receiver */
  MessageReceiver = 'message_receiver',
  /** Message sender */
  MessageSender = 'message_sender',
  /** Message type name */
  MessageTypeName = 'message_type_name',
  /** Message value */
  MessageValue = 'message_value',
  /** Previous Message */
  PreviousBlock = 'previous_block',
  /** Shard of block in the blockhains */
  Shard = 'shard',
  /** Number of sharded block block in the blockhains */
  ShardedBlock = 'sharded_block',
  /** Hash of the the sharded block block */
  ShardedBlockHash = 'sharded_block_hash',
  /** Shard of sharded block block in the blockhains */
  ShardedBlockShard = 'sharded_block_shard',
  /** Workchain of sharded block block in the blockhains */
  ShardedBlockWorkchain = 'sharded_block_workchain',
  /** Signature */
  Signature = 'signature',
  /** Signature Hash */
  SignatureHash = 'signature_hash',
  /** Signature Name */
  SignatureName = 'signature_name',
  /** Time */
  Time = 'time',
  /** Tx Aborted */
  TxAborted = 'tx_aborted',
  /** Tx Account */
  TxAccount = 'tx_account',
  /** Tx Hash */
  TxHash = 'tx_hash',
  /** Tx Type */
  TxType = 'tx_type',
  /** Workchain of block in the blockhains */
  Workchain = 'workchain'
}

export enum BitqueryEverscaleEventUniq {
  /** Unique Number of Shards in the blockchains */
  BlockShard = 'block_shard',
  /** Unique Number of workchains in the blockchains */
  BlockWorkchain = 'block_workchain',
  /** Uniq dates count */
  Dates = 'dates',
  /** Unique Number of block in the blockchains */
  Height = 'height',
  /** Unique Number of messages */
  Messages = 'messages',
  /** Unique Number of sharded block shards in the blockchains */
  ShardedBlockShards = 'sharded_block_shards',
  /** Unique Number of sharded block workchains in the blockchains */
  ShardedBlockWorkchains = 'sharded_block_workchains',
  /** Unique Number of sharded blocks in the blockchains */
  ShardedBlocks = 'sharded_blocks',
  /** Unique Number of signatures */
  SmartContractMethods = 'smart_contract_methods',
  /** Unique Number of smart contracts */
  SmartContracts = 'smart_contracts',
  /** Uniq times count */
  Times = 'times',
  /** Unique Number of transactions */
  Txs = 'txs'
}

/** General Block information */
export type BitqueryEverscaleGeneralDimension = {
  __typename?: 'BitqueryEverscaleGeneralDimension';
  /** Catchain Sequence */
  catchainSeqno?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Software capabilities */
  softwareCapabilities?: Maybe<Scalars['String']['output']>;
  /** Software version */
  softwareVersion?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Validator List Hast Short */
  validatorListHashShort?: Maybe<Scalars['BitqueryBigInt']['output']>;
};

/** Message in Everscale blockchain */
export type BitqueryEverscaleMessage = {
  __typename?: 'BitqueryEverscaleMessage';
  any?: Maybe<Scalars['String']['output']>;
  /** Hash of the the block */
  blockHash?: Maybe<Scalars['String']['output']>;
  /** Shard number of block */
  blockShard?: Maybe<Scalars['String']['output']>;
  /** Proposer block hash */
  blockWorkchain?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Message boc */
  boc?: Maybe<Scalars['String']['output']>;
  /** Message body */
  body?: Maybe<Scalars['String']['output']>;
  /** Message body hash */
  bodyHash?: Maybe<Scalars['String']['output']>;
  /** Message Bounce */
  bounce?: Maybe<Scalars['Boolean']['output']>;
  /** Message bounced */
  bounced?: Maybe<Scalars['Boolean']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Message created logical time */
  createdLogicalTime?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Message data */
  data?: Maybe<Scalars['String']['output']>;
  /** Message data hash */
  dataHash?: Maybe<Scalars['String']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Message Direction */
  direction?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Message fwd fee */
  fwdFee?: Maybe<Scalars['Float']['output']>;
  /** Message Hash */
  hash?: Maybe<Scalars['String']['output']>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Message ihr disabled */
  ihrDisabled?: Maybe<Scalars['Boolean']['output']>;
  /** Message ihr fee */
  ihrFee?: Maybe<Scalars['Float']['output']>;
  /** Message index */
  index?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Previous Block */
  previousBlock?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Message receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Message sender */
  sender?: Maybe<BitqueryAddress>;
  /** Sharded Block Information */
  shardedBlock?: Maybe<BitqueryEverscaleShardedBlockDimension>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transactions */
  transactions?: Maybe<BitqueryEverscaleTransactionDimension>;
  /** Message Type Name */
  typeName?: Maybe<Scalars['String']['output']>;
  value?: Maybe<Scalars['Float']['output']>;
};


/** Message in Everscale blockchain */
export type BitqueryEverscaleMessageAnyArgs = {
  of: BitqueryEverscaleMessageMeasurable;
};


/** Message in Everscale blockchain */
export type BitqueryEverscaleMessageCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  messageBoc?: InputMaybe<BitqueryStringSelector>;
  messageBody?: InputMaybe<BitqueryStringSelector>;
  messageBodyHash?: InputMaybe<BitqueryStringSelector>;
  messageBounce?: InputMaybe<BitqueryBooleanSelector>;
  messageBounced?: InputMaybe<BitqueryBooleanSelector>;
  messageCreatedLogicalTime?: InputMaybe<BitqueryBigIntegerSelector>;
  messageData?: InputMaybe<BitqueryStringSelector>;
  messageDataHash?: InputMaybe<BitqueryStringSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageFwdFee?: InputMaybe<BitqueryFloatSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageIhrDisabled?: InputMaybe<BitqueryBooleanSelector>;
  messageIndex?: InputMaybe<BitqueryIntegerSelector>;
  messageIrbFee?: InputMaybe<BitqueryFloatSelector>;
  messageReceiver?: InputMaybe<BitqueryStringSelector>;
  messageSender?: InputMaybe<BitqueryStringSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryEverscaleMessageUniq>;
};


/** Message in Everscale blockchain */
export type BitqueryEverscaleMessageCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  messageBoc?: InputMaybe<BitqueryStringSelector>;
  messageBody?: InputMaybe<BitqueryStringSelector>;
  messageBodyHash?: InputMaybe<BitqueryStringSelector>;
  messageBounce?: InputMaybe<BitqueryBooleanSelector>;
  messageBounced?: InputMaybe<BitqueryBooleanSelector>;
  messageCreatedLogicalTime?: InputMaybe<BitqueryBigIntegerSelector>;
  messageData?: InputMaybe<BitqueryStringSelector>;
  messageDataHash?: InputMaybe<BitqueryStringSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageFwdFee?: InputMaybe<BitqueryFloatSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageIhrDisabled?: InputMaybe<BitqueryBooleanSelector>;
  messageIndex?: InputMaybe<BitqueryIntegerSelector>;
  messageIrbFee?: InputMaybe<BitqueryFloatSelector>;
  messageReceiver?: InputMaybe<BitqueryStringSelector>;
  messageSender?: InputMaybe<BitqueryStringSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryEverscaleMessageUniq>;
};


/** Message in Everscale blockchain */
export type BitqueryEverscaleMessageExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Message in Everscale blockchain */
export type BitqueryEverscaleMessageMaximumArgs = {
  get?: InputMaybe<BitqueryEverscaleMessageMeasurable>;
  of: BitqueryEverscaleMessageMeasurable;
};


/** Message in Everscale blockchain */
export type BitqueryEverscaleMessageMinimumArgs = {
  get?: InputMaybe<BitqueryEverscaleMessageMeasurable>;
  of: BitqueryEverscaleMessageMeasurable;
};


/** Message in Everscale blockchain */
export type BitqueryEverscaleMessageShardedBlockArgs = {
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  shard?: InputMaybe<BitqueryStringIdSelector>;
  workchain?: InputMaybe<BitqueryBigIntIdSelector>;
};


/** Message in Everscale blockchain */
export type BitqueryEverscaleMessageTransactionsArgs = {
  txAborted?: InputMaybe<BitqueryBigIntIdSelector>;
  txAccount?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txType?: InputMaybe<BitqueryStringSelector>;
};


/** Message in Everscale blockchain */
export type BitqueryEverscaleMessageValueArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  messageBoc?: InputMaybe<BitqueryStringSelector>;
  messageBody?: InputMaybe<BitqueryStringSelector>;
  messageBodyHash?: InputMaybe<BitqueryStringSelector>;
  messageBounce?: InputMaybe<BitqueryBooleanSelector>;
  messageBounced?: InputMaybe<BitqueryBooleanSelector>;
  messageCreatedLogicalTime?: InputMaybe<BitqueryBigIntegerSelector>;
  messageData?: InputMaybe<BitqueryStringSelector>;
  messageDataHash?: InputMaybe<BitqueryStringSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageFwdFee?: InputMaybe<BitqueryFloatSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageIhrDisabled?: InputMaybe<BitqueryBooleanSelector>;
  messageIndex?: InputMaybe<BitqueryIntegerSelector>;
  messageIrbFee?: InputMaybe<BitqueryFloatSelector>;
  messageReceiver?: InputMaybe<BitqueryStringSelector>;
  messageSender?: InputMaybe<BitqueryStringSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};

/** Information about message */
export type BitqueryEverscaleMessageDimension = {
  __typename?: 'BitqueryEverscaleMessageDimension';
  /** Message Direction */
  direction?: Maybe<Scalars['String']['output']>;
  /** Message Hash */
  hash?: Maybe<Scalars['String']['output']>;
  /** Message Receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Message Sender */
  sender?: Maybe<BitqueryAddress>;
  /** Message Type */
  typeName?: Maybe<Scalars['String']['output']>;
  /** Message value */
  value?: Maybe<Scalars['Float']['output']>;
};

export enum BitqueryEverscaleMessageDirectionEnum {
  /** Inbound message */
  In = 'in',
  /** Outbound Message */
  Out = 'out'
}

/** Select by message direction */
export type BitqueryEverscaleMessageDirectionSelector = {
  /** Message Direction in the list */
  in?: InputMaybe<Array<BitqueryEverscaleMessageDirectionEnum>>;
  /** Message Direction is */
  is?: InputMaybe<BitqueryEverscaleMessageDirectionEnum>;
  /** Message Direction not */
  not?: InputMaybe<BitqueryEverscaleMessageDirectionEnum>;
  /** Message Direction not in the list */
  notIn?: InputMaybe<Array<BitqueryEverscaleMessageDirectionEnum>>;
};

export type BitqueryEverscaleMessageFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  messageBoc?: InputMaybe<BitqueryStringSelector>;
  messageBody?: InputMaybe<BitqueryStringSelector>;
  messageBodyHash?: InputMaybe<BitqueryStringSelector>;
  messageBounce?: InputMaybe<BitqueryBooleanSelector>;
  messageBounced?: InputMaybe<BitqueryBooleanSelector>;
  messageCreatedLogicalTime?: InputMaybe<BitqueryBigIntegerSelector>;
  messageData?: InputMaybe<BitqueryStringSelector>;
  messageDataHash?: InputMaybe<BitqueryStringSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageFwdFee?: InputMaybe<BitqueryFloatSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageIhrDisabled?: InputMaybe<BitqueryBooleanSelector>;
  messageIndex?: InputMaybe<BitqueryIntegerSelector>;
  messageIrbFee?: InputMaybe<BitqueryFloatSelector>;
  messageReceiver?: InputMaybe<BitqueryStringSelector>;
  messageSender?: InputMaybe<BitqueryStringSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};

export enum BitqueryEverscaleMessageMeasurable {
  /** Message boc */
  Boc = 'boc',
  /** Message body */
  Body = 'body',
  /** Message body hash */
  BodyHash = 'body_hash',
  /** Message bounce */
  Bounce = 'bounce',
  /** Message bounced */
  Bounced = 'bounced',
  /** Message created logical time */
  CreatedLogicalTime = 'created_logical_time',
  /** Message data */
  Data = 'data',
  /** Message data hash */
  DataHash = 'data_hash',
  /** Date */
  Date = 'date',
  /** Message fwd fee */
  FwdFee = 'fwd_fee',
  /** Hash of the the block */
  Hash = 'hash',
  /** Number of block in the blockhains */
  Height = 'height',
  /** Message Ihr Disabled */
  IhrDisabled = 'ihr_disabled',
  /** Message ihr fee */
  IhrFee = 'ihr_fee',
  /** Message direction */
  MessageDirection = 'message_direction',
  /** Message Hash */
  MessageHash = 'message_hash',
  /** Message Index */
  MessageIndex = 'message_index',
  /** Message receiver */
  MessageReceiver = 'message_receiver',
  /** Message sender */
  MessageSender = 'message_sender',
  /** Message Type Name */
  MessageTypeName = 'message_type_name',
  /** Message value */
  MessageValue = 'message_value',
  /** Previous Message */
  PreviousBlock = 'previous_block',
  /** Shard of block in the blockhains */
  Shard = 'shard',
  /** Number of sharded block block in the blockhains */
  ShardedBlock = 'sharded_block',
  /** Hash of the the sharded block block */
  ShardedBlockHash = 'sharded_block_hash',
  /** Shard of sharded block block in the blockhains */
  ShardedBlockShard = 'sharded_block_shard',
  /** Workchain of sharded block block in the blockhains */
  ShardedBlockWorkchain = 'sharded_block_workchain',
  /** Time */
  Time = 'time',
  /** Tx Account */
  TxAccount = 'tx_account',
  /** Tx Hash */
  TxHash = 'tx_hash',
  /** Tx Type */
  TxType = 'tx_type',
  /** Workchain of block in the blockhains */
  Workchain = 'workchain'
}

export enum BitqueryEverscaleMessageTypeNameEnum {
  /** ExtInt Message */
  ExtInt = 'ExtInt',
  /** ExtOut Message */
  ExtOut = 'ExtOut',
  /** Internal Message */
  Internal = 'Internal'
}

/** Select by message type name */
export type BitqueryEverscaleMessageTypeNameSelector = {
  /** Message type name in the list */
  in?: InputMaybe<Array<BitqueryEverscaleMessageTypeNameEnum>>;
  /** Message type name is */
  is?: InputMaybe<BitqueryEverscaleMessageTypeNameEnum>;
  /** Message type name not */
  not?: InputMaybe<BitqueryEverscaleMessageTypeNameEnum>;
  /** Message type name not in the list */
  notIn?: InputMaybe<Array<BitqueryEverscaleMessageTypeNameEnum>>;
};

export enum BitqueryEverscaleMessageUniq {
  /** Unique Number of Shards in the blockchains */
  BlockShard = 'block_shard',
  /** Unique Number of workchains in the blockchains */
  BlockWorkchain = 'block_workchain',
  /** Uniq dates count */
  Dates = 'dates',
  /** Unique Number of block in the blockchains */
  Height = 'height',
  /** Unique Number of Message Receivers */
  MessageReceiver = 'message_receiver',
  /** Unique Number of Message Senders */
  MessageSender = 'message_sender',
  /** Unique Number of Messages */
  Messages = 'messages',
  /** Unique Number of sharded block shards in the blockchains */
  ShardedBlockShards = 'sharded_block_shards',
  /** Unique Number of sharded block workchains in the blockchains */
  ShardedBlockWorkchains = 'sharded_block_workchains',
  /** Unique Number of sharded blocks in the blockchains */
  ShardedBlocks = 'sharded_blocks',
  /** Uniq times count */
  Times = 'times',
  /** Unique Number of transactions */
  Txs = 'txs'
}

export enum BitqueryEverscaleNetwork {
  /** Everscale */
  Everscale = 'everscale'
}

/** Phase in Everscale blockchain */
export type BitqueryEverscalePhase = {
  __typename?: 'BitqueryEverscalePhase';
  any?: Maybe<Scalars['String']['output']>;
  /** Hash of the the block */
  blockHash?: Maybe<Scalars['String']['output']>;
  /** Shard number of block */
  blockShard?: Maybe<Scalars['String']['output']>;
  /** Proposer block hash */
  blockWorkchain?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Phase data */
  data?: Maybe<Scalars['String']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  fee?: Maybe<Scalars['Float']['output']>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Previous Block */
  previousBlock?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Sharded Block Information */
  shardedBlock?: Maybe<BitqueryEverscaleShardedBlockDimension>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transactions */
  transactions?: Maybe<BitqueryEverscaleTransactionDimension>;
  /** Phase Type */
  type?: Maybe<Scalars['String']['output']>;
};


/** Phase in Everscale blockchain */
export type BitqueryEverscalePhaseAnyArgs = {
  of: BitqueryEverscalePhaseMeasurable;
};


/** Phase in Everscale blockchain */
export type BitqueryEverscalePhaseCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  phaseData?: InputMaybe<BitqueryStringSelector>;
  phaseFee?: InputMaybe<BitqueryFloatSelector>;
  phaseType?: InputMaybe<BitqueryStringSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryEverscalePhaseUniq>;
};


/** Phase in Everscale blockchain */
export type BitqueryEverscalePhaseCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  phaseData?: InputMaybe<BitqueryStringSelector>;
  phaseFee?: InputMaybe<BitqueryFloatSelector>;
  phaseType?: InputMaybe<BitqueryStringSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryEverscalePhaseUniq>;
};


/** Phase in Everscale blockchain */
export type BitqueryEverscalePhaseExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Phase in Everscale blockchain */
export type BitqueryEverscalePhaseFeeArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  phaseData?: InputMaybe<BitqueryStringSelector>;
  phaseFee?: InputMaybe<BitqueryFloatSelector>;
  phaseType?: InputMaybe<BitqueryStringSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};


/** Phase in Everscale blockchain */
export type BitqueryEverscalePhaseMaximumArgs = {
  get?: InputMaybe<BitqueryEverscalePhaseMeasurable>;
  of: BitqueryEverscalePhaseMeasurable;
};


/** Phase in Everscale blockchain */
export type BitqueryEverscalePhaseMinimumArgs = {
  get?: InputMaybe<BitqueryEverscalePhaseMeasurable>;
  of: BitqueryEverscalePhaseMeasurable;
};


/** Phase in Everscale blockchain */
export type BitqueryEverscalePhaseShardedBlockArgs = {
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  shard?: InputMaybe<BitqueryStringIdSelector>;
  workchain?: InputMaybe<BitqueryBigIntIdSelector>;
};


/** Phase in Everscale blockchain */
export type BitqueryEverscalePhaseTransactionsArgs = {
  txAborted?: InputMaybe<BitqueryBigIntIdSelector>;
  txAccount?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txType?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryEverscalePhaseFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  phaseData?: InputMaybe<BitqueryStringSelector>;
  phaseFee?: InputMaybe<BitqueryFloatSelector>;
  phaseType?: InputMaybe<BitqueryStringSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};

export enum BitqueryEverscalePhaseMeasurable {
  /** Date */
  Date = 'date',
  /** Hash of the the block */
  Hash = 'hash',
  /** Number of block in the blockhains */
  Height = 'height',
  /** Phase data */
  PhaseData = 'phase_data',
  /** Phase fee */
  PhaseFee = 'phase_fee',
  /** Phase type */
  PhaseType = 'phase_type',
  /** Previous Message */
  PreviousBlock = 'previous_block',
  /** Shard of block in the blockhains */
  Shard = 'shard',
  /** Number of sharded block block in the blockhains */
  ShardedBlock = 'sharded_block',
  /** Hash of the the sharded block block */
  ShardedBlockHash = 'sharded_block_hash',
  /** Shard of sharded block block in the blockhains */
  ShardedBlockShard = 'sharded_block_shard',
  /** Workchain of sharded block block in the blockhains */
  ShardedBlockWorkchain = 'sharded_block_workchain',
  /** Time */
  Time = 'time',
  /** Tx Account */
  TxAccount = 'tx_account',
  /** Tx Hash */
  TxHash = 'tx_hash',
  /** Tx Type */
  TxType = 'tx_type',
  /** Workchain of block in the blockhains */
  Workchain = 'workchain'
}

export enum BitqueryEverscalePhaseUniq {
  /** Unique Number of Shards in the blockchains */
  BlockShard = 'block_shard',
  /** Unique Number of workchains in the blockchains */
  BlockWorkchain = 'block_workchain',
  /** Uniq dates count */
  Dates = 'dates',
  /** Unique Number of block in the blockchains */
  Height = 'height',
  /** Unique Number of phases */
  Phases = 'phases',
  /** Unique Number of sharded block shards in the blockchains */
  ShardedBlockShards = 'sharded_block_shards',
  /** Unique Number of sharded block workchains in the blockchains */
  ShardedBlockWorkchains = 'sharded_block_workchains',
  /** Unique Number of sharded blocks in the blockchains */
  ShardedBlocks = 'sharded_blocks',
  /** Uniq times count */
  Times = 'times',
  /** Unique Number of transactions */
  Txs = 'txs'
}

/** Information about sharded block */
export type BitqueryEverscaleShardedBlockDimension = {
  __typename?: 'BitqueryEverscaleShardedBlockDimension';
  /** Hash of the the master block */
  hash?: Maybe<Scalars['String']['output']>;
  /** Number of master block in the blockchains */
  height?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Shard master number of block */
  shard?: Maybe<Scalars['String']['output']>;
  /** Workchain master block hash */
  workchain?: Maybe<Scalars['BitqueryBigInt']['output']>;
};

/** Transaction in Everscale blockchain */
export type BitqueryEverscaleTransaction = {
  __typename?: 'BitqueryEverscaleTransaction';
  /** Transaction Aborted */
  aborted?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction Account */
  account?: Maybe<Scalars['String']['output']>;
  accountFees?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Hash of the the block */
  blockHash?: Maybe<Scalars['String']['output']>;
  /** Shard number of block */
  blockShard?: Maybe<Scalars['String']['output']>;
  /** Proposer block hash */
  blockWorkchain?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Transaction Boc */
  boc?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Transaction Credit First */
  creditFirst?: Maybe<Scalars['Int']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Transaction Destroyed */
  destroyed?: Maybe<Scalars['Boolean']['output']>;
  /** The end state of an account after a transaction */
  endStatus?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Tx Ext In And Ihr In Fees */
  extInAndIhrInFees?: Maybe<Scalars['Float']['output']>;
  /** Transaction Hash */
  hash?: Maybe<Scalars['String']['output']>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Internal Message bounce flag */
  inMessageBounceFlag?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction Logical Time */
  logicalTime?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Transaction New Hash */
  newHash?: Maybe<Scalars['String']['output']>;
  /** Transaction Old Hash */
  oldHash?: Maybe<Scalars['String']['output']>;
  /** The initial state of account */
  originalStatus?: Maybe<Scalars['String']['output']>;
  /** Transaction Out Messages count */
  outMessagesCount?: Maybe<Scalars['Int']['output']>;
  /** Previous Block */
  previousBlock?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Transaction Out Messages count */
  previousTxHash?: Maybe<Scalars['String']['output']>;
  /** Transaction Previous Tx Logical Time */
  previousTxLogicalTime?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Sharded Block Information */
  shardedBlock?: Maybe<BitqueryEverscaleShardedBlockDimension>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction Type */
  type?: Maybe<Scalars['String']['output']>;
};


/** Transaction in Everscale blockchain */
export type BitqueryEverscaleTransactionAccountFeesArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  previousTxHash?: InputMaybe<BitqueryStringSelector>;
  previousTxLogicalTime?: InputMaybe<BitqueryBigIntegerSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryBooleanSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txAccountFees?: InputMaybe<BitqueryFloatSelector>;
  txCreditFirst?: InputMaybe<BitqueryBooleanSelector>;
  txDestroyed?: InputMaybe<BitqueryBooleanSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txExtInAndIhrInFees?: InputMaybe<BitqueryFloatSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txInMessageBounceFlag?: InputMaybe<BitqueryBooleanSelector>;
  txLogicalTime?: InputMaybe<BitqueryIntegerSelector>;
  txNewHash?: InputMaybe<BitqueryStringSelector>;
  txOldHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txOutMessagesCount?: InputMaybe<BitqueryIntegerSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction in Everscale blockchain */
export type BitqueryEverscaleTransactionAnyArgs = {
  of: BitqueryEverscaleTransactionMeasurable;
};


/** Transaction in Everscale blockchain */
export type BitqueryEverscaleTransactionCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  previousTxHash?: InputMaybe<BitqueryStringSelector>;
  previousTxLogicalTime?: InputMaybe<BitqueryBigIntegerSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryBooleanSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txAccountFees?: InputMaybe<BitqueryFloatSelector>;
  txCreditFirst?: InputMaybe<BitqueryBooleanSelector>;
  txDestroyed?: InputMaybe<BitqueryBooleanSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txExtInAndIhrInFees?: InputMaybe<BitqueryFloatSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txInMessageBounceFlag?: InputMaybe<BitqueryBooleanSelector>;
  txLogicalTime?: InputMaybe<BitqueryIntegerSelector>;
  txNewHash?: InputMaybe<BitqueryStringSelector>;
  txOldHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txOutMessagesCount?: InputMaybe<BitqueryIntegerSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryEverscaleTransactionUniq>;
};


/** Transaction in Everscale blockchain */
export type BitqueryEverscaleTransactionCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  previousTxHash?: InputMaybe<BitqueryStringSelector>;
  previousTxLogicalTime?: InputMaybe<BitqueryBigIntegerSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryBooleanSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txAccountFees?: InputMaybe<BitqueryFloatSelector>;
  txCreditFirst?: InputMaybe<BitqueryBooleanSelector>;
  txDestroyed?: InputMaybe<BitqueryBooleanSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txExtInAndIhrInFees?: InputMaybe<BitqueryFloatSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txInMessageBounceFlag?: InputMaybe<BitqueryBooleanSelector>;
  txLogicalTime?: InputMaybe<BitqueryIntegerSelector>;
  txNewHash?: InputMaybe<BitqueryStringSelector>;
  txOldHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txOutMessagesCount?: InputMaybe<BitqueryIntegerSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryEverscaleTransactionUniq>;
};


/** Transaction in Everscale blockchain */
export type BitqueryEverscaleTransactionExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transaction in Everscale blockchain */
export type BitqueryEverscaleTransactionMaximumArgs = {
  get?: InputMaybe<BitqueryEverscaleTransactionMeasurable>;
  of: BitqueryEverscaleTransactionMeasurable;
};


/** Transaction in Everscale blockchain */
export type BitqueryEverscaleTransactionMinimumArgs = {
  get?: InputMaybe<BitqueryEverscaleTransactionMeasurable>;
  of: BitqueryEverscaleTransactionMeasurable;
};


/** Transaction in Everscale blockchain */
export type BitqueryEverscaleTransactionShardedBlockArgs = {
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  shard?: InputMaybe<BitqueryStringIdSelector>;
  workchain?: InputMaybe<BitqueryBigIntIdSelector>;
};

/** Information about transaction */
export type BitqueryEverscaleTransactionDimension = {
  __typename?: 'BitqueryEverscaleTransactionDimension';
  /** Transaction Aborted */
  aborted?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction Account */
  account?: Maybe<Scalars['String']['output']>;
  /** The end state of an account after a transaction */
  endStatus?: Maybe<Scalars['String']['output']>;
  /** Transaction Hash */
  hash?: Maybe<Scalars['String']['output']>;
  /** The initial state of account */
  originalStatus?: Maybe<Scalars['String']['output']>;
  /** Transaction Type */
  type?: Maybe<Scalars['String']['output']>;
};

export type BitqueryEverscaleTransactionFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  previousTxHash?: InputMaybe<BitqueryStringSelector>;
  previousTxLogicalTime?: InputMaybe<BitqueryBigIntegerSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryBooleanSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txAccountFees?: InputMaybe<BitqueryFloatSelector>;
  txCreditFirst?: InputMaybe<BitqueryBooleanSelector>;
  txDestroyed?: InputMaybe<BitqueryBooleanSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txExtInAndIhrInFees?: InputMaybe<BitqueryFloatSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txInMessageBounceFlag?: InputMaybe<BitqueryBooleanSelector>;
  txLogicalTime?: InputMaybe<BitqueryIntegerSelector>;
  txNewHash?: InputMaybe<BitqueryStringSelector>;
  txOldHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txOutMessagesCount?: InputMaybe<BitqueryIntegerSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};

export enum BitqueryEverscaleTransactionMeasurable {
  /** Date */
  Date = 'date',
  /** Hash of the the block */
  Hash = 'hash',
  /** Number of block in the blockhains */
  Height = 'height',
  /** Previous Transaction */
  PreviousBlock = 'previous_block',
  /** Previous Tx Hash */
  PreviousTxHash = 'previous_tx_hash',
  /** Previous Tx Logical Time */
  PreviousTxLogicalTime = 'previous_tx_logical_time',
  /** Shard of block in the blockhains */
  Shard = 'shard',
  /** Number of sharded block block in the blockhains */
  ShardedBlock = 'sharded_block',
  /** Hash of the the sharded block block */
  ShardedBlockHash = 'sharded_block_hash',
  /** Shard of sharded block block in the blockhains */
  ShardedBlockShard = 'sharded_block_shard',
  /** Workchain of sharded block block in the blockhains */
  ShardedBlockWorkchain = 'sharded_block_workchain',
  /** Time */
  Time = 'time',
  /** Tx Account */
  TxAccount = 'tx_account',
  /** Tx Hash */
  TxHash = 'tx_hash',
  /** Tx New Hash */
  TxNewHash = 'tx_new_hash',
  /** Tx Old hash */
  TxOldHash = 'tx_old_hash',
  /** Tx Type */
  TxType = 'tx_type',
  /** Workchain of block in the blockhains */
  Workchain = 'workchain'
}

export enum BitqueryEverscaleTransactionUniq {
  /** Unique Number of Shards in the blockchains */
  BlockShard = 'block_shard',
  /** Unique Number of workchains in the blockchains */
  BlockWorkchain = 'block_workchain',
  /** Uniq dates count */
  Dates = 'dates',
  /** Unique Number of block in the blockchains */
  Height = 'height',
  /** Unique Number of sharded block shards in the blockchains */
  ShardedBlockShards = 'sharded_block_shards',
  /** Unique Number of sharded block workchains in the blockchains */
  ShardedBlockWorkchains = 'sharded_block_workchains',
  /** Unique Number of sharded blocks in the blockchains */
  ShardedBlocks = 'sharded_blocks',
  /** Uniq times count */
  Times = 'times',
  /** Unique Number of Transactions */
  Txs = 'txs'
}

/** Transfer in Everscale blockchain */
export type BitqueryEverscaleTransfer = {
  __typename?: 'BitqueryEverscaleTransfer';
  amount?: Maybe<Scalars['Float']['output']>;
  /** Input value as decimal */
  amountDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Hash of the the block */
  blockHash?: Maybe<Scalars['String']['output']>;
  /** Shard number of block */
  blockShard?: Maybe<Scalars['String']['output']>;
  /** Proposer block hash */
  blockWorkchain?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** NFT Id */
  entityId: Scalars['BitqueryBigInt']['output'];
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** messages */
  messages?: Maybe<BitqueryEverscaleMessageDimension>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Previous Block */
  previousBlock?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Transfer To */
  receiver: BitqueryAddress;
  /** Transfer From */
  sender: BitqueryAddress;
  /** Sharded Block Information */
  shardedBlock?: Maybe<BitqueryEverscaleShardedBlockDimension>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transactions */
  transactions?: Maybe<BitqueryEverscaleTransactionDimension>;
  /** Transfer type */
  transferType: Scalars['String']['output'];
};


/** Transfer in Everscale blockchain */
export type BitqueryEverscaleTransferAmountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transferReceiver?: InputMaybe<BitqueryStringSelector>;
  transferSender?: InputMaybe<BitqueryStringSelector>;
  transferType?: InputMaybe<BitqueryEverscaleTransferTypeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transfer in Everscale blockchain */
export type BitqueryEverscaleTransferAmountDecimalArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryBigIntIdSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transferReceiver?: InputMaybe<BitqueryStringSelector>;
  transferSender?: InputMaybe<BitqueryStringSelector>;
  transferType?: InputMaybe<BitqueryEverscaleTransferTypeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transfer in Everscale blockchain */
export type BitqueryEverscaleTransferAnyArgs = {
  of: BitqueryEverscaleTransferMeasurable;
};


/** Transfer in Everscale blockchain */
export type BitqueryEverscaleTransferCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryBigIntIdSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transferReceiver?: InputMaybe<BitqueryStringSelector>;
  transferSender?: InputMaybe<BitqueryStringSelector>;
  transferType?: InputMaybe<BitqueryEverscaleTransferTypeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryEverscaleTransferUniq>;
};


/** Transfer in Everscale blockchain */
export type BitqueryEverscaleTransferCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryBigIntIdSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transferReceiver?: InputMaybe<BitqueryStringSelector>;
  transferSender?: InputMaybe<BitqueryStringSelector>;
  transferType?: InputMaybe<BitqueryEverscaleTransferTypeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryEverscaleTransferUniq>;
};


/** Transfer in Everscale blockchain */
export type BitqueryEverscaleTransferExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transfer in Everscale blockchain */
export type BitqueryEverscaleTransferMaximumArgs = {
  get?: InputMaybe<BitqueryEverscaleTransferMeasurable>;
  of: BitqueryEverscaleTransferMeasurable;
};


/** Transfer in Everscale blockchain */
export type BitqueryEverscaleTransferMessagesArgs = {
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transfer in Everscale blockchain */
export type BitqueryEverscaleTransferMinimumArgs = {
  get?: InputMaybe<BitqueryEverscaleTransferMeasurable>;
  of: BitqueryEverscaleTransferMeasurable;
};


/** Transfer in Everscale blockchain */
export type BitqueryEverscaleTransferShardedBlockArgs = {
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  shard?: InputMaybe<BitqueryStringIdSelector>;
  workchain?: InputMaybe<BitqueryBigIntIdSelector>;
};


/** Transfer in Everscale blockchain */
export type BitqueryEverscaleTransferTransactionsArgs = {
  txAborted?: InputMaybe<BitqueryBigIntIdSelector>;
  txAccount?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txType?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryEverscaleTransferFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryBigIntIdSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transferReceiver?: InputMaybe<BitqueryStringSelector>;
  transferSender?: InputMaybe<BitqueryStringSelector>;
  transferType?: InputMaybe<BitqueryEverscaleTransferTypeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};

export enum BitqueryEverscaleTransferMeasurable {
  /** Currency Address */
  CurrencyAddress = 'currency_address',
  /** Currency Name */
  CurrencyName = 'currency_name',
  /** Currency Symbol */
  CurrencySymbol = 'currency_symbol',
  /** Date */
  Date = 'date',
  /** Hash of the the block */
  Hash = 'hash',
  /** Number of block in the blockhains */
  Height = 'height',
  /** Message direction */
  MessageDirection = 'message_direction',
  /** Message Hash */
  MessageHash = 'message_hash',
  /** Message receiver */
  MessageReceiver = 'message_receiver',
  /** Message sender */
  MessageSender = 'message_sender',
  /** Message type name */
  MessageTypeName = 'message_type_name',
  /** Message value */
  MessageValue = 'message_value',
  /** Previous Message */
  PreviousBlock = 'previous_block',
  /** Shard of block in the blockhains */
  Shard = 'shard',
  /** Number of sharded block block in the blockhains */
  ShardedBlock = 'sharded_block',
  /** Hash of the the sharded block block */
  ShardedBlockHash = 'sharded_block_hash',
  /** Shard of sharded block block in the blockhains */
  ShardedBlockShard = 'sharded_block_shard',
  /** Workchain of sharded block block in the blockhains */
  ShardedBlockWorkchain = 'sharded_block_workchain',
  /** Time */
  Time = 'time',
  /** Tx Aborted */
  TxAborted = 'tx_aborted',
  /** Tx Account */
  TxAccount = 'tx_account',
  /** Tx Hash */
  TxHash = 'tx_hash',
  /** Tx Type */
  TxType = 'tx_type',
  /** Value */
  Value = 'value',
  /** Workchain of block in the blockhains */
  Workchain = 'workchain'
}

export enum BitqueryEverscaleTransferTypeEnum {
  /** Token Burn */
  TokenBurn = 'token_burn',
  /** Token Mint */
  TokenMint = 'token_mint',
  /** Token Transfers */
  TokenTransfer = 'token_transfer',
  /** Transaction transfer */
  Transaction = 'transaction'
}

/** Select by message type name */
export type BitqueryEverscaleTransferTypeSelector = {
  /** Transfer type name in the list */
  in?: InputMaybe<Array<BitqueryEverscaleTransferTypeEnum>>;
  /** Transfer type name is */
  is?: InputMaybe<BitqueryEverscaleTransferTypeEnum>;
  /** Transfer type name not */
  not?: InputMaybe<BitqueryEverscaleTransferTypeEnum>;
  /** Transfer type name not in the list */
  notIn?: InputMaybe<Array<BitqueryEverscaleTransferTypeEnum>>;
};

export enum BitqueryEverscaleTransferUniq {
  /** Unique Number of Shards in the blockchains */
  BlockShard = 'block_shard',
  /** Unique Number of workchains in the blockchains */
  BlockWorkchain = 'block_workchain',
  /** Unique Number of currencies */
  Currencies = 'currencies',
  /** Uniq dates count */
  Dates = 'dates',
  /** Unique Number of block in the blockchains */
  Height = 'height',
  /** Unique Number of messages */
  Messages = 'messages',
  /** Unique Number of receivers */
  Receivers = 'receivers',
  /** Unique Number of senders */
  Senders = 'senders',
  /** Unique Number of sharded block shards in the blockchains */
  ShardedBlockShards = 'sharded_block_shards',
  /** Unique Number of sharded block workchains in the blockchains */
  ShardedBlockWorkchains = 'sharded_block_workchains',
  /** Unique Number of sharded blocks in the blockchains */
  ShardedBlocks = 'sharded_blocks',
  /** Uniq times count */
  Times = 'times',
  /** Unique Number of transactions */
  Txs = 'txs'
}

/** Value Block information */
export type BitqueryEverscaleValueDimension = {
  __typename?: 'BitqueryEverscaleValueDimension';
  /** Created */
  created?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Exported */
  exported?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Fees Collected */
  feesCollected?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Fees imported */
  feesImported?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** From Previous Block */
  fromPreviousBlock?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Imported */
  imported?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Minted */
  minted?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Value Flow To Next Block */
  toNextBlock?: Maybe<Scalars['BitqueryBigInt']['output']>;
};

/** Filecoin */
export type BitqueryFilecoin = {
  __typename?: 'BitqueryFilecoin';
  /** Basic information about address */
  address: Array<BitqueryFilecoinAddressInfoWithBalance>;
  /** Filecoin Network Blocks */
  blocks?: Maybe<Array<BitqueryFilecoinBlock>>;
  /** Filecoin Network Calls */
  calls?: Maybe<Array<BitqueryFilecoinCalls>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryFilecoinCoinpath>>;
  /** Filecoin Network Messages ( blocks, transfers, ... ) */
  messages?: Maybe<Array<BitqueryFilecoinMessages>>;
  /** Filecoin Network Currency Transfers */
  transfers?: Maybe<Array<BitqueryFilecoinTransfers>>;
};


/** Filecoin */
export type BitqueryFilecoinAddressArgs = {
  address: Array<BitqueryAddressSelectorIn>;
};


/** Filecoin */
export type BitqueryFilecoinBlocksArgs = {
  any?: InputMaybe<Array<BitqueryFilecoinBlockFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockIndex?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryAddressSelector>>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Filecoin */
export type BitqueryFilecoinCallsArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  any?: InputMaybe<Array<BitqueryFilecoinCallFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  messageMethod?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Filecoin */
export type BitqueryFilecoinCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCoinpathOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Filecoin */
export type BitqueryFilecoinMessagesArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  any?: InputMaybe<Array<BitqueryFilecoinMessageFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Filecoin */
export type BitqueryFilecoinTransfersArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  any?: InputMaybe<Array<BitqueryFilecoinTransferFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  messageMethod?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transferType?: InputMaybe<BitqueryTransferTypeSelector>;
};

/** Blockchain address */
export type BitqueryFilecoinAddressInfoWithBalance = {
  __typename?: 'BitqueryFilecoinAddressInfoWithBalance';
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Wallet balance */
  balance?: Maybe<Scalars['Float']['output']>;
};


/** Blockchain address */
export type BitqueryFilecoinAddressInfoWithBalanceBalanceArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};

/** Block */
export type BitqueryFilecoinBlock = {
  __typename?: 'BitqueryFilecoinBlock';
  any?: Maybe<Scalars['String']['output']>;
  blockSig?: Maybe<BitqueryNameWithId>;
  blsAggregate?: Maybe<BitqueryNameWithId>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  electionProof?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  forkSignalling?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Block hash */
  hash: Scalars['String']['output'];
  /** Block round in blockchain */
  height: Scalars['Int']['output'];
  /** Block index on height */
  index?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  messageCount?: Maybe<Scalars['Int']['output']>;
  messageCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  messages?: Maybe<Scalars['String']['output']>;
  /** Miner */
  miner?: Maybe<BitqueryAddress>;
  minerTips?: Maybe<Scalars['Float']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  parentMessageReceipts?: Maybe<Scalars['String']['output']>;
  parentStateRoot?: Maybe<Scalars['String']['output']>;
  parentWeight?: Maybe<Scalars['BitqueryBigInt']['output']>;
  reward?: Maybe<Scalars['Float']['output']>;
  ticket?: Maybe<Scalars['String']['output']>;
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  totalReward?: Maybe<Scalars['Float']['output']>;
  winCount?: Maybe<Scalars['Int']['output']>;
  winCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  wincount?: Maybe<Scalars['Int']['output']>;
};


/** Block */
export type BitqueryFilecoinBlockAnyArgs = {
  of: BitqueryFilecoinBlocksMeasureable;
};


/** Block */
export type BitqueryFilecoinBlockCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockIndex?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryFilecoinBlockUniq>;
};


/** Block */
export type BitqueryFilecoinBlockCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockIndex?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryFilecoinBlockUniq>;
};


/** Block */
export type BitqueryFilecoinBlockExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Block */
export type BitqueryFilecoinBlockHashArgs = {
  blockHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Block */
export type BitqueryFilecoinBlockHeightArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Block */
export type BitqueryFilecoinBlockIndexArgs = {
  blockIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Block */
export type BitqueryFilecoinBlockMaximumArgs = {
  get?: InputMaybe<BitqueryFilecoinBlocksMeasureable>;
  of: BitqueryFilecoinBlocksMeasureable;
};


/** Block */
export type BitqueryFilecoinBlockMessageCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockIndex?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Block */
export type BitqueryFilecoinBlockMessageCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockIndex?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Block */
export type BitqueryFilecoinBlockMinerArgs = {
  miner?: InputMaybe<BitqueryAddressSelector>;
};


/** Block */
export type BitqueryFilecoinBlockMinerTipsArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockIndex?: InputMaybe<BitqueryIntegerSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  miner?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Block */
export type BitqueryFilecoinBlockMinimumArgs = {
  get?: InputMaybe<BitqueryFilecoinBlocksMeasureable>;
  of: BitqueryFilecoinBlocksMeasureable;
};


/** Block */
export type BitqueryFilecoinBlockRewardArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockIndex?: InputMaybe<BitqueryIntegerSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  miner?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Block */
export type BitqueryFilecoinBlockTimestampArgs = {
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Block */
export type BitqueryFilecoinBlockTotalRewardArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockIndex?: InputMaybe<BitqueryIntegerSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  miner?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Block */
export type BitqueryFilecoinBlockWinCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockIndex?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Block */
export type BitqueryFilecoinBlockWinCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockIndex?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

export type BitqueryFilecoinBlockFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockIndex?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

export enum BitqueryFilecoinBlockUniq {
  /** Unique block count */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates',
  /** Unique block height count */
  Heights = 'heights',
  /** Miner */
  Miners = 'miners'
}

export enum BitqueryFilecoinBlocksMeasureable {
  /** Block */
  Block = 'block',
  /** Block hash */
  BlockHash = 'block_hash',
  /** Date */
  Date = 'date',
  /** Block Miner */
  Miner = 'miner',
  /** Time */
  Time = 'time'
}

export type BitqueryFilecoinCallFilter = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  messageMethod?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

/** Calls in Filecoin blockchain */
export type BitqueryFilecoinCalls = {
  __typename?: 'BitqueryFilecoinCalls';
  amount?: Maybe<Scalars['Float']['output']>;
  /** Amount as decimal */
  amountDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer Message is included */
  block?: Maybe<BitqueryBlock>;
  /** Call hash */
  callHash?: Maybe<Scalars['String']['output']>;
  /** Call hash */
  callPath?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  exitCode?: Maybe<Scalars['BitqueryBigInt']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  gas?: Maybe<Scalars['Int']['output']>;
  gasFeeCap?: Maybe<Scalars['BitqueryBigInt']['output']>;
  gasLimit?: Maybe<Scalars['BitqueryBigInt']['output']>;
  gasPremium?: Maybe<Scalars['Float']['output']>;
  /** Message hash */
  hash?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Message Method */
  messageMethod?: Maybe<BitqueryNameWithId>;
  /** Method */
  method?: Maybe<BitqueryNameWithId>;
  minedBlock?: Maybe<BitqueryFilecoinMinedBlock>;
  minimum?: Maybe<Scalars['String']['output']>;
  nonce?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Message receiver */
  receiver?: Maybe<BitqueryAddressWithAccount>;
  returnValue?: Maybe<Scalars['String']['output']>;
  /** Message sender */
  sender?: Maybe<BitqueryAddressWithAccount>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
};


/** Calls in Filecoin blockchain */
export type BitqueryFilecoinCallsAmountArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  messageMethod?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Calls in Filecoin blockchain */
export type BitqueryFilecoinCallsAmountDecimalArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  messageMethod?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Calls in Filecoin blockchain */
export type BitqueryFilecoinCallsAnyArgs = {
  of: BitqueryFilecoinCallsMeasureable;
};


/** Calls in Filecoin blockchain */
export type BitqueryFilecoinCallsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Calls in Filecoin blockchain */
export type BitqueryFilecoinCallsCountArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  messageMethod?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryFilecoinMessagesUniq>;
};


/** Calls in Filecoin blockchain */
export type BitqueryFilecoinCallsCountBigIntArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  messageMethod?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryFilecoinMessagesUniq>;
};


/** Calls in Filecoin blockchain */
export type BitqueryFilecoinCallsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Calls in Filecoin blockchain */
export type BitqueryFilecoinCallsGasArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Calls in Filecoin blockchain */
export type BitqueryFilecoinCallsHashArgs = {
  hash?: InputMaybe<BitqueryHashSelector>;
};


/** Calls in Filecoin blockchain */
export type BitqueryFilecoinCallsMaximumArgs = {
  get?: InputMaybe<BitqueryFilecoinCallsMeasureable>;
  of: BitqueryFilecoinCallsMeasureable;
};


/** Calls in Filecoin blockchain */
export type BitqueryFilecoinCallsMessageMethodArgs = {
  messageMethod?: InputMaybe<BitqueryIntegerSelector>;
};


/** Calls in Filecoin blockchain */
export type BitqueryFilecoinCallsMethodArgs = {
  method?: InputMaybe<BitqueryIntegerSelector>;
};


/** Calls in Filecoin blockchain */
export type BitqueryFilecoinCallsMinimumArgs = {
  get?: InputMaybe<BitqueryFilecoinCallsMeasureable>;
  of: BitqueryFilecoinCallsMeasureable;
};


/** Calls in Filecoin blockchain */
export type BitqueryFilecoinCallsReceiverArgs = {
  receiver?: InputMaybe<BitqueryAddressSelector>;
};


/** Calls in Filecoin blockchain */
export type BitqueryFilecoinCallsSenderArgs = {
  sender?: InputMaybe<BitqueryAddressSelector>;
};


/** Calls in Filecoin blockchain */
export type BitqueryFilecoinCallsSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum BitqueryFilecoinCallsMeasureable {
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Gas used */
  Gas = 'gas',
  /** Gas limit */
  GasLimit = 'gas_limit',
  /** Gas value */
  GasValue = 'gas_value',
  /** Message hash */
  MessageHash = 'message_hash',
  /** Time */
  Time = 'time'
}

/** Coinpath */
export type BitqueryFilecoinCoinpath = {
  __typename?: 'BitqueryFilecoinCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Message of transfer happened */
  message?: Maybe<BitqueryTransactionHashValue>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryAddress>;
};


/** Coinpath */
export type BitqueryFilecoinCoinpathAmountArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Coinpath */
export type BitqueryFilecoinCoinpathAnyArgs = {
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryFilecoinCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryFilecoinCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};

export type BitqueryFilecoinMessageFilter = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessages = {
  __typename?: 'BitqueryFilecoinMessages';
  amount?: Maybe<Scalars['Float']['output']>;
  /** Amount as decimal */
  amountDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  baseFeeBurn?: Maybe<Scalars['Float']['output']>;
  baseFeeBurnDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  /** Block where transfer Message is included */
  block?: Maybe<BitqueryBlock>;
  burned?: Maybe<Scalars['Float']['output']>;
  burnedDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  exitCode?: Maybe<Scalars['BitqueryBigInt']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  gas?: Maybe<Scalars['Int']['output']>;
  gasBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  gasFeeCap?: Maybe<Scalars['BitqueryBigInt']['output']>;
  gasLimit?: Maybe<Scalars['BitqueryBigInt']['output']>;
  gasPremium?: Maybe<Scalars['Float']['output']>;
  /** Message hash */
  hash?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Method */
  method?: Maybe<BitqueryNameWithId>;
  minedBlock?: Maybe<BitqueryFilecoinMinedBlock>;
  minerPenalty?: Maybe<Scalars['Float']['output']>;
  minerPenaltyDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  minerTip?: Maybe<Scalars['Float']['output']>;
  minerTipDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  nonce?: Maybe<Scalars['BitqueryBigInt']['output']>;
  overEstimationBurn?: Maybe<Scalars['Float']['output']>;
  overEstimationBurnDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  /** Message receiver */
  receiver?: Maybe<BitqueryAddressWithAccount>;
  refund?: Maybe<Scalars['Float']['output']>;
  refundDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  returnValue?: Maybe<Scalars['String']['output']>;
  /** Message sender */
  sender?: Maybe<BitqueryAddressWithAccount>;
  signature?: Maybe<Scalars['String']['output']>;
  signatureType?: Maybe<Scalars['String']['output']>;
  /** Signed Message hash */
  signedHash?: Maybe<Scalars['String']['output']>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  totalCost?: Maybe<Scalars['Float']['output']>;
  totalCostDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesAmountArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesAmountDecimalArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesAnyArgs = {
  of: BitqueryFilecoinMessagesMeasureable;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesBaseFeeBurnArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesBaseFeeBurnDecimalArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesBurnedArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesBurnedDecimalArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesCountArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryFilecoinMessagesUniq>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesCountBigIntArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryFilecoinMessagesUniq>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesGasArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesGasBigIntArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesHashArgs = {
  hash?: InputMaybe<BitqueryHashSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesMaximumArgs = {
  get?: InputMaybe<BitqueryFilecoinMessagesMeasureable>;
  of: BitqueryFilecoinMessagesMeasureable;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesMethodArgs = {
  method?: InputMaybe<BitqueryIntegerSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesMinerPenaltyArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesMinerPenaltyDecimalArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesMinerTipArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesMinerTipDecimalArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesMinimumArgs = {
  get?: InputMaybe<BitqueryFilecoinMessagesMeasureable>;
  of: BitqueryFilecoinMessagesMeasureable;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesOverEstimationBurnArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesOverEstimationBurnDecimalArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesReceiverArgs = {
  receiver?: InputMaybe<BitqueryAddressSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesRefundArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesRefundDecimalArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesSenderArgs = {
  sender?: InputMaybe<BitqueryAddressSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesTotalCostArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesTotalCostDecimalArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

export enum BitqueryFilecoinMessagesMeasureable {
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Gas used */
  Gas = 'gas',
  /** Gas limit */
  GasLimit = 'gas_limit',
  /** Gas value */
  GasValue = 'gas_value',
  /** Message hash */
  MessageHash = 'message_hash',
  /** Time */
  Time = 'time'
}

export enum BitqueryFilecoinMessagesUniq {
  /** Unique block heights */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates',
  /** Unique Message receivers */
  Receivers = 'receivers',
  /** Unique Message senders */
  Senders = 'senders'
}

/** Filecoin Mined Block */
export type BitqueryFilecoinMinedBlock = {
  __typename?: 'BitqueryFilecoinMinedBlock';
  /** Hash */
  hash?: Maybe<Scalars['String']['output']>;
  /** Index on height */
  index?: Maybe<Scalars['Int']['output']>;
  /** Miner */
  miner?: Maybe<BitqueryAddress>;
};

export enum BitqueryFilecoinNetwork {
  /** Filecoin Mainnet */
  Filecoin = 'filecoin'
}

export type BitqueryFilecoinTransferFilter = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  messageMethod?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transferType?: InputMaybe<BitqueryTransferTypeSelector>;
};

export enum BitqueryFilecoinTransferType {
  /** Burn */
  Burn = 'burn',
  /** Genesis */
  Genesis = 'genesis',
  /** Miner Tip */
  Miner = 'miner',
  /** Rebalance */
  Rebalance = 'rebalance',
  /** Reward */
  Reward = 'reward',
  /** Send (transfer) */
  Send = 'send'
}

/** Transfers in Filecoin blockchain */
export type BitqueryFilecoinTransfers = {
  __typename?: 'BitqueryFilecoinTransfers';
  amount?: Maybe<Scalars['Float']['output']>;
  /** Amount as decimal */
  amountDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer Transfer is included */
  block?: Maybe<BitqueryBlockExtended>;
  /** Call hash */
  callHash?: Maybe<Scalars['String']['output']>;
  /** Call hash */
  callPath?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Message hash */
  hash?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Message Method */
  messageMethod?: Maybe<BitqueryNameWithId>;
  /** Method */
  method?: Maybe<BitqueryNameWithId>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Transfer receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Transfer sender */
  sender?: Maybe<BitqueryAddress>;
  /** Transfer timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Type of transfer */
  transferType?: Maybe<BitqueryFilecoinTransferType>;
};


/** Transfers in Filecoin blockchain */
export type BitqueryFilecoinTransfersAmountArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  messageMethod?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transferType?: InputMaybe<BitqueryTransferTypeSelector>;
};


/** Transfers in Filecoin blockchain */
export type BitqueryFilecoinTransfersAmountDecimalArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  messageMethod?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transferType?: InputMaybe<BitqueryTransferTypeSelector>;
};


/** Transfers in Filecoin blockchain */
export type BitqueryFilecoinTransfersAnyArgs = {
  of: BitqueryFilecoinTransfersMeasureable;
};


/** Transfers in Filecoin blockchain */
export type BitqueryFilecoinTransfersBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transfers in Filecoin blockchain */
export type BitqueryFilecoinTransfersCountArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  messageMethod?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transferType?: InputMaybe<BitqueryTransferTypeSelector>;
  uniq?: InputMaybe<BitqueryFilecoinMessagesUniq>;
};


/** Transfers in Filecoin blockchain */
export type BitqueryFilecoinTransfersCountBigIntArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  messageMethod?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transferType?: InputMaybe<BitqueryTransferTypeSelector>;
  uniq?: InputMaybe<BitqueryFilecoinMessagesUniq>;
};


/** Transfers in Filecoin blockchain */
export type BitqueryFilecoinTransfersExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transfers in Filecoin blockchain */
export type BitqueryFilecoinTransfersHashArgs = {
  hash?: InputMaybe<BitqueryHashSelector>;
};


/** Transfers in Filecoin blockchain */
export type BitqueryFilecoinTransfersMaximumArgs = {
  get?: InputMaybe<BitqueryFilecoinTransfersMeasureable>;
  of: BitqueryFilecoinTransfersMeasureable;
};


/** Transfers in Filecoin blockchain */
export type BitqueryFilecoinTransfersMessageMethodArgs = {
  messageMethod?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transfers in Filecoin blockchain */
export type BitqueryFilecoinTransfersMethodArgs = {
  method?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transfers in Filecoin blockchain */
export type BitqueryFilecoinTransfersMinimumArgs = {
  get?: InputMaybe<BitqueryFilecoinTransfersMeasureable>;
  of: BitqueryFilecoinTransfersMeasureable;
};


/** Transfers in Filecoin blockchain */
export type BitqueryFilecoinTransfersReceiverArgs = {
  receiver?: InputMaybe<BitqueryAddressSelector>;
};


/** Transfers in Filecoin blockchain */
export type BitqueryFilecoinTransfersSenderArgs = {
  sender?: InputMaybe<BitqueryAddressSelector>;
};


/** Transfers in Filecoin blockchain */
export type BitqueryFilecoinTransfersTimestampArgs = {
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transfers in Filecoin blockchain */
export type BitqueryFilecoinTransfersTransferTypeArgs = {
  transferType?: InputMaybe<BitqueryTransferTypeSelector>;
};

export enum BitqueryFilecoinTransfersMeasureable {
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Block hash */
  BlockHash = 'block_hash',
  /** Currency Name */
  CurrencyName = 'currency_name',
  /** Currency Symbol */
  CurrencySymbol = 'currency_symbol',
  /** Date */
  Date = 'date',
  /** Message hash */
  MessageHash = 'message_hash',
  /** Time */
  Time = 'time',
  /** Token ID */
  TokenId = 'token_id',
  /** Token Type */
  TokenType = 'token_type'
}

/** Select by number */
export type BitqueryFloatSelector = {
  /** in range */
  between?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** greater than */
  gt?: InputMaybe<Scalars['Float']['input']>;
  /** greater or equal than */
  gteq?: InputMaybe<Scalars['Float']['input']>;
  /** in the list */
  in?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** is */
  is?: InputMaybe<Scalars['Float']['input']>;
  /** less than */
  lt?: InputMaybe<Scalars['Float']['input']>;
  /** less or equal than */
  lteq?: InputMaybe<Scalars['Float']['input']>;
  /** not */
  not?: InputMaybe<Scalars['Float']['input']>;
  /** not in the list */
  notIn?: InputMaybe<Array<Scalars['Float']['input']>>;
};

/** Flow Chain */
export type BitqueryFlow = {
  __typename?: 'BitqueryFlow';
  /** Basic information about address */
  address: Array<BitqueryFlowAddressInfoWithBalance>;
  /** The outermost portion of the transaction, which contains the payload and envelope signatures */
  arguments?: Maybe<Array<BitqueryFlowArgument>>;
  /**
   * A block seal is an attestation that the execution result of a specific block has
   *                    been verified and approved by a quorum of verification nodes.
   */
  blockSeals?: Maybe<Array<BitqueryFlowBlockSeal>>;
  /** Full block information. */
  blocks?: Maybe<Array<BitqueryFlowBlock>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryFlowCoinpath>>;
  /** A collection is a batch of transactions that have been includes in a block. */
  collections?: Maybe<Array<BitqueryFlowCollection>>;
  /** Event fields */
  eventFields?: Maybe<Array<BitqueryFlowEventField>>;
  /**
   * An event is emitted as the result of a transaction execution.
   *         Events are either user-defined events originating from a Cadence smart contract, or built-in Flow system events.
   */
  events?: Maybe<Array<BitqueryFlowEvent>>;
  /** Blockchain Transaction Inputs */
  inputs?: Maybe<Array<BitqueryFlowInput>>;
  /** Blockchain Transaction Outputs */
  outputs?: Maybe<Array<BitqueryFlowOutput>>;
  /** List of transaction authorizers */
  transactionAuthorizers?: Maybe<Array<BitqueryFlowTransactionAuthorizer>>;
  /** The outermost portion of the transaction, which contains the payload and envelope signatures */
  transactionEnvelopeSignatures?: Maybe<Array<BitqueryFlowTransactionEnvelopeSignature>>;
  /**
   * The transaction authorization envelope contains both the
   *                    transaction payload and the payload signatures.
   */
  transactionPayloadSignatures?: Maybe<Array<BitqueryFlowTransactionPayloadSignature>>;
  /** A transaction represents a unit of computation that is submitted to the Flow network. */
  transactions?: Maybe<Array<BitqueryFlowTransaction>>;
};


/** Flow Chain */
export type BitqueryFlowAddressArgs = {
  address: Array<BitqueryAddressSelectorIn>;
};


/** Flow Chain */
export type BitqueryFlowArgumentsArgs = {
  any?: InputMaybe<Array<BitqueryFlowArgumentFilter>>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  value?: InputMaybe<BitqueryStringSelector>;
  valueAsFix?: InputMaybe<BitqueryIntegerSelector>;
  valueAsInt?: InputMaybe<BitqueryIntegerSelector>;
};


/** Flow Chain */
export type BitqueryFlowBlockSealsArgs = {
  any?: InputMaybe<Array<BitqueryFlowBlockSealFilter>>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  blockSealId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  executionReceiptId?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Flow Chain */
export type BitqueryFlowBlocksArgs = {
  any?: InputMaybe<Array<BitqueryFlowBlockFilter>>;
  collectionsCount?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  id?: InputMaybe<BitqueryHashSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  parentBlockId?: InputMaybe<BitqueryHashSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionsCount?: InputMaybe<BitqueryIntegerSelector>;
};


/** Flow Chain */
export type BitqueryFlowCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCoinpathOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Flow Chain */
export type BitqueryFlowCollectionsArgs = {
  any?: InputMaybe<Array<BitqueryFlowCollectionFilter>>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  collectionId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionsCount?: InputMaybe<BitqueryIntegerSelector>;
};


/** Flow Chain */
export type BitqueryFlowEventFieldsArgs = {
  any?: InputMaybe<Array<BitqueryFlowEventFieldFilter>>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  eventIndex?: InputMaybe<BitqueryIntegerSelector>;
  fieldAsFix?: InputMaybe<BitqueryIntegerSelector>;
  fieldAsInt?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  smartContractAddress?: InputMaybe<BitqueryStringSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Flow Chain */
export type BitqueryFlowEventsArgs = {
  any?: InputMaybe<Array<BitqueryFlowEventFilter>>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  smartContractAddress?: InputMaybe<BitqueryStringSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Flow Chain */
export type BitqueryFlowInputsArgs = {
  address?: InputMaybe<BitqueryStringSelector>;
  any?: InputMaybe<Array<BitqueryFlowInputFilter>>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryBigIntIdSelector>;
  eventIndex?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  smartContractAddress?: InputMaybe<BitqueryStringSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
  transferReason?: InputMaybe<BitqueryFlowTransferReasonSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Flow Chain */
export type BitqueryFlowOutputsArgs = {
  address?: InputMaybe<BitqueryStringSelector>;
  any?: InputMaybe<Array<BitqueryFlowOutputFilter>>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryBigIntIdSelector>;
  eventIndex?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  smartContractAddress?: InputMaybe<BitqueryStringSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
  transferReason?: InputMaybe<BitqueryFlowTransferReasonSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Flow Chain */
export type BitqueryFlowTransactionAuthorizersArgs = {
  any?: InputMaybe<Array<BitqueryFlowTransactionAuthorizerFilter>>;
  authorizer?: InputMaybe<BitqueryAddressSelector>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  collectionId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  eventsCount?: InputMaybe<BitqueryIntegerSelector>;
  gasLimit?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  indexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  payer?: InputMaybe<BitqueryAddressSelector>;
  proposalKeyId?: InputMaybe<BitqueryIntegerSelector>;
  proposalKeySequenceNumber?: InputMaybe<BitqueryIntegerSelector>;
  proposer?: InputMaybe<BitqueryAddressSelector>;
  referenceBlockId?: InputMaybe<BitqueryStringSelector>;
  statusCode?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
};


/** Flow Chain */
export type BitqueryFlowTransactionEnvelopeSignaturesArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  any?: InputMaybe<Array<BitqueryFlowTransactionEnvelopeSignatureFilter>>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  collectionId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  eventsCount?: InputMaybe<BitqueryIntegerSelector>;
  gasLimit?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  indexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  keyId?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  payer?: InputMaybe<BitqueryAddressSelector>;
  proposalKeyId?: InputMaybe<BitqueryIntegerSelector>;
  proposalKeySequenceNumber?: InputMaybe<BitqueryIntegerSelector>;
  proposer?: InputMaybe<BitqueryAddressSelector>;
  referenceBlockId?: InputMaybe<BitqueryStringSelector>;
  signature?: InputMaybe<BitqueryStringSelector>;
  statusCode?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
};


/** Flow Chain */
export type BitqueryFlowTransactionPayloadSignaturesArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  any?: InputMaybe<Array<BitqueryFlowTransactionPayloadSignatureFilter>>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  collectionId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  eventsCount?: InputMaybe<BitqueryIntegerSelector>;
  gasLimit?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  indexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  keyId?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  payer?: InputMaybe<BitqueryAddressSelector>;
  proposalKeyId?: InputMaybe<BitqueryIntegerSelector>;
  proposalKeySequenceNumber?: InputMaybe<BitqueryIntegerSelector>;
  proposer?: InputMaybe<BitqueryAddressSelector>;
  referenceBlockId?: InputMaybe<BitqueryStringSelector>;
  signature?: InputMaybe<BitqueryStringSelector>;
  statusCode?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
};


/** Flow Chain */
export type BitqueryFlowTransactionsArgs = {
  any?: InputMaybe<Array<BitqueryFlowTransactionFilter>>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  collectionId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  eventsCount?: InputMaybe<BitqueryIntegerSelector>;
  gasLimit?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  indexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  payer?: InputMaybe<BitqueryAddressSelector>;
  proposalKeyId?: InputMaybe<BitqueryIntegerSelector>;
  proposalKeySequenceNumber?: InputMaybe<BitqueryIntegerSelector>;
  proposer?: InputMaybe<BitqueryAddressSelector>;
  referenceBlockId?: InputMaybe<BitqueryStringSelector>;
  statusCode?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
};

/** Blockchain address */
export type BitqueryFlowAddressInfoWithBalance = {
  __typename?: 'BitqueryFlowAddressInfoWithBalance';
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** FLOW currency balance */
  balance?: Maybe<Scalars['Float']['output']>;
};


/** Blockchain address */
export type BitqueryFlowAddressInfoWithBalanceBalanceArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};

/** Arguments in Flow blockchain */
export type BitqueryFlowArgument = {
  __typename?: 'BitqueryFlowArgument';
  any?: Maybe<Scalars['String']['output']>;
  /** Block information */
  block: BitqueryFlowBlockDimension;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Index of the argument inside transaction */
  index: Scalars['Int']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Transaction information */
  transaction: BitqueryFlowMinorTransactionDimension;
  /** Type of field, e.g. UInt64, String, Bool, etc.. */
  type: Scalars['String']['output'];
  /** Value */
  value: Scalars['String']['output'];
  valueAsFix?: Maybe<Scalars['Float']['output']>;
  /** Value converted to integer */
  valueAsInt: Scalars['Int']['output'];
};


/** Arguments in Flow blockchain */
export type BitqueryFlowArgumentAnyArgs = {
  of: BitqueryFlowArgumentMeasureable;
};


/** Arguments in Flow blockchain */
export type BitqueryFlowArgumentBlockArgs = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Arguments in Flow blockchain */
export type BitqueryFlowArgumentCountArgs = {
  uniq?: InputMaybe<BitqueryFlowArgumentUniq>;
};


/** Arguments in Flow blockchain */
export type BitqueryFlowArgumentCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryFlowArgumentUniq>;
};


/** Arguments in Flow blockchain */
export type BitqueryFlowArgumentExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Arguments in Flow blockchain */
export type BitqueryFlowArgumentMaximumArgs = {
  get?: InputMaybe<BitqueryFlowArgumentMeasureable>;
  of: BitqueryFlowArgumentMeasureable;
};


/** Arguments in Flow blockchain */
export type BitqueryFlowArgumentMinimumArgs = {
  get?: InputMaybe<BitqueryFlowArgumentMeasureable>;
  of: BitqueryFlowArgumentMeasureable;
};


/** Arguments in Flow blockchain */
export type BitqueryFlowArgumentTransactionArgs = {
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
};


/** Arguments in Flow blockchain */
export type BitqueryFlowArgumentValueAsFixArgs = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  value?: InputMaybe<BitqueryStringSelector>;
  valueAsFix?: InputMaybe<BitqueryIntegerSelector>;
  valueAsInt?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryFlowArgumentFilter = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  value?: InputMaybe<BitqueryStringSelector>;
  valueAsFix?: InputMaybe<BitqueryIntegerSelector>;
  valueAsInt?: InputMaybe<BitqueryIntegerSelector>;
};

export enum BitqueryFlowArgumentMeasureable {
  /** Hash of the the block */
  BlockId = 'block_id',
  /** Date */
  Date = 'date',
  /** Number of block in the blockhains */
  Height = 'height',
  /** Time */
  Time = 'time',
  /** ID transaction */
  TransactionId = 'transaction_id',
  /** Type */
  Type = 'type',
  /** Value */
  Value = 'value',
  /** Value with UFix64 type and converted to integer */
  ValueAsFix = 'value_as_fix'
}

export enum BitqueryFlowArgumentUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique Number of block in the blockchains */
  Height = 'height',
  /** Unique time */
  Times = 'times',
  /** Unique Number of transactions */
  Transactions = 'transactions'
}

/** Block in Flow blockchain */
export type BitqueryFlowBlock = {
  __typename?: 'BitqueryFlowBlock';
  any?: Maybe<Scalars['String']['output']>;
  /** 	BLS signatures of consensus nodes */
  blockSignatures?: Maybe<Array<Scalars['String']['output']>>;
  /** Count of collections */
  collectionsCount?: Maybe<Scalars['Int']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Height of the block in the chain */
  height?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** SHA3-256 hash of the entire block payload */
  id?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** ID of the previous block in the chain */
  parentBlockId?: Maybe<Scalars['String']['output']>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Count of transactions */
  transactionsCount?: Maybe<Scalars['Int']['output']>;
};


/** Block in Flow blockchain */
export type BitqueryFlowBlockAnyArgs = {
  of: BitqueryFlowBlockMeasureable;
};


/** Block in Flow blockchain */
export type BitqueryFlowBlockCountArgs = {
  uniq?: InputMaybe<BitqueryFlowBlockUniq>;
};


/** Block in Flow blockchain */
export type BitqueryFlowBlockCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryFlowBlockUniq>;
};


/** Block in Flow blockchain */
export type BitqueryFlowBlockExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Block in Flow blockchain */
export type BitqueryFlowBlockMaximumArgs = {
  get?: InputMaybe<BitqueryFlowBlockMeasureable>;
  of: BitqueryFlowBlockMeasureable;
};


/** Block in Flow blockchain */
export type BitqueryFlowBlockMinimumArgs = {
  get?: InputMaybe<BitqueryFlowBlockMeasureable>;
  of: BitqueryFlowBlockMeasureable;
};

export type BitqueryFlowBlockDimension = {
  __typename?: 'BitqueryFlowBlockDimension';
  /** Height of the block in the chain */
  height?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** SHA3-256 hash of the entire block payload */
  id?: Maybe<Scalars['String']['output']>;
};

export type BitqueryFlowBlockFilter = {
  collectionsCount?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  id?: InputMaybe<BitqueryHashSelector>;
  parentBlockId?: InputMaybe<BitqueryHashSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionsCount?: InputMaybe<BitqueryIntegerSelector>;
};

export enum BitqueryFlowBlockMeasureable {
  /** Count of collections */
  CollectionsCount = 'collections_count',
  /** Date */
  Date = 'date',
  /** Height of the block in the chain */
  Height = 'height',
  /** SHA3-256 hash of the entire block payload */
  Id = 'id',
  /** ID of the previous block in the chain */
  ParentBlockId = 'parent_block_id',
  /** Time */
  Time = 'time',
  /** Count of transactions */
  TransactionsCount = 'transactions_count'
}

/** Block seals in Flow blockchain */
export type BitqueryFlowBlockSeal = {
  __typename?: 'BitqueryFlowBlockSeal';
  any?: Maybe<Scalars['String']['output']>;
  /** Block information */
  block: BitqueryFlowBlockDimension;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  /** ID execution receipt being sealed */
  executionReceiptId?: Maybe<Scalars['String']['output']>;
  /** BLS signatures of verification nodes on the execution receipt contents */
  executionReceiptSignatures?: Maybe<Array<Scalars['String']['output']>>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Index inside block */
  index?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** BLS signatures of verification nodes on the result approval contents */
  resultApprovalSignatures?: Maybe<Array<Scalars['String']['output']>>;
  /** ID of the block being sealed */
  sealId?: Maybe<Scalars['String']['output']>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
};


/** Block seals in Flow blockchain */
export type BitqueryFlowBlockSealAnyArgs = {
  of: BitqueryFlowBlockSealsMeasureable;
};


/** Block seals in Flow blockchain */
export type BitqueryFlowBlockSealBlockArgs = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Block seals in Flow blockchain */
export type BitqueryFlowBlockSealCountArgs = {
  uniq?: InputMaybe<BitqueryFlowBlockSealUniq>;
};


/** Block seals in Flow blockchain */
export type BitqueryFlowBlockSealCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryFlowBlockSealUniq>;
};


/** Block seals in Flow blockchain */
export type BitqueryFlowBlockSealExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Block seals in Flow blockchain */
export type BitqueryFlowBlockSealMaximumArgs = {
  get?: InputMaybe<BitqueryFlowBlockSealsMeasureable>;
  of: BitqueryFlowBlockSealsMeasureable;
};


/** Block seals in Flow blockchain */
export type BitqueryFlowBlockSealMinimumArgs = {
  get?: InputMaybe<BitqueryFlowBlockSealsMeasureable>;
  of: BitqueryFlowBlockSealsMeasureable;
};

export type BitqueryFlowBlockSealFilter = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  blockSealId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  executionReceiptId?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

export enum BitqueryFlowBlockSealUniq {
  /** Unique number of sealed blocks */
  BlockSealId = 'block_seal_id',
  /** Unique date count */
  Dates = 'dates',
  /** ID execution receipt being sealed */
  ExecutionReceiptId = 'execution_receipt_id',
  /** Unique Number of block in the blockchains */
  Height = 'height',
  /** Unique time */
  Times = 'times'
}

export enum BitqueryFlowBlockSealsMeasureable {
  /** SHA3-256 hash of the entire block payload */
  BlockId = 'block_id',
  /** ID of the block being sealed */
  BlockSealId = 'block_seal_id',
  /** Date */
  Date = 'date',
  /** ID execution receipt being sealed */
  ExecutionReceiptId = 'execution_receipt_id',
  /** Height of the block in the chain */
  Height = 'height',
  /** Time */
  Time = 'time'
}

export enum BitqueryFlowBlockUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique Number of block in the blockchains */
  Height = 'height',
  /** Unique time */
  Times = 'times'
}

/** FlowCoinpath */
export type BitqueryFlowCoinpath = {
  __typename?: 'BitqueryFlowCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<BitqueryFlowTransactionHashIndexValues>;
};


/** FlowCoinpath */
export type BitqueryFlowCoinpathAmountArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** FlowCoinpath */
export type BitqueryFlowCoinpathAnyArgs = {
  of: BitqueryCoinpathMeasureable;
};


/** FlowCoinpath */
export type BitqueryFlowCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};


/** FlowCoinpath */
export type BitqueryFlowCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};

/** Collections in Flow blockchain */
export type BitqueryFlowCollection = {
  __typename?: 'BitqueryFlowCollection';
  any?: Maybe<Scalars['String']['output']>;
  /** Block information */
  block: BitqueryFlowBlockDimension;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** SHA3-256 hash of the collection contents */
  id?: Maybe<Scalars['String']['output']>;
  /** Index of collection inside block */
  index?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** BLS signatures of the collection nodes guaranteeing the collection */
  signatures?: Maybe<Array<Scalars['String']['output']>>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Count of transactions inside collection */
  transactionsCount?: Maybe<Scalars['Int']['output']>;
};


/** Collections in Flow blockchain */
export type BitqueryFlowCollectionAnyArgs = {
  of: BitqueryFlowCollectionsMeasureable;
};


/** Collections in Flow blockchain */
export type BitqueryFlowCollectionBlockArgs = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Collections in Flow blockchain */
export type BitqueryFlowCollectionCountArgs = {
  uniq?: InputMaybe<BitqueryFlowCollectionUniq>;
};


/** Collections in Flow blockchain */
export type BitqueryFlowCollectionCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryFlowCollectionUniq>;
};


/** Collections in Flow blockchain */
export type BitqueryFlowCollectionExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Collections in Flow blockchain */
export type BitqueryFlowCollectionMaximumArgs = {
  get?: InputMaybe<BitqueryFlowCollectionsMeasureable>;
  of: BitqueryFlowCollectionsMeasureable;
};


/** Collections in Flow blockchain */
export type BitqueryFlowCollectionMinimumArgs = {
  get?: InputMaybe<BitqueryFlowCollectionsMeasureable>;
  of: BitqueryFlowCollectionsMeasureable;
};

export type BitqueryFlowCollectionFilter = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  collectionId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionsCount?: InputMaybe<BitqueryIntegerSelector>;
};

export enum BitqueryFlowCollectionUniq {
  /** SHA3-256 hash of the collection contents */
  CollectionId = 'collection_id',
  /** Index of collection inside block */
  CollectionIndex = 'collection_index',
  /** Unique date count */
  Dates = 'dates',
  /** Unique Number of block in the blockchains */
  Height = 'height',
  /** Unique time */
  Times = 'times'
}

export enum BitqueryFlowCollectionsMeasureable {
  /** SHA3-256 hash of the entire block payload */
  BlockId = 'block_id',
  /** SHA3-256 hash of the collection contents */
  CollectionId = 'collection_id',
  /** Index of collection inside block */
  CollectionIndex = 'collection_index',
  /** Date */
  Date = 'date',
  /** Height of the block in the chain */
  Height = 'height',
  /** Time */
  Time = 'time',
  /** Count of transactions inside collection */
  TransactionsCount = 'transactions_count'
}

export enum BitqueryFlowDirection {
  /** Inbound transfers */
  Inbound = 'inbound',
  /** Outbound transfers */
  Outbound = 'outbound'
}

/** Events in Flow blockchain */
export type BitqueryFlowEvent = {
  __typename?: 'BitqueryFlowEvent';
  any?: Maybe<Scalars['String']['output']>;
  /** Block information */
  block: BitqueryFlowBlockDimension;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  index: Scalars['Int']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Smart contract address */
  smartContractAddress?: Maybe<BitqueryAddress>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<BitqueryMethod>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Transaction information */
  transaction: BitqueryFlowMinorTransactionDimension;
  /** Type of field, e.g. UInt64, String, Bool, etc.. */
  type: Scalars['String']['output'];
};


/** Events in Flow blockchain */
export type BitqueryFlowEventAnyArgs = {
  of: BitqueryFlowEventMeasureable;
};


/** Events in Flow blockchain */
export type BitqueryFlowEventBlockArgs = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Events in Flow blockchain */
export type BitqueryFlowEventCountArgs = {
  uniq?: InputMaybe<BitqueryFlowEventUniq>;
};


/** Events in Flow blockchain */
export type BitqueryFlowEventCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryFlowEventUniq>;
};


/** Events in Flow blockchain */
export type BitqueryFlowEventExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Events in Flow blockchain */
export type BitqueryFlowEventMaximumArgs = {
  get?: InputMaybe<BitqueryFlowEventMeasureable>;
  of: BitqueryFlowEventMeasureable;
};


/** Events in Flow blockchain */
export type BitqueryFlowEventMinimumArgs = {
  get?: InputMaybe<BitqueryFlowEventMeasureable>;
  of: BitqueryFlowEventMeasureable;
};


/** Events in Flow blockchain */
export type BitqueryFlowEventTransactionArgs = {
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
};

/** EventFields in Flow blockchain */
export type BitqueryFlowEventField = {
  __typename?: 'BitqueryFlowEventField';
  any?: Maybe<Scalars['String']['output']>;
  /** Block information */
  block: BitqueryFlowBlockDimension;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  /** Index of event inside transaction */
  eventIndex: Scalars['Int']['output'];
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Field */
  field: Scalars['String']['output'];
  /** Field as fix */
  fieldAsFix: Scalars['String']['output'];
  /** Field as fix */
  fieldAsInt: Scalars['String']['output'];
  /** Index of field inside event */
  index: Scalars['String']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Smart contract address */
  smartContractAddress?: Maybe<BitqueryAddress>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<BitqueryMethod>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Transaction information */
  transaction: BitqueryFlowMinorTransactionDimension;
  /** Type of field, e.g. UInt64, String, Bool, etc.. */
  type: Scalars['String']['output'];
};


/** EventFields in Flow blockchain */
export type BitqueryFlowEventFieldAnyArgs = {
  of: BitqueryFlowEventFieldMeasureable;
};


/** EventFields in Flow blockchain */
export type BitqueryFlowEventFieldBlockArgs = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** EventFields in Flow blockchain */
export type BitqueryFlowEventFieldCountArgs = {
  uniq?: InputMaybe<BitqueryFlowEventFieldUniq>;
};


/** EventFields in Flow blockchain */
export type BitqueryFlowEventFieldCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryFlowEventFieldUniq>;
};


/** EventFields in Flow blockchain */
export type BitqueryFlowEventFieldExpressionArgs = {
  get: Scalars['String']['input'];
};


/** EventFields in Flow blockchain */
export type BitqueryFlowEventFieldMaximumArgs = {
  get?: InputMaybe<BitqueryFlowEventFieldMeasureable>;
  of: BitqueryFlowEventFieldMeasureable;
};


/** EventFields in Flow blockchain */
export type BitqueryFlowEventFieldMinimumArgs = {
  get?: InputMaybe<BitqueryFlowEventFieldMeasureable>;
  of: BitqueryFlowEventFieldMeasureable;
};


/** EventFields in Flow blockchain */
export type BitqueryFlowEventFieldTransactionArgs = {
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryFlowEventFieldFilter = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  eventIndex?: InputMaybe<BitqueryIntegerSelector>;
  fieldAsFix?: InputMaybe<BitqueryIntegerSelector>;
  fieldAsInt?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryStringSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};

export enum BitqueryFlowEventFieldMeasureable {
  /** Hash of the the block */
  BlockId = 'block_id',
  /** Date */
  Date = 'date',
  /** Number of block in the blockhains */
  Height = 'height',
  /** Smart Contract Method Signature */
  Signature = 'signature',
  /** Smart Contract Method Signature Hash */
  SignatureHash = 'signature_hash',
  /** Smart Contract Method Name */
  SignatureName = 'signature_name',
  /** Smart Contract */
  SmartContract = 'smart_contract',
  /** Time */
  Time = 'time',
  /** ID transaction */
  TxId = 'tx_id',
  /** Index of transaction inside collection */
  TxIndexInCollection = 'tx_index_in_collection',
  /** TX status code */
  TxStatusCode = 'tx_status_code'
}

export enum BitqueryFlowEventFieldUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique Number of events */
  Events = 'events',
  /** Unique Number of block in the blockchains */
  Height = 'height',
  /** Unique Number of smart contract methods */
  SmartContractMethods = 'smart_contract_methods',
  /** Unique Number of smart contract */
  SmartContracts = 'smart_contracts',
  /** Unique time */
  Times = 'times',
  /** Unique Number of transactions */
  Transactions = 'transactions'
}

export type BitqueryFlowEventFilter = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryStringSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};

export enum BitqueryFlowEventMeasureable {
  /** Hash of the the block */
  BlockId = 'block_id',
  /** Date */
  Date = 'date',
  /** Number of block in the blockhains */
  Height = 'height',
  /** Smart Contract Method Signature */
  Signature = 'signature',
  /** Smart Contract Method Signature Hash */
  SignatureHash = 'signature_hash',
  /** Smart Contract Method Name */
  SignatureName = 'signature_name',
  /** Smart Contract */
  SmartContract = 'smart_contract',
  /** Time */
  Time = 'time',
  /** ID transaction */
  TxId = 'tx_id',
  /** Index of transaction inside collection */
  TxIndexInCollection = 'tx_index_in_collection',
  /** TX status code */
  TxStatusCode = 'tx_status_code'
}

export enum BitqueryFlowEventUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique Number of events */
  Events = 'events',
  /** Unique Number of block in the blockchains */
  Height = 'height',
  /** Unique Number of smart contract methods */
  SmartContractMethods = 'smart_contract_methods',
  /** Unique Number of smart contract */
  SmartContracts = 'smart_contracts',
  /** Unique time */
  Times = 'times',
  /** Unique Number of transactions */
  Transactions = 'transactions'
}

export type BitqueryFlowFullTransactionDimension = {
  __typename?: 'BitqueryFlowFullTransactionDimension';
  /** Error message */
  errorMessage?: Maybe<Scalars['String']['output']>;
  /** Count of events inside transaction */
  eventsCount?: Maybe<Scalars['Int']['output']>;
  /** Gas Limit */
  gasLimit?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** ID of the transaction */
  id?: Maybe<Scalars['String']['output']>;
  /** Transaction Index inside collection */
  indexInCollection?: Maybe<Scalars['Int']['output']>;
  /** The account paying for the transaction fees */
  payer?: Maybe<Scalars['String']['output']>;
  /** ID of proposal key on the proposal account */
  proposalKeyId?: Maybe<Scalars['Int']['output']>;
  /** Sequence number for the proposal key */
  proposalKeySequenceNumber?: Maybe<Scalars['Int']['output']>;
  /** The account that specifies a proposal key */
  proposer?: Maybe<Scalars['String']['output']>;
  /** Block ID used to determine transaction expiry */
  referenceBlockId?: Maybe<Scalars['String']['output']>;
  /** Status code of transaction where 0 is success and 1 is failure */
  statusCode?: Maybe<Scalars['Int']['output']>;
};

/** Inputs in Flow blockchain */
export type BitqueryFlowInput = {
  __typename?: 'BitqueryFlowInput';
  /** Address */
  address: BitqueryAddress;
  amount?: Maybe<Scalars['Float']['output']>;
  /** Input value as decimal */
  amountDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block information */
  block: BitqueryFlowBlockDimension;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  /** NFT Id */
  entityId: Scalars['BitqueryBigInt']['output'];
  /** Index of event inside transaction */
  eventIndex: Scalars['Int']['output'];
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Smart contract address */
  smartContractAddress?: Maybe<BitqueryAddress>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<BitqueryMethod>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Transaction information */
  transaction: BitqueryFlowMinorTransactionDimension;
  /** Transfer reason, e.g. nft_transfer, fungible_token_transfer, fee */
  transferReason: Scalars['String']['output'];
  /** Type of field, e.g. UInt64, String, Bool, etc.. */
  type: Scalars['String']['output'];
};


/** Inputs in Flow blockchain */
export type BitqueryFlowInputAmountArgs = {
  address?: InputMaybe<BitqueryStringSelector>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryBigIntIdSelector>;
  eventIndex?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryStringSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
  transferReason?: InputMaybe<BitqueryFlowTransferReasonSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Inputs in Flow blockchain */
export type BitqueryFlowInputAmountDecimalArgs = {
  address?: InputMaybe<BitqueryStringSelector>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryBigIntIdSelector>;
  eventIndex?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryStringSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
  transferReason?: InputMaybe<BitqueryFlowTransferReasonSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Inputs in Flow blockchain */
export type BitqueryFlowInputAnyArgs = {
  of: BitqueryFlowInputMeasureable;
};


/** Inputs in Flow blockchain */
export type BitqueryFlowInputBlockArgs = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Inputs in Flow blockchain */
export type BitqueryFlowInputCountArgs = {
  uniq?: InputMaybe<BitqueryFlowInputUniq>;
};


/** Inputs in Flow blockchain */
export type BitqueryFlowInputCountBigIntArgs = {
  address?: InputMaybe<BitqueryStringSelector>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryBigIntIdSelector>;
  eventIndex?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryStringSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
  transferReason?: InputMaybe<BitqueryFlowTransferReasonSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryFlowInputUniq>;
};


/** Inputs in Flow blockchain */
export type BitqueryFlowInputExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Inputs in Flow blockchain */
export type BitqueryFlowInputMaximumArgs = {
  get?: InputMaybe<BitqueryFlowInputMeasureable>;
  of: BitqueryFlowInputMeasureable;
};


/** Inputs in Flow blockchain */
export type BitqueryFlowInputMinimumArgs = {
  get?: InputMaybe<BitqueryFlowInputMeasureable>;
  of: BitqueryFlowInputMeasureable;
};


/** Inputs in Flow blockchain */
export type BitqueryFlowInputTransactionArgs = {
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryFlowInputFilter = {
  address?: InputMaybe<BitqueryStringSelector>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryBigIntIdSelector>;
  eventIndex?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryStringSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
  transferReason?: InputMaybe<BitqueryFlowTransferReasonSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};

export enum BitqueryFlowInputMeasureable {
  /** Address */
  Address = 'address',
  /** Amount */
  Amount = 'amount',
  /** Hash of the the block */
  BlockId = 'block_id',
  /** Currency address */
  CurrencyAddress = 'currency_address',
  /** Currency symbol */
  CurrencySymbol = 'currency_symbol',
  /** Date */
  Date = 'date',
  /** Entity ID */
  EntityId = 'entity_id',
  /** Index of event inside transaction */
  EventIndex = 'event_index',
  /** Number of block in the blockhains */
  Height = 'height',
  /** Smart Contract Method Signature */
  Signature = 'signature',
  /** Smart Contract Method Hash */
  SignatureHash = 'signature_hash',
  /** Smart Contract Method Name */
  SignatureName = 'signature_name',
  /** Smart Contract */
  SmartContract = 'smart_contract',
  /** Time */
  Time = 'time',
  /** ID transaction */
  TxId = 'tx_id',
  /** Index of transaction inside collection */
  TxIndexInCollection = 'tx_index_in_collection',
  /** TX status code */
  TxStatusCode = 'tx_status_code',
  /** Type */
  Type = 'type'
}

export enum BitqueryFlowInputUniq {
  /** Unique Number of symbol currencies */
  Currencies = 'currencies',
  /** Unique date count */
  Dates = 'dates',
  /** Unique Number of events */
  Events = 'events',
  /** Unique Number of block in the blockchains */
  Height = 'height',
  /** Unique Number of smart contract methods */
  SmartContractMethods = 'smart_contract_methods',
  /** Unique Number of smart contract */
  SmartContracts = 'smart_contracts',
  /** Unique time */
  Times = 'times',
  /** Unique Number of transactions */
  Transactions = 'transactions',
  /** Unique Number of types */
  Types = 'types'
}

export type BitqueryFlowMinorTransactionDimension = {
  __typename?: 'BitqueryFlowMinorTransactionDimension';
  /** ID of the transaction */
  id?: Maybe<Scalars['String']['output']>;
  /** Transaction Index inside collection */
  indexInCollection?: Maybe<Scalars['Int']['output']>;
  /** Status code of transaction where 0 is success and 1 is failure */
  statusCode?: Maybe<Scalars['Int']['output']>;
};

export enum BitqueryFlowNetwork {
  /** Flow mainnet */
  Flow = 'flow'
}

/** Outputs in Flow blockchain */
export type BitqueryFlowOutput = {
  __typename?: 'BitqueryFlowOutput';
  /** Address */
  address: BitqueryAddress;
  amount?: Maybe<Scalars['Float']['output']>;
  /** Input value as decimal */
  amountDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block information */
  block: BitqueryFlowBlockDimension;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  /** NFT Id */
  entityId: Scalars['BitqueryBigInt']['output'];
  /** Index of event inside transaction */
  eventIndex: Scalars['Int']['output'];
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Smart contract address */
  smartContractAddress?: Maybe<BitqueryAddress>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<BitqueryMethod>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Transaction information */
  transaction: BitqueryFlowMinorTransactionDimension;
  /** Transfer reason, e.g. nft_transfer, fungible_token_transfer, fee */
  transferReason: Scalars['String']['output'];
  /** Type of field, e.g. UInt64, String, Bool, etc.. */
  type: Scalars['String']['output'];
};


/** Outputs in Flow blockchain */
export type BitqueryFlowOutputAmountArgs = {
  address?: InputMaybe<BitqueryStringSelector>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryBigIntIdSelector>;
  eventIndex?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryStringSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
  transferReason?: InputMaybe<BitqueryFlowTransferReasonSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Outputs in Flow blockchain */
export type BitqueryFlowOutputAmountDecimalArgs = {
  address?: InputMaybe<BitqueryStringSelector>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryBigIntIdSelector>;
  eventIndex?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryStringSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
  transferReason?: InputMaybe<BitqueryFlowTransferReasonSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Outputs in Flow blockchain */
export type BitqueryFlowOutputAnyArgs = {
  of: BitqueryFlowOutputMeasureable;
};


/** Outputs in Flow blockchain */
export type BitqueryFlowOutputBlockArgs = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Outputs in Flow blockchain */
export type BitqueryFlowOutputCountArgs = {
  uniq?: InputMaybe<BitqueryFlowOutputUniq>;
};


/** Outputs in Flow blockchain */
export type BitqueryFlowOutputCountBigIntArgs = {
  address?: InputMaybe<BitqueryStringSelector>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryBigIntIdSelector>;
  eventIndex?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryStringSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
  transferReason?: InputMaybe<BitqueryFlowTransferReasonSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryFlowOutputUniq>;
};


/** Outputs in Flow blockchain */
export type BitqueryFlowOutputExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Outputs in Flow blockchain */
export type BitqueryFlowOutputMaximumArgs = {
  get?: InputMaybe<BitqueryFlowOutputMeasureable>;
  of: BitqueryFlowOutputMeasureable;
};


/** Outputs in Flow blockchain */
export type BitqueryFlowOutputMinimumArgs = {
  get?: InputMaybe<BitqueryFlowOutputMeasureable>;
  of: BitqueryFlowOutputMeasureable;
};


/** Outputs in Flow blockchain */
export type BitqueryFlowOutputTransactionArgs = {
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryFlowOutputFilter = {
  address?: InputMaybe<BitqueryStringSelector>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryBigIntIdSelector>;
  eventIndex?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryStringSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
  transferReason?: InputMaybe<BitqueryFlowTransferReasonSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};

export enum BitqueryFlowOutputMeasureable {
  /** Address */
  Address = 'address',
  /** Amount */
  Amount = 'amount',
  /** Hash of the the block */
  BlockId = 'block_id',
  /** Currency address */
  CurrencyAddress = 'currency_address',
  /** Currency symbol */
  CurrencySymbol = 'currency_symbol',
  /** Date */
  Date = 'date',
  /** Entity ID */
  EntityId = 'entity_id',
  /** Index of event inside transaction */
  EventIndex = 'event_index',
  /** Number of block in the blockhains */
  Height = 'height',
  /** Smart Contract Method Signature */
  Signature = 'signature',
  /** Smart Contract Method Hash */
  SignatureHash = 'signature_hash',
  /** Smart Contract Method Name */
  SignatureName = 'signature_name',
  /** Smart Contract */
  SmartContract = 'smart_contract',
  /** Time */
  Time = 'time',
  /** ID transaction */
  TxId = 'tx_id',
  /** Index of transaction inside collection */
  TxIndexInCollection = 'tx_index_in_collection',
  /** TX status code */
  TxStatusCode = 'tx_status_code',
  /** Type */
  Type = 'type'
}

export enum BitqueryFlowOutputUniq {
  /** Unique Number of symbol currencies */
  Currencies = 'currencies',
  /** Unique date count */
  Dates = 'dates',
  /** Unique Number of events */
  Events = 'events',
  /** Unique Number of block in the blockchains */
  Height = 'height',
  /** Unique Number of smart contract methods */
  SmartContractMethods = 'smart_contract_methods',
  /** Unique Number of smart contract */
  SmartContracts = 'smart_contracts',
  /** Unique time */
  Times = 'times',
  /** Unique Number of transactions */
  Transactions = 'transactions',
  /** Unique Number of types */
  Types = 'types'
}

/** Transactions in Flow  blockchain */
export type BitqueryFlowTransaction = {
  __typename?: 'BitqueryFlowTransaction';
  any?: Maybe<Scalars['String']['output']>;
  /** Block information */
  block: BitqueryFlowBlockDimension;
  /** SHA3-256 hash of the collection contents */
  collectionId?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  /** Error message */
  errorMessage?: Maybe<Scalars['String']['output']>;
  /** Count of events inside transaction */
  eventsCount?: Maybe<Scalars['Int']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Gas Limit */
  gasLimit?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** ID of the transaction */
  id?: Maybe<Scalars['String']['output']>;
  /** Transaction Index inside collection */
  indexInCollection?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** The account paying for the transaction fees */
  payer?: Maybe<BitqueryAddress>;
  /** ID of proposal key on the proposal account */
  proposalKeyId?: Maybe<Scalars['Int']['output']>;
  /** Sequence number for the proposal key */
  proposalKeySequenceNumber?: Maybe<Scalars['Int']['output']>;
  /** The account that specifies a proposal key */
  proposer?: Maybe<BitqueryAddress>;
  /** Block ID used to determine transaction expiry */
  referenceBlockId?: Maybe<Scalars['String']['output']>;
  /** Raw source code for a Cadence script, encoded as UTF-8 bytes */
  script?: Maybe<Scalars['String']['output']>;
  /** Status code of transaction where 0 is success and 1 is failure */
  statusCode?: Maybe<Scalars['Int']['output']>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
};


/** Transactions in Flow  blockchain */
export type BitqueryFlowTransactionAnyArgs = {
  of: BitqueryFlowTransactionMeasureable;
};


/** Transactions in Flow  blockchain */
export type BitqueryFlowTransactionBlockArgs = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Transactions in Flow  blockchain */
export type BitqueryFlowTransactionCountArgs = {
  uniq?: InputMaybe<BitqueryFlowTransactionUniq>;
};


/** Transactions in Flow  blockchain */
export type BitqueryFlowTransactionCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryFlowTransactionUniq>;
};


/** Transactions in Flow  blockchain */
export type BitqueryFlowTransactionExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transactions in Flow  blockchain */
export type BitqueryFlowTransactionMaximumArgs = {
  get?: InputMaybe<BitqueryFlowTransactionMeasureable>;
  of: BitqueryFlowTransactionMeasureable;
};


/** Transactions in Flow  blockchain */
export type BitqueryFlowTransactionMinimumArgs = {
  get?: InputMaybe<BitqueryFlowTransactionMeasureable>;
  of: BitqueryFlowTransactionMeasureable;
};

/** TransactionAuthorizers in Flow blockchain */
export type BitqueryFlowTransactionAuthorizer = {
  __typename?: 'BitqueryFlowTransactionAuthorizer';
  any?: Maybe<Scalars['String']['output']>;
  /** Account authorizing the transaction to mutate their state. */
  authorizer?: Maybe<BitqueryAddress>;
  /** Block information */
  block: BitqueryFlowBlockDimension;
  /** SHA3-256 hash of the collection contents */
  collectionId?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Information about transaction */
  transaction: BitqueryFlowFullTransactionDimension;
};


/** TransactionAuthorizers in Flow blockchain */
export type BitqueryFlowTransactionAuthorizerAnyArgs = {
  of: BitqueryFlowTransactionAuthorizerMeasureable;
};


/** TransactionAuthorizers in Flow blockchain */
export type BitqueryFlowTransactionAuthorizerBlockArgs = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** TransactionAuthorizers in Flow blockchain */
export type BitqueryFlowTransactionAuthorizerCountArgs = {
  uniq?: InputMaybe<BitqueryFlowTransactionAuthorizerUniq>;
};


/** TransactionAuthorizers in Flow blockchain */
export type BitqueryFlowTransactionAuthorizerCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryFlowTransactionAuthorizerUniq>;
};


/** TransactionAuthorizers in Flow blockchain */
export type BitqueryFlowTransactionAuthorizerExpressionArgs = {
  get: Scalars['String']['input'];
};


/** TransactionAuthorizers in Flow blockchain */
export type BitqueryFlowTransactionAuthorizerMaximumArgs = {
  get?: InputMaybe<BitqueryFlowTransactionAuthorizerMeasureable>;
  of: BitqueryFlowTransactionAuthorizerMeasureable;
};


/** TransactionAuthorizers in Flow blockchain */
export type BitqueryFlowTransactionAuthorizerMinimumArgs = {
  get?: InputMaybe<BitqueryFlowTransactionAuthorizerMeasureable>;
  of: BitqueryFlowTransactionAuthorizerMeasureable;
};


/** TransactionAuthorizers in Flow blockchain */
export type BitqueryFlowTransactionAuthorizerTransactionArgs = {
  errorMessage?: InputMaybe<BitqueryStringSelector>;
  eventsCount?: InputMaybe<BitqueryIntegerSelector>;
  gasLimit?: InputMaybe<BitqueryIntegerSelector>;
  indexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  payer?: InputMaybe<BitqueryHashSelector>;
  proposalKeyId?: InputMaybe<BitqueryIntegerSelector>;
  proposalKeySequenceNumber?: InputMaybe<BitqueryIntegerSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  referenceBlockId?: InputMaybe<BitqueryHashSelector>;
  statusCode?: InputMaybe<BitqueryIntegerSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
};

export type BitqueryFlowTransactionAuthorizerFilter = {
  authorizer?: InputMaybe<BitqueryAddressSelector>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  collectionId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  eventsCount?: InputMaybe<BitqueryIntegerSelector>;
  gasLimit?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  indexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  payer?: InputMaybe<BitqueryAddressSelector>;
  proposalKeyId?: InputMaybe<BitqueryIntegerSelector>;
  proposalKeySequenceNumber?: InputMaybe<BitqueryIntegerSelector>;
  proposer?: InputMaybe<BitqueryAddressSelector>;
  referenceBlockId?: InputMaybe<BitqueryStringSelector>;
  statusCode?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
};

export enum BitqueryFlowTransactionAuthorizerMeasureable {
  /** Account authorizing the transaction to mutate their state. */
  Authorizer = 'authorizer',
  /** Hash of the the block */
  BlockId = 'block_id',
  /** SHA3-256 hash of the collection contents */
  CollectionId = 'collection_id',
  /** Date */
  Date = 'date',
  /** Error message in transaction */
  ErrorMessage = 'error_message',
  /** Count of events inside transactions */
  EventsCount = 'events_count',
  /** Gas Limit */
  GasLimit = 'gas_limit',
  /** Number of block in the blockhains */
  Height = 'height',
  /** The account paying for the transaction fees */
  Payer = 'payer',
  /** Proposer key sequence number */
  ProposalKeySequenceNumber = 'proposal_key_sequence_number',
  /** The account that specifies a proposal key */
  Proposer = 'proposer',
  /** Proposer Key ID */
  ProposerKeyId = 'proposer_key_id',
  /** Reference block hash */
  ReferenceBlockId = 'reference_block_id',
  /** Status code of transaction */
  StatusCode = 'status_code',
  /** Time */
  Time = 'time',
  /** Transaction ID */
  TxId = 'tx_id',
  /** Transaction index inside collection */
  TxIndexInCollection = 'tx_index_in_collection'
}

export enum BitqueryFlowTransactionAuthorizerUniq {
  /** Unique Number of authorizers */
  Authorizers = 'authorizers',
  /** Unique Number of collection */
  CollectionId = 'collection_id',
  /** Unique date count */
  Dates = 'dates',
  /** Unique Number of block in the blockchains */
  Height = 'height',
  /** The account paying for the transaction fees */
  Payers = 'payers',
  /** The account that specifies a proposal key */
  Proposers = 'proposers',
  /** Reference block hash */
  ReferenceBlockId = 'reference_block_id',
  /** Unique time */
  Times = 'times',
  /** Transaction ID */
  TxId = 'tx_id',
  /** Transaction index inside collection */
  TxIndexInCollection = 'tx_index_in_collection'
}

/** TransactionEnvelopeSignature in Flow blockchain */
export type BitqueryFlowTransactionEnvelopeSignature = {
  __typename?: 'BitqueryFlowTransactionEnvelopeSignature';
  /** Address of the account for this signature */
  address: BitqueryAddress;
  any?: Maybe<Scalars['String']['output']>;
  /** Block information */
  block: BitqueryFlowBlockDimension;
  /** SHA3-256 hash of the collection contents */
  collectionId: Scalars['String']['output'];
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** ID of the account key */
  keyId: Scalars['Int']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Raw signature data */
  signature: Scalars['String']['output'];
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Information about transaction */
  transaction: BitqueryFlowFullTransactionDimension;
};


/** TransactionEnvelopeSignature in Flow blockchain */
export type BitqueryFlowTransactionEnvelopeSignatureAnyArgs = {
  of: BitqueryFlowTransactionEnvelopeSignatureMeasureable;
};


/** TransactionEnvelopeSignature in Flow blockchain */
export type BitqueryFlowTransactionEnvelopeSignatureBlockArgs = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** TransactionEnvelopeSignature in Flow blockchain */
export type BitqueryFlowTransactionEnvelopeSignatureCountArgs = {
  uniq?: InputMaybe<BitqueryFlowTransactionEnvelopeSignatureUniq>;
};


/** TransactionEnvelopeSignature in Flow blockchain */
export type BitqueryFlowTransactionEnvelopeSignatureCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryFlowTransactionEnvelopeSignatureUniq>;
};


/** TransactionEnvelopeSignature in Flow blockchain */
export type BitqueryFlowTransactionEnvelopeSignatureExpressionArgs = {
  get: Scalars['String']['input'];
};


/** TransactionEnvelopeSignature in Flow blockchain */
export type BitqueryFlowTransactionEnvelopeSignatureMaximumArgs = {
  get?: InputMaybe<BitqueryFlowTransactionEnvelopeSignatureMeasureable>;
  of: BitqueryFlowTransactionEnvelopeSignatureMeasureable;
};


/** TransactionEnvelopeSignature in Flow blockchain */
export type BitqueryFlowTransactionEnvelopeSignatureMinimumArgs = {
  get?: InputMaybe<BitqueryFlowTransactionEnvelopeSignatureMeasureable>;
  of: BitqueryFlowTransactionEnvelopeSignatureMeasureable;
};


/** TransactionEnvelopeSignature in Flow blockchain */
export type BitqueryFlowTransactionEnvelopeSignatureTransactionArgs = {
  errorMessage?: InputMaybe<BitqueryStringSelector>;
  eventsCount?: InputMaybe<BitqueryIntegerSelector>;
  gasLimit?: InputMaybe<BitqueryIntegerSelector>;
  indexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  payer?: InputMaybe<BitqueryHashSelector>;
  proposalKeyId?: InputMaybe<BitqueryIntegerSelector>;
  proposalKeySequenceNumber?: InputMaybe<BitqueryIntegerSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  referenceBlockId?: InputMaybe<BitqueryHashSelector>;
  statusCode?: InputMaybe<BitqueryIntegerSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
};

export type BitqueryFlowTransactionEnvelopeSignatureFilter = {
  address?: InputMaybe<BitqueryAddressSelector>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  collectionId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  eventsCount?: InputMaybe<BitqueryIntegerSelector>;
  gasLimit?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  indexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  keyId?: InputMaybe<BitqueryIntegerSelector>;
  payer?: InputMaybe<BitqueryAddressSelector>;
  proposalKeyId?: InputMaybe<BitqueryIntegerSelector>;
  proposalKeySequenceNumber?: InputMaybe<BitqueryIntegerSelector>;
  proposer?: InputMaybe<BitqueryAddressSelector>;
  referenceBlockId?: InputMaybe<BitqueryStringSelector>;
  signature?: InputMaybe<BitqueryStringSelector>;
  statusCode?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
};

export enum BitqueryFlowTransactionEnvelopeSignatureMeasureable {
  /** Address of the account for this signature */
  Address = 'address',
  /** Hash of the the block */
  BlockId = 'block_id',
  /** SHA3-256 hash of the collection contents */
  CollectionId = 'collection_id',
  /** Date */
  Date = 'date',
  /** Error message in transaction */
  ErrorMessage = 'error_message',
  /** Count of events inside transactions */
  EventsCount = 'events_count',
  /** Gas Limit */
  GasLimit = 'gas_limit',
  /** Number of block in the blockhains */
  Height = 'height',
  /** ID of account key */
  KeyId = 'key_id',
  /** The account paying for the transaction fees */
  Payer = 'payer',
  /** Proposer key sequence number */
  ProposalKeySequenceNumber = 'proposal_key_sequence_number',
  /** The account that specifies a proposal key */
  Proposer = 'proposer',
  /** Proposer Key ID */
  ProposerKeyId = 'proposer_key_id',
  /** Reference block hash */
  ReferenceBlockId = 'reference_block_id',
  /** Raw signature data */
  Signature = 'signature',
  /** Status code of transaction */
  StatusCode = 'status_code',
  /** Time */
  Time = 'time',
  /** Transaction ID */
  TxId = 'tx_id',
  /** Transaction index inside collection */
  TxIndexInCollection = 'tx_index_in_collection'
}

export enum BitqueryFlowTransactionEnvelopeSignatureUniq {
  /** The address and key ID fields declare the account key that generated the signature */
  Addresses = 'addresses',
  /** Unique Number of collection */
  CollectionId = 'collection_id',
  /** Unique date count */
  Dates = 'dates',
  /** Unique Number of block in the blockchains */
  Height = 'height',
  /** The account paying for the transaction fees */
  Payers = 'payers',
  /** The account that specifies a proposal key */
  Proposers = 'proposers',
  /** Reference block hash */
  ReferenceBlockId = 'reference_block_id',
  /** Unique time */
  Times = 'times',
  /** Transaction ID */
  TxId = 'tx_id',
  /** Transaction index inside collection */
  TxIndexInCollection = 'tx_index_in_collection'
}

export type BitqueryFlowTransactionFilter = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  collectionId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  eventsCount?: InputMaybe<BitqueryIntegerSelector>;
  gasLimit?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  indexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  payer?: InputMaybe<BitqueryAddressSelector>;
  proposalKeyId?: InputMaybe<BitqueryIntegerSelector>;
  proposalKeySequenceNumber?: InputMaybe<BitqueryIntegerSelector>;
  proposer?: InputMaybe<BitqueryAddressSelector>;
  referenceBlockId?: InputMaybe<BitqueryStringSelector>;
  statusCode?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
};

/** Blockchain transaction */
export type BitqueryFlowTransactionHashIndexValues = {
  __typename?: 'BitqueryFlowTransactionHashIndexValues';
  /** Hash hex representation */
  id: Scalars['String']['output'];
  /** Transaction value in input */
  valueIn: Scalars['Float']['output'];
  /** Transaction value in input */
  valueInDecimal: Scalars['BitqueryDecimalNumber']['output'];
  /** Transaction value in output */
  valueOut: Scalars['Float']['output'];
  /** Transaction value in output */
  valueOutDecimal: Scalars['BitqueryDecimalNumber']['output'];
};

export enum BitqueryFlowTransactionMeasureable {
  /** Hash of the the block */
  BlockId = 'block_id',
  /** SHA3-256 hash of the collection contents */
  CollectionId = 'collection_id',
  /** Date */
  Date = 'date',
  /** Error message in transaction */
  ErrorMessage = 'error_message',
  /** Count of events inside transactions */
  EventsCount = 'events_count',
  /** Gas Limit */
  GasLimit = 'gas_limit',
  /** Number of block in the blockhains */
  Height = 'height',
  /** The account paying for the transaction fees */
  Payer = 'payer',
  /** Proposer key sequence number */
  ProposalKeySequenceNumber = 'proposal_key_sequence_number',
  /** The account that specifies a proposal key */
  Proposer = 'proposer',
  /** Proposer Key ID */
  ProposerKeyId = 'proposer_key_id',
  /** Reference block hash */
  ReferenceBlockId = 'reference_block_id',
  /** Status code of transaction */
  StatusCode = 'status_code',
  /** Time */
  Time = 'time',
  /** Transaction ID */
  TxId = 'tx_id',
  /** Transaction index inside collection */
  TxIndexInCollection = 'tx_index_in_collection'
}

/** TransactionPayloadSignature in Flow blockchain */
export type BitqueryFlowTransactionPayloadSignature = {
  __typename?: 'BitqueryFlowTransactionPayloadSignature';
  /** Address of the account for this signature */
  address: BitqueryAddress;
  any?: Maybe<Scalars['String']['output']>;
  /** Block information */
  block: BitqueryFlowBlockDimension;
  /** SHA3-256 hash of the collection contents */
  collectionId: Scalars['String']['output'];
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** ID of the account key */
  keyId: Scalars['Int']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Raw signature data */
  signature: Scalars['String']['output'];
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Information about transaction */
  transaction: BitqueryFlowFullTransactionDimension;
};


/** TransactionPayloadSignature in Flow blockchain */
export type BitqueryFlowTransactionPayloadSignatureAnyArgs = {
  of: BitqueryFlowTransactionPayloadSignatureMeasureable;
};


/** TransactionPayloadSignature in Flow blockchain */
export type BitqueryFlowTransactionPayloadSignatureBlockArgs = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** TransactionPayloadSignature in Flow blockchain */
export type BitqueryFlowTransactionPayloadSignatureCountArgs = {
  uniq?: InputMaybe<BitqueryFlowTransactionPayloadSignatureUniq>;
};


/** TransactionPayloadSignature in Flow blockchain */
export type BitqueryFlowTransactionPayloadSignatureCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryFlowTransactionPayloadSignatureUniq>;
};


/** TransactionPayloadSignature in Flow blockchain */
export type BitqueryFlowTransactionPayloadSignatureExpressionArgs = {
  get: Scalars['String']['input'];
};


/** TransactionPayloadSignature in Flow blockchain */
export type BitqueryFlowTransactionPayloadSignatureMaximumArgs = {
  get?: InputMaybe<BitqueryFlowTransactionPayloadSignatureMeasureable>;
  of: BitqueryFlowTransactionPayloadSignatureMeasureable;
};


/** TransactionPayloadSignature in Flow blockchain */
export type BitqueryFlowTransactionPayloadSignatureMinimumArgs = {
  get?: InputMaybe<BitqueryFlowTransactionPayloadSignatureMeasureable>;
  of: BitqueryFlowTransactionPayloadSignatureMeasureable;
};


/** TransactionPayloadSignature in Flow blockchain */
export type BitqueryFlowTransactionPayloadSignatureTransactionArgs = {
  errorMessage?: InputMaybe<BitqueryStringSelector>;
  eventsCount?: InputMaybe<BitqueryIntegerSelector>;
  gasLimit?: InputMaybe<BitqueryIntegerSelector>;
  indexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  payer?: InputMaybe<BitqueryHashSelector>;
  proposalKeyId?: InputMaybe<BitqueryIntegerSelector>;
  proposalKeySequenceNumber?: InputMaybe<BitqueryIntegerSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  referenceBlockId?: InputMaybe<BitqueryHashSelector>;
  statusCode?: InputMaybe<BitqueryIntegerSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
};

export type BitqueryFlowTransactionPayloadSignatureFilter = {
  address?: InputMaybe<BitqueryAddressSelector>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  collectionId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  eventsCount?: InputMaybe<BitqueryIntegerSelector>;
  gasLimit?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  indexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  keyId?: InputMaybe<BitqueryIntegerSelector>;
  payer?: InputMaybe<BitqueryAddressSelector>;
  proposalKeyId?: InputMaybe<BitqueryIntegerSelector>;
  proposalKeySequenceNumber?: InputMaybe<BitqueryIntegerSelector>;
  proposer?: InputMaybe<BitqueryAddressSelector>;
  referenceBlockId?: InputMaybe<BitqueryStringSelector>;
  signature?: InputMaybe<BitqueryStringSelector>;
  statusCode?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
};

export enum BitqueryFlowTransactionPayloadSignatureMeasureable {
  /** Address of the account for this signature */
  Address = 'address',
  /** Hash of the the block */
  BlockId = 'block_id',
  /** SHA3-256 hash of the collection contents */
  CollectionId = 'collection_id',
  /** Date */
  Date = 'date',
  /** Error message in transaction */
  ErrorMessage = 'error_message',
  /** Count of events inside transactions */
  EventsCount = 'events_count',
  /** Gas Limit */
  GasLimit = 'gas_limit',
  /** Number of block in the blockhains */
  Height = 'height',
  /** ID of account key */
  KeyId = 'key_id',
  /** The account paying for the transaction fees */
  Payer = 'payer',
  /** Proposer key sequence number */
  ProposalKeySequenceNumber = 'proposal_key_sequence_number',
  /** The account that specifies a proposal key */
  Proposer = 'proposer',
  /** Proposer Key ID */
  ProposerKeyId = 'proposer_key_id',
  /** Reference block hash */
  ReferenceBlockId = 'reference_block_id',
  /** Raw signature data */
  Signature = 'signature',
  /** Status code of transaction */
  StatusCode = 'status_code',
  /** Time */
  Time = 'time',
  /** Transaction ID */
  TxId = 'tx_id',
  /** Transaction index inside collection */
  TxIndexInCollection = 'tx_index_in_collection'
}

export enum BitqueryFlowTransactionPayloadSignatureUniq {
  /** The address and key ID fields declare the account key that generated the signature */
  Addresses = 'addresses',
  /** Unique Number of collection */
  CollectionId = 'collection_id',
  /** Unique date count */
  Dates = 'dates',
  /** Unique Number of block in the blockchains */
  Height = 'height',
  /** The account paying for the transaction fees */
  Payers = 'payers',
  /** The account that specifies a proposal key */
  Proposers = 'proposers',
  /** Reference block hash */
  ReferenceBlockId = 'reference_block_id',
  /** Unique time */
  Times = 'times',
  /** Transaction ID */
  TxId = 'tx_id',
  /** Transaction index inside collection */
  TxIndexInCollection = 'tx_index_in_collection'
}

export enum BitqueryFlowTransactionUniq {
  /** Unique Number of collection */
  CollectionId = 'collection_id',
  /** Unique date count */
  Dates = 'dates',
  /** Unique Number of block in the blockchains */
  Height = 'height',
  /** The account paying for the transaction fees */
  Payers = 'payers',
  /** The account that specifies a proposal key */
  Proposers = 'proposers',
  /** Reference block hash */
  ReferenceBlockId = 'reference_block_id',
  /** Unique time */
  Times = 'times',
  /** Transaction ID */
  TxId = 'tx_id',
  /** Transaction index inside collection */
  TxIndexInCollection = 'tx_index_in_collection'
}

export enum BitqueryFlowTransferReasonEnum {
  /** Fee paid */
  Fee = 'fee',
  /** Currency transfer */
  FungibleTokenTransfer = 'fungible_token_transfer',
  /** NFT Transfer */
  NftTransfer = 'nft_transfer'
}

/** Select by transfer reason */
export type BitqueryFlowTransferReasonSelector = {
  /** Reason in the list */
  in?: InputMaybe<Array<BitqueryFlowTransferReasonEnum>>;
  /** Reason is */
  is?: InputMaybe<BitqueryFlowTransferReasonEnum>;
  /** Reason not */
  not?: InputMaybe<BitqueryFlowTransferReasonEnum>;
  /** Reason not in the list */
  notIn?: InputMaybe<Array<BitqueryFlowTransferReasonEnum>>;
};

/** Select transactions by group */
export type BitqueryGroupSelector = {
  /** Transaction group in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Transaction group is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Transaction group not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Transaction group not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Harmony Chain */
export type BitqueryHarmony = {
  __typename?: 'BitqueryHarmony';
  /** Arguments of Smart Contract Calls and Events */
  arguments?: Maybe<Array<BitqueryHarmonyArguments>>;
  /** Harmony Blocks */
  blocks?: Maybe<Array<BitqueryHarmonyBlocks>>;
  /** Smart Contract Calls */
  smartContractCalls?: Maybe<Array<BitqueryHarmonySmartContractCalls>>;
  /** Smart Contract Events */
  smartContractEvents?: Maybe<Array<BitqueryHarmonySmartContractEvents>>;
  /** Harmony Staking Transactions */
  stakingTransactions?: Maybe<Array<BitqueryHarmonyStakingTransactions>>;
  /** Harmony Transactions */
  transactions?: Maybe<Array<BitqueryHarmonyTransactions>>;
  /** Harmony Transfers */
  transfers?: Maybe<Array<BitqueryHarmonyTransfers>>;
};


/** Harmony Chain */
export type BitqueryHarmonyArgumentsArgs = {
  any?: InputMaybe<Array<BitqueryHarmonyArgumentsFilter>>;
  argument?: InputMaybe<BitqueryStringSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  ledger?: InputMaybe<BitqueryBlockSelector>;
  nonce?: InputMaybe<BitqueryBigIntIdSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  receiver?: InputMaybe<BitqueryHashSelector>;
  sender?: InputMaybe<BitqueryHashSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryHashSelector>;
  smartContractId?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  toShardId?: InputMaybe<BitqueryBigIntegerSelector>;
  txIndex?: InputMaybe<BitqueryBigIntegerSelector>;
};


/** Harmony Chain */
export type BitqueryHarmonyBlocksArgs = {
  any?: InputMaybe<Array<BitqueryHarmonyBlocksFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  difficulty?: InputMaybe<BitqueryHashSelector>;
  epoch?: InputMaybe<BitqueryBigIntegerSelector>;
  ledger?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<BitqueryHashSelector>;
  nonce?: InputMaybe<BitqueryBigIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  parentHash?: InputMaybe<BitqueryHashSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  size?: InputMaybe<BitqueryBigIntegerSelector>;
  stakingTransactionsCount?: InputMaybe<BitqueryHashSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryHashSelector>;
  unclesCount?: InputMaybe<BitqueryHashSelector>;
  viewId?: InputMaybe<BitqueryHashSelector>;
};


/** Harmony Chain */
export type BitqueryHarmonySmartContractCallsArgs = {
  any?: InputMaybe<Array<BitqueryHarmonySmartContractCallsFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  nonce?: InputMaybe<BitqueryBigIntIdSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  toShardId?: InputMaybe<BitqueryBigIntegerSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryBigIntegerSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Harmony Chain */
export type BitqueryHarmonySmartContractEventsArgs = {
  any?: InputMaybe<Array<BitqueryHarmonySmartContractEventsFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  nonce?: InputMaybe<BitqueryBigIntIdSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  toShardId?: InputMaybe<BitqueryBigIntegerSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryBigIntegerSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Harmony Chain */
export type BitqueryHarmonyStakingTransactionsArgs = {
  any?: InputMaybe<Array<BitqueryHarmonyStakingTransactionsFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  delegatorAddress?: InputMaybe<BitqueryHashSelector>;
  ledger?: InputMaybe<BitqueryBlockSelector>;
  nonce?: InputMaybe<BitqueryBigIntIdSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  shardId?: InputMaybe<BitqueryBigIntIdSelector>;
  status?: InputMaybe<Scalars['Boolean']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionType?: InputMaybe<BitqueryStakingTransactionsTypeSelector>;
  validatorAddress?: InputMaybe<BitqueryHashSelector>;
};


/** Harmony Chain */
export type BitqueryHarmonyTransactionsArgs = {
  any?: InputMaybe<Array<BitqueryHarmonyTransactionsFilter>>;
  creates?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryBigIntegerSelector>;
  ledger?: InputMaybe<BitqueryBigIntIdSelector>;
  nonce?: InputMaybe<BitqueryBigIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  receiver?: InputMaybe<BitqueryHashSelector>;
  sender?: InputMaybe<BitqueryHashSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  status?: InputMaybe<Scalars['Boolean']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  toShardId?: InputMaybe<BitqueryBigIntegerSelector>;
  transactionHash?: InputMaybe<BitqueryStringSelector>;
  transactionIndex?: InputMaybe<BitqueryHashSelector>;
};


/** Harmony Chain */
export type BitqueryHarmonyTransfersArgs = {
  any?: InputMaybe<Array<BitqueryHarmonyTransfersFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryIntIdSelector>;
  ledger?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  sender?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<Scalars['Boolean']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transferFrom?: InputMaybe<BitqueryAddressSelector>;
  transferTo?: InputMaybe<BitqueryAddressSelector>;
};

/** Arguments of Smart Contract Calls and Events */
export type BitqueryHarmonyArguments = {
  __typename?: 'BitqueryHarmonyArguments';
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Argument Index */
  argIndex?: Maybe<Scalars['String']['output']>;
  /** Argument Type */
  argType?: Maybe<Scalars['String']['output']>;
  /** Argument */
  argument?: Maybe<Scalars['String']['output']>;
  /** Transaction hash */
  blockHash?: Maybe<Scalars['String']['output']>;
  /** Call Path */
  callPath?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  /** Epoch */
  epoch?: Maybe<Scalars['BitqueryBigInt']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Value */
  external?: Maybe<Scalars['Int']['output']>;
  /** Hash of the block where this transaction was in */
  ledger?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** The number of transactions made by the sender prior to this one. */
  nonce?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Number */
  number?: Maybe<Scalars['String']['output']>;
  /** Address of the receiver */
  receiver?: Maybe<Scalars['String']['output']>;
  /** Address of the sender */
  sender?: Maybe<Scalars['String']['output']>;
  /** ShardID */
  shardId?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Signature ID */
  signatureId?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Address of the smart contract */
  smartContractAddress?: Maybe<Scalars['String']['output']>;
  /** Id of the smart contract */
  smartContractId?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** To Shard ID */
  toShardId?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Value */
  value?: Maybe<Scalars['String']['output']>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryHarmonyArgumentsAnyArgs = {
  of: BitqueryHarmonyArgumentsMeasureable;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryHarmonyArgumentsArgumentArgs = {
  argument?: InputMaybe<Scalars['String']['input']>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryHarmonyArgumentsBlockHashArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryHarmonyArgumentsCountArgs = {
  uniq?: InputMaybe<BitqueryHarmonyArgumentsUniq>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryHarmonyArgumentsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryHarmonyArgumentsLedgerArgs = {
  ledger?: InputMaybe<BitqueryBlockSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryHarmonyArgumentsMaximumArgs = {
  get?: InputMaybe<BitqueryHarmonyArgumentsMeasureable>;
  of: BitqueryHarmonyArgumentsMeasureable;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryHarmonyArgumentsMinimumArgs = {
  get?: InputMaybe<BitqueryHarmonyArgumentsMeasureable>;
  of: BitqueryHarmonyArgumentsMeasureable;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryHarmonyArgumentsReceiverArgs = {
  receiver?: InputMaybe<BitqueryHashSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryHarmonyArgumentsSenderArgs = {
  sender?: InputMaybe<BitqueryHashSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryHarmonyArgumentsSmartContractAddressArgs = {
  smartContractAddress?: InputMaybe<BitqueryHashSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryHarmonyArgumentsSmartContractIdArgs = {
  smartContractAddress?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryHarmonyArgumentsFilter = {
  argument?: InputMaybe<BitqueryStringSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  ledger?: InputMaybe<BitqueryBlockSelector>;
  nonce?: InputMaybe<BitqueryBigIntIdSelector>;
  receiver?: InputMaybe<BitqueryHashSelector>;
  sender?: InputMaybe<BitqueryHashSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryHashSelector>;
  smartContractId?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  toShardId?: InputMaybe<BitqueryBigIntegerSelector>;
  txIndex?: InputMaybe<BitqueryBigIntegerSelector>;
};

export enum BitqueryHarmonyArgumentsMeasureable {
  /** Address */
  Address = 'address',
  /** Block hash */
  BlockHash = 'block_hash',
  /** Date */
  Date = 'date',
  /** Epoch */
  Epoch = 'epoch',
  /** Nonce */
  Nonce = 'nonce',
  /** Address of  the receive */
  Receiver = 'receiver',
  /** Address of the sender */
  Sender = 'sender',
  /** Shard ID */
  ShardId = 'shard_id',
  /** Signature */
  Signature = 'signature',
  /** Hash of the signature */
  SignatureHash = 'signature_hash',
  /** Name of the signature */
  SignatureName = 'signature_name',
  /** Address of the smart contract */
  SmartContractAddress = 'smart_contract_address',
  /** Id of the smart contract */
  SmartContractId = 'smart_contract_id',
  /** Time */
  Time = 'time',
  /** TO Shard ID */
  ToShardId = 'to_shard_id',
  /** TX Index */
  TxIndex = 'tx_index',
  /** Value */
  Value = 'value'
}

export enum BitqueryHarmonyArgumentsUniq {
  /** Unique addresses */
  Address = 'address',
  /** Unique block hash count */
  BlockHash = 'block_hash',
  /** Unique date count */
  Dates = 'dates',
  /** Unique ledger count */
  Ledger = 'ledger',
  /** Unique address of the receiver */
  Receiver = 'receiver',
  /** Unique address of the sender */
  Sender = 'sender',
  /** Unique smart contract address */
  SmartContractAddress = 'smart_contract_address',
  /** Unique time */
  Times = 'times',
  /** Unique transaction hash */
  Txs = 'txs'
}

/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocks = {
  __typename?: 'BitqueryHarmonyBlocks';
  any?: Maybe<Scalars['String']['output']>;
  /** Transaction hash */
  blockHash?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  /** Difficulty */
  difficulty?: Maybe<Scalars['String']['output']>;
  /** Epoch */
  epoch?: Maybe<Scalars['BitqueryBigInt']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** The extra data field of this block */
  extraData?: Maybe<Scalars['String']['output']>;
  gasLimit?: Maybe<Scalars['Float']['output']>;
  gasUsed?: Maybe<Scalars['Float']['output']>;
  /** Hash of the block where this transaction was in */
  ledger?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The bloom filter for the logs of the block. null when its pending block */
  logsBloom?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Transaction hash */
  miner?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Mix Hash */
  mixHash?: Maybe<Scalars['String']['output']>;
  /** Nonce */
  nonce?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Parent hash */
  parentHash?: Maybe<Scalars['String']['output']>;
  /** Receipts Root */
  receiptsRoot?: Maybe<Scalars['String']['output']>;
  /** ShardID */
  shardId?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Integer the size of this block in bytes */
  size?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Staking Transaction Count */
  stakingTransactionsCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The root of the final state trie of the block */
  stateRoot?: Maybe<Scalars['String']['output']>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Transaction Count */
  transactionCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The root of the transaction trie of the block */
  transactionsRoot?: Maybe<Scalars['String']['output']>;
  /** Count of ucles hashes */
  unclesCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** View ID */
  viewId?: Maybe<Scalars['String']['output']>;
};


/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocksAnyArgs = {
  of: BitqueryHarmonyBlocksMeasureable;
};


/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocksBlockHashArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
};


/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocksCountArgs = {
  uniq?: InputMaybe<BitqueryHarmonyBlocksUniq>;
};


/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocksCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryHarmonyBlocksUniq>;
};


/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocksExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocksGasLimitArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  difficulty?: InputMaybe<BitqueryHashSelector>;
  epoch?: InputMaybe<BitqueryBigIntegerSelector>;
  ledger?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<BitqueryHashSelector>;
  nonce?: InputMaybe<BitqueryBigIntegerSelector>;
  parentHash?: InputMaybe<BitqueryHashSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  size?: InputMaybe<BitqueryBigIntegerSelector>;
  stakingTransactionsCount?: InputMaybe<BitqueryHashSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryHashSelector>;
  unclesCount?: InputMaybe<BitqueryHashSelector>;
  viewId?: InputMaybe<BitqueryHashSelector>;
};


/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocksGasUsedArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  difficulty?: InputMaybe<BitqueryHashSelector>;
  epoch?: InputMaybe<BitqueryBigIntegerSelector>;
  ledger?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<BitqueryHashSelector>;
  nonce?: InputMaybe<BitqueryBigIntegerSelector>;
  parentHash?: InputMaybe<BitqueryHashSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  size?: InputMaybe<BitqueryBigIntegerSelector>;
  stakingTransactionsCount?: InputMaybe<BitqueryHashSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryHashSelector>;
  unclesCount?: InputMaybe<BitqueryHashSelector>;
  viewId?: InputMaybe<BitqueryHashSelector>;
};


/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocksLedgerArgs = {
  ledger?: InputMaybe<BitqueryBlockSelector>;
};


/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocksMaximumArgs = {
  get?: InputMaybe<BitqueryHarmonyBlocksMeasureable>;
  of: BitqueryHarmonyBlocksMeasureable;
};


/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocksMinerArgs = {
  miner?: InputMaybe<BitqueryHashSelector>;
};


/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocksMinimumArgs = {
  get?: InputMaybe<BitqueryHarmonyBlocksMeasureable>;
  of: BitqueryHarmonyBlocksMeasureable;
};


/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocksParentHashArgs = {
  parentHash?: InputMaybe<BitqueryHashSelector>;
};


/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocksSizeArgs = {
  size?: InputMaybe<BitqueryHashSelector>;
};


/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocksStakingTransactionsCountArgs = {
  stakingTransactionsCount?: InputMaybe<BitqueryHashSelector>;
};


/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocksTransactionCountArgs = {
  transactionCount?: InputMaybe<BitqueryHashSelector>;
};


/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocksUnclesCountArgs = {
  unclesCount?: InputMaybe<BitqueryHashSelector>;
};


/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocksViewIdArgs = {
  viewId?: InputMaybe<BitqueryHashSelector>;
};

export type BitqueryHarmonyBlocksFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  difficulty?: InputMaybe<BitqueryHashSelector>;
  epoch?: InputMaybe<BitqueryBigIntegerSelector>;
  ledger?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<BitqueryHashSelector>;
  nonce?: InputMaybe<BitqueryBigIntegerSelector>;
  parentHash?: InputMaybe<BitqueryHashSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  size?: InputMaybe<BitqueryBigIntegerSelector>;
  stakingTransactionsCount?: InputMaybe<BitqueryHashSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryHashSelector>;
  unclesCount?: InputMaybe<BitqueryHashSelector>;
  viewId?: InputMaybe<BitqueryHashSelector>;
};

export enum BitqueryHarmonyBlocksMeasureable {
  /** Block hash */
  BlockHash = 'block_hash',
  /** Date */
  Date = 'date',
  /** Gas limit */
  GasLimit = 'gas_limit',
  /** Gas Used */
  GasUsed = 'gas_used',
  /** Parent hash */
  ParetHash = 'paret_hash',
  /** Time */
  Time = 'time',
  /** Transaction Count */
  TransactionCount = 'transaction_count'
}

export enum BitqueryHarmonyBlocksUniq {
  /** Unique block hash count */
  BlockHash = 'block_hash',
  /** Unique date count */
  Dates = 'dates',
  /** Unique ledger count */
  Ledger = 'ledger',
  /** Unique miner count */
  Miner = 'miner',
  /** Unique mix hash count */
  MixHash = 'mix_hash',
  /** Unique parent hash count */
  ParentHash = 'parent_hash',
  /** Unique receipts root count */
  ReceiptsRoot = 'receipts_root',
  /** Unique state root count */
  StateRoot = 'state_root',
  /** Unique time */
  Times = 'times',
  /** Unique transactions root count */
  TransactionsRoot = 'transactions_root'
}

export enum BitqueryHarmonyEventsMeasureable {
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Nonce */
  Nonce = 'nonce',
  /** Shard ID */
  ShardId = 'shard_id',
  /** Smart Contract Method Signature */
  Signature = 'signature',
  /** Smart Contract Method Signature Hash */
  SignatureHash = 'signature_hash',
  /** Smart Contract Method Name */
  SignatureName = 'signature_name',
  /** Smart Contract */
  SmartContract = 'smart_contract',
  /** Time */
  Time = 'time',
  /** To Shard ID */
  ToShardId = 'to_shard_id',
  /** Action From */
  TxFrom = 'tx_from',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Transaction Index */
  TxIndex = 'tx_index',
  /** Action To */
  TxTo = 'tx_to'
}

export enum BitqueryHarmonyNetwork {
  /** Harmony Mainnat */
  Harmony = 'harmony',
  /** Harmony Testnet */
  HarmonyTestnet = 'harmony_testnet'
}

/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCalls = {
  __typename?: 'BitqueryHarmonySmartContractCalls';
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callPath?: Maybe<Scalars['String']['output']>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']['output']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** External call executed explicitly by caller. Internal calls executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']['output']>;
  gas?: Maybe<Scalars['Int']['output']>;
  /** Gas unit price */
  gasPrice: Scalars['Float']['output'];
  gasValue?: Maybe<Scalars['Float']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Nonce */
  nonce?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** ShardID */
  shardId?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Smart contract address */
  smartContractAddress?: Maybe<BitqueryAddress>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<BitqueryMethod>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** ToShardID */
  toShardId?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Action from address */
  txFrom?: Maybe<BitqueryAddress>;
  /** Transaction hash where transfer happened */
  txHash?: Maybe<Scalars['String']['output']>;
  /** Tx index */
  txIndex?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Transaction Sender */
  txSender?: Maybe<BitqueryAddress>;
  /** Action to address */
  txTo?: Maybe<BitqueryAddress>;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsAmountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nonce?: InputMaybe<BitqueryBigIntIdSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  toShardId?: InputMaybe<BitqueryBigIntegerSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryBigIntegerSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsAnyArgs = {
  of: BitqueryHarmonySmartContractCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  nonce?: InputMaybe<BitqueryBigIntIdSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  toShardId?: InputMaybe<BitqueryBigIntegerSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryBigIntegerSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryHarmonySmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  nonce?: InputMaybe<BitqueryBigIntIdSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  toShardId?: InputMaybe<BitqueryBigIntegerSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryBigIntegerSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryHarmonySmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsGasArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  nonce?: InputMaybe<BitqueryBigIntIdSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  toShardId?: InputMaybe<BitqueryBigIntegerSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryBigIntegerSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsGasPriceArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  nonce?: InputMaybe<BitqueryBigIntIdSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  toShardId?: InputMaybe<BitqueryBigIntegerSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryBigIntegerSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsGasValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  nonce?: InputMaybe<BitqueryBigIntIdSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  toShardId?: InputMaybe<BitqueryBigIntegerSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryBigIntegerSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsMaximumArgs = {
  get?: InputMaybe<BitqueryHarmonySmartContractCallsMeasureable>;
  of: BitqueryHarmonySmartContractCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsMinimumArgs = {
  get?: InputMaybe<BitqueryHarmonySmartContractCallsMeasureable>;
  of: BitqueryHarmonySmartContractCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsNonceArgs = {
  nonce?: InputMaybe<BitqueryIntegerSelector>;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsSmartContractMethodArgs = {
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsSuccessArgs = {
  success?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsTxFromArgs = {
  txFrom?: InputMaybe<BitqueryAddressSelector>;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsTxHashArgs = {
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsTxSenderArgs = {
  txSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsTxToArgs = {
  txTo?: InputMaybe<BitqueryAddressSelector>;
};

export type BitqueryHarmonySmartContractCallsFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  nonce?: InputMaybe<BitqueryBigIntIdSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  toShardId?: InputMaybe<BitqueryBigIntegerSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryBigIntegerSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};

export enum BitqueryHarmonySmartContractCallsMeasureable {
  /** Block */
  Block = 'block',
  /** Call depth */
  CallPath = 'call_path',
  /** Date */
  Date = 'date',
  /** External */
  External = 'external',
  /** Nonce */
  Nonce = 'nonce',
  /** Receiver */
  Receiver = 'receiver',
  /** Sender */
  Sender = 'sender',
  /** Shard ID */
  ShardId = 'shard_id',
  /** Smart Contract Method Signature */
  Signature = 'signature',
  /** Smart Contract Method Signature Hash */
  SignatureHash = 'signature_hash',
  /** Smart Contract Method Name */
  SignatureName = 'signature_name',
  /** Smart Contract */
  SmartContract = 'smart_contract',
  /** Success */
  Success = 'success',
  /** Time */
  Time = 'time',
  /** To Shard ID */
  ToShardId = 'to_shard_id',
  /** Action From */
  TxFrom = 'tx_from',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Transaction Index */
  TxIndex = 'tx_index'
}

export enum BitqueryHarmonySmartContractCallsUniq {
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates',
  /** Unique smart contract methods count */
  SmartContractMethods = 'smart_contract_methods',
  /** Unique smart contracts count */
  SmartContracts = 'smart_contracts',
  /** Unique transaction senders */
  TxFrom = 'tx_from',
  /** Unique transactions senders */
  TxSender = 'tx_sender',
  /** Unique callers count */
  TxTo = 'tx_to',
  /** Unique transactions count */
  Txs = 'txs'
}

/** Smart Contract Events */
export type BitqueryHarmonySmartContractEvents = {
  __typename?: 'BitqueryHarmonySmartContractEvents';
  any?: Maybe<Scalars['String']['output']>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']['output']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Transaction hash where transfer happened */
  epoch?: Maybe<Scalars['BitqueryBigInt']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** The number of transactions made by the sender prior to this one. */
  nonce?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** ShardID */
  shardId?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Smart contract address */
  smartContractAddress?: Maybe<BitqueryAddress>;
  /** Contract method invoked */
  smartContractEvent?: Maybe<BitqueryEvent>;
  /** ToShardID */
  toShardId?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Action from address */
  txFrom?: Maybe<BitqueryAddress>;
  /** Transaction hash where transfer happened */
  txHash?: Maybe<Scalars['String']['output']>;
  /** Tx index */
  txIndex?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Action to address */
  txTo?: Maybe<BitqueryAddress>;
};


/** Smart Contract Events */
export type BitqueryHarmonySmartContractEventsAnyArgs = {
  of: BitqueryHarmonyEventsMeasureable;
};


/** Smart Contract Events */
export type BitqueryHarmonySmartContractEventsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Smart Contract Events */
export type BitqueryHarmonySmartContractEventsCountArgs = {
  uniq?: InputMaybe<BitquerySmartContractEventsUniq>;
};


/** Smart Contract Events */
export type BitqueryHarmonySmartContractEventsCountBigIntArgs = {
  uniq?: InputMaybe<BitquerySmartContractEventsUniq>;
};


/** Smart Contract Events */
export type BitqueryHarmonySmartContractEventsEpochArgs = {
  epoch?: InputMaybe<BitqueryIntegerSelector>;
};


/** Smart Contract Events */
export type BitqueryHarmonySmartContractEventsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Smart Contract Events */
export type BitqueryHarmonySmartContractEventsMaximumArgs = {
  get?: InputMaybe<BitqueryHarmonyEventsMeasureable>;
  of: BitqueryHarmonyEventsMeasureable;
};


/** Smart Contract Events */
export type BitqueryHarmonySmartContractEventsMinimumArgs = {
  get?: InputMaybe<BitqueryHarmonyEventsMeasureable>;
  of: BitqueryHarmonyEventsMeasureable;
};


/** Smart Contract Events */
export type BitqueryHarmonySmartContractEventsNonceArgs = {
  nonce?: InputMaybe<BitqueryIntegerSelector>;
};


/** Smart Contract Events */
export type BitqueryHarmonySmartContractEventsSmartContractEventArgs = {
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
};


/** Smart Contract Events */
export type BitqueryHarmonySmartContractEventsTxFromArgs = {
  txFrom?: InputMaybe<BitqueryAddressSelector>;
};


/** Smart Contract Events */
export type BitqueryHarmonySmartContractEventsTxHashArgs = {
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Smart Contract Events */
export type BitqueryHarmonySmartContractEventsTxToArgs = {
  txTo?: InputMaybe<BitqueryAddressSelector>;
};

export type BitqueryHarmonySmartContractEventsFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  nonce?: InputMaybe<BitqueryBigIntIdSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  toShardId?: InputMaybe<BitqueryBigIntegerSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryBigIntegerSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};

/** StakingTransactions in Harmony blockchain */
export type BitqueryHarmonyStakingTransactions = {
  __typename?: 'BitqueryHarmonyStakingTransactions';
  any?: Maybe<Scalars['String']['output']>;
  /** Hash of block */
  blockHash?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Data */
  data?: Maybe<Scalars['String']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  /** Delegator Address */
  delegatorAddress?: Maybe<Scalars['String']['output']>;
  /** Epoch */
  epoch?: Maybe<Scalars['BitqueryBigInt']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Gas provided by the sender */
  gas?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Gas price provided by the sender */
  gasPrice?: Maybe<Scalars['String']['output']>;
  gasValue?: Maybe<Scalars['Float']['output']>;
  /** Hash of the block where this transaction was in */
  ledger?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** The number of transactions made by the sender prior to this one */
  nonce?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** ShardID */
  shardId?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Status */
  status?: Maybe<Scalars['Boolean']['output']>;
  /** Successful of not */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Transaction hash */
  transactionHash?: Maybe<Scalars['String']['output']>;
  /** Transaction type */
  transactionType?: Maybe<Scalars['String']['output']>;
  /** Validator Address */
  validatorAddress?: Maybe<Scalars['String']['output']>;
  /** Value transferred in ATTO */
  value?: Maybe<Scalars['String']['output']>;
};


/** StakingTransactions in Harmony blockchain */
export type BitqueryHarmonyStakingTransactionsAnyArgs = {
  of: BitqueryHarmonyStakingTransactionsMeasureable;
};


/** StakingTransactions in Harmony blockchain */
export type BitqueryHarmonyStakingTransactionsCountArgs = {
  uniq?: InputMaybe<BitqueryHarmonyStakingTransactionsUniq>;
};


/** StakingTransactions in Harmony blockchain */
export type BitqueryHarmonyStakingTransactionsCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryHarmonyStakingTransactionsUniq>;
};


/** StakingTransactions in Harmony blockchain */
export type BitqueryHarmonyStakingTransactionsDelegatorAddressArgs = {
  delegatorAddress?: InputMaybe<BitqueryHashSelector>;
};


/** StakingTransactions in Harmony blockchain */
export type BitqueryHarmonyStakingTransactionsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** StakingTransactions in Harmony blockchain */
export type BitqueryHarmonyStakingTransactionsGasValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  delegatorAddress?: InputMaybe<BitqueryHashSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  ledger?: InputMaybe<BitqueryBlockSelector>;
  nonce?: InputMaybe<BitqueryBigIntIdSelector>;
  shardId?: InputMaybe<BitqueryBigIntIdSelector>;
  status?: InputMaybe<Scalars['Boolean']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionType?: InputMaybe<BitqueryStakingTransactionsTypeSelector>;
  validatorAddress?: InputMaybe<BitqueryHashSelector>;
};


/** StakingTransactions in Harmony blockchain */
export type BitqueryHarmonyStakingTransactionsLedgerArgs = {
  ledger?: InputMaybe<BitqueryBlockSelector>;
};


/** StakingTransactions in Harmony blockchain */
export type BitqueryHarmonyStakingTransactionsMaximumArgs = {
  get?: InputMaybe<BitqueryHarmonyStakingTransactionsMeasureable>;
  of: BitqueryHarmonyStakingTransactionsMeasureable;
};


/** StakingTransactions in Harmony blockchain */
export type BitqueryHarmonyStakingTransactionsMinimumArgs = {
  get?: InputMaybe<BitqueryHarmonyStakingTransactionsMeasureable>;
  of: BitqueryHarmonyStakingTransactionsMeasureable;
};


/** StakingTransactions in Harmony blockchain */
export type BitqueryHarmonyStakingTransactionsStatusArgs = {
  status?: InputMaybe<Scalars['Boolean']['input']>;
};


/** StakingTransactions in Harmony blockchain */
export type BitqueryHarmonyStakingTransactionsSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** StakingTransactions in Harmony blockchain */
export type BitqueryHarmonyStakingTransactionsTransactionHashArgs = {
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** StakingTransactions in Harmony blockchain */
export type BitqueryHarmonyStakingTransactionsTransactionTypeArgs = {
  transactionType?: InputMaybe<BitqueryStakingTransactionsTypeSelector>;
};


/** StakingTransactions in Harmony blockchain */
export type BitqueryHarmonyStakingTransactionsValidatorAddressArgs = {
  validatorAddress?: InputMaybe<BitqueryHashSelector>;
};

export type BitqueryHarmonyStakingTransactionsFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  delegatorAddress?: InputMaybe<BitqueryHashSelector>;
  ledger?: InputMaybe<BitqueryBlockSelector>;
  nonce?: InputMaybe<BitqueryBigIntIdSelector>;
  shardId?: InputMaybe<BitqueryBigIntIdSelector>;
  status?: InputMaybe<Scalars['Boolean']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionType?: InputMaybe<BitqueryStakingTransactionsTypeSelector>;
  validatorAddress?: InputMaybe<BitqueryHashSelector>;
};

export enum BitqueryHarmonyStakingTransactionsMeasureable {
  /** Date */
  Date = 'date',
  /** Deligator Address */
  DeligatorAddress = 'deligator_address',
  /** Gas provided by the sender */
  Gas = 'gas',
  /** Gas price provided by the sender */
  GasPrice = 'gasPrice',
  /** Gas price provided by the sender */
  GasPrice = 'gas_price',
  /** Time */
  Time = 'time',
  /** Transaction Hash */
  TransactionHash = 'transaction_hash',
  /** Validator Address */
  ValidatorAddress = 'validator_address',
  /** Value transferred in ATTO */
  Value = 'value'
}

export enum BitqueryHarmonyStakingTransactionsUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique delegator validator */
  DelegatorAddress = 'delegator_address',
  /** Unique block */
  Ledger = 'ledger',
  /** Unique smart contract addresses */
  SmartContractAddress = 'smart_contract_address',
  /** Unique time */
  Times = 'times',
  /** Unique transaction hash */
  Txs = 'txs',
  /** Unique address validator */
  ValidatorAddress = 'validator_address'
}

/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactions = {
  __typename?: 'BitqueryHarmonyTransactions';
  any?: Maybe<Scalars['String']['output']>;
  /** Hash of the block */
  blockHash?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Transaction creates */
  creates?: Maybe<Scalars['String']['output']>;
  /** Data */
  data?: Maybe<Scalars['String']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  /** Epoch */
  epoch?: Maybe<Scalars['BitqueryBigInt']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  gas?: Maybe<Scalars['Float']['output']>;
  /** Gas price provided by the sender */
  gasPrice?: Maybe<Scalars['String']['output']>;
  gasValue?: Maybe<Scalars['Float']['output']>;
  /** Hash of the block where this transaction was in */
  ledger?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** The number of transactions made by the sender prior to this one */
  nonce?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Address of the receiver */
  receiver?: Maybe<Scalars['String']['output']>;
  /** Address of the sender */
  sender?: Maybe<Scalars['String']['output']>;
  /** ShardID */
  shardId?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Status */
  status?: Maybe<Scalars['Boolean']['output']>;
  /** Successful of not */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** ToShardID */
  toShardId?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Integer of the transactions index position in the block. null when its pending. */
  transactionHash?: Maybe<Scalars['String']['output']>;
  /** Index of the transaction */
  transactionIndex?: Maybe<Scalars['Int']['output']>;
  /** Value transferred in ATTO */
  value?: Maybe<Scalars['String']['output']>;
};


/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactionsAnyArgs = {
  of: BitqueryHarmonyTransactionsMeasureable;
};


/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactionsBlockHashArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
};


/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactionsCountArgs = {
  uniq?: InputMaybe<BitqueryHarmonyTransactionsUniq>;
};


/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactionsCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryHarmonyTransactionsUniq>;
};


/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactionsCreatesArgs = {
  creates?: InputMaybe<BitqueryHashSelector>;
};


/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactionsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactionsGasArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  creates?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryBigIntegerSelector>;
  ledger?: InputMaybe<BitqueryBigIntIdSelector>;
  nonce?: InputMaybe<BitqueryBigIntegerSelector>;
  receiver?: InputMaybe<BitqueryHashSelector>;
  sender?: InputMaybe<BitqueryHashSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  status?: InputMaybe<Scalars['Boolean']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  toShardId?: InputMaybe<BitqueryBigIntegerSelector>;
  transactionHash?: InputMaybe<BitqueryStringSelector>;
  transactionIndex?: InputMaybe<BitqueryHashSelector>;
};


/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactionsGasValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  creates?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryBigIntegerSelector>;
  ledger?: InputMaybe<BitqueryBigIntIdSelector>;
  nonce?: InputMaybe<BitqueryBigIntegerSelector>;
  receiver?: InputMaybe<BitqueryHashSelector>;
  sender?: InputMaybe<BitqueryHashSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  status?: InputMaybe<Scalars['Boolean']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  toShardId?: InputMaybe<BitqueryBigIntegerSelector>;
  transactionHash?: InputMaybe<BitqueryStringSelector>;
  transactionIndex?: InputMaybe<BitqueryHashSelector>;
};


/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactionsLedgerArgs = {
  ledger?: InputMaybe<BitqueryBlockSelector>;
};


/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactionsMaximumArgs = {
  get?: InputMaybe<BitqueryHarmonyTransactionsMeasureable>;
  of: BitqueryHarmonyTransactionsMeasureable;
};


/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactionsMinimumArgs = {
  get?: InputMaybe<BitqueryHarmonyTransactionsMeasureable>;
  of: BitqueryHarmonyTransactionsMeasureable;
};


/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactionsReceiverArgs = {
  receiver?: InputMaybe<BitqueryHashSelector>;
};


/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactionsSenderArgs = {
  sender?: InputMaybe<BitqueryHashSelector>;
};


/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactionsStatusArgs = {
  status?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactionsSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactionsTransactionHashArgs = {
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactionsTransactionIndexArgs = {
  transactionIndex?: InputMaybe<BitqueryHashSelector>;
};

export type BitqueryHarmonyTransactionsFilter = {
  creates?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryBigIntegerSelector>;
  ledger?: InputMaybe<BitqueryBigIntIdSelector>;
  nonce?: InputMaybe<BitqueryBigIntegerSelector>;
  receiver?: InputMaybe<BitqueryHashSelector>;
  sender?: InputMaybe<BitqueryHashSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  status?: InputMaybe<Scalars['Boolean']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  toShardId?: InputMaybe<BitqueryBigIntegerSelector>;
  transactionHash?: InputMaybe<BitqueryStringSelector>;
  transactionIndex?: InputMaybe<BitqueryHashSelector>;
};

export enum BitqueryHarmonyTransactionsMeasureable {
  /** Date */
  Date = 'date',
  /** Gas provided by the sender */
  Gas = 'gas',
  /** Gas price provided by the sender */
  GasPrice = 'gasPrice',
  /** Gas value provided by the sender */
  GasValue = 'gasValue',
  /** Gas price provided by the sender */
  GasPrice = 'gas_price',
  /** Deligator Address */
  Receiver = 'receiver',
  /** Validator Address */
  Sender = 'sender',
  /** Shard ID */
  ShardId = 'shardId',
  /** Status */
  Status = 'status',
  /** Success */
  Success = 'success',
  /** Time */
  Time = 'time',
  /** To Shard ID */
  ToShardId = 'toShardId',
  /** Transaction Hash */
  TransactionHash = 'transactionHash',
  /** Transaction Index */
  TransactionIndex = 'transactionIndex',
  /** Value transferred in ATTO */
  Value = 'value'
}

export enum BitqueryHarmonyTransactionsUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique block */
  Ledger = 'ledger',
  /** Unique receiver */
  Receiver = 'receiver',
  /** Unique sender */
  Sender = 'sender',
  /** Unique time */
  Times = 'times'
}

/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfers = {
  __typename?: 'BitqueryHarmonyTransfers';
  any?: Maybe<Scalars['String']['output']>;
  /** Hash of the block */
  blockHash?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** Data */
  data?: Maybe<Scalars['String']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  /** Entity */
  entityId?: Maybe<Scalars['Int']['output']>;
  /** Epoch */
  epoch?: Maybe<Scalars['BitqueryBigInt']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** External */
  external?: Maybe<Scalars['Boolean']['output']>;
  /** Gas provided by the sender */
  gas?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Gas price provided by the sender */
  gasPrice?: Maybe<Scalars['String']['output']>;
  gasValue?: Maybe<Scalars['Float']['output']>;
  /** Hash of the block where this transaction was in */
  ledger?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** The number of transactions made by the sender prior to this one */
  nonce?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** ShardID */
  shardId?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Staking Tx Type */
  stakingTxType?: Maybe<Scalars['String']['output']>;
  /** Status */
  status?: Maybe<Scalars['Boolean']['output']>;
  /** Successful of not */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** TO Shard ID */
  toShardId?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Integer of the transactions index position in the block. null when its pending. */
  transactionHash?: Maybe<Scalars['String']['output']>;
  /** Index of the transaction */
  transactionIndex?: Maybe<Scalars['Int']['output']>;
  /** Address of the payer */
  transferFrom?: Maybe<BitqueryAddress>;
  /** Address of the receiver */
  transferTo?: Maybe<BitqueryAddress>;
  /** Address of transaction sender */
  txSender?: Maybe<Scalars['String']['output']>;
  /** Address of transaction receiver */
  txTo?: Maybe<Scalars['String']['output']>;
  /** Value transferred in ATTO */
  value?: Maybe<Scalars['String']['output']>;
};


/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfersAnyArgs = {
  of: BitqueryHarmonyTransfersMeasureable;
};


/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfersBlockHashArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
};


/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfersCountArgs = {
  uniq?: InputMaybe<BitqueryHarmonyTransfersUniq>;
};


/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfersCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryHarmonyTransfersUniq>;
};


/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfersCurrencyArgs = {
  currency?: InputMaybe<BitqueryCurrencySelector>;
};


/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfersExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfersExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfersGasValueArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  ledger?: InputMaybe<BitqueryBlockSelector>;
  sender?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<Scalars['Boolean']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transferFrom?: InputMaybe<BitqueryAddressSelector>;
  transferTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfersLedgerArgs = {
  ledger?: InputMaybe<BitqueryBlockSelector>;
};


/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfersMaximumArgs = {
  get?: InputMaybe<BitqueryHarmonyTransfersMeasureable>;
  of: BitqueryHarmonyTransfersMeasureable;
};


/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfersMinimumArgs = {
  get?: InputMaybe<BitqueryHarmonyTransfersMeasureable>;
  of: BitqueryHarmonyTransfersMeasureable;
};


/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfersStatusArgs = {
  status?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfersSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfersTransactionHashArgs = {
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfersTransactionIndexArgs = {
  transactionIndex?: InputMaybe<BitqueryHashSelector>;
};


/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfersTransferFromArgs = {
  transferFrom?: InputMaybe<BitqueryHashSelector>;
};


/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfersTransferToArgs = {
  transferTo?: InputMaybe<BitqueryHashSelector>;
};

export type BitqueryHarmonyTransfersFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryIntIdSelector>;
  ledger?: InputMaybe<BitqueryBlockSelector>;
  sender?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<Scalars['Boolean']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transferFrom?: InputMaybe<BitqueryAddressSelector>;
  transferTo?: InputMaybe<BitqueryAddressSelector>;
};

export enum BitqueryHarmonyTransfersMeasureable {
  /** Block Hash */
  BlockHash = 'block_hash',
  /** Token address */
  CurrencyAddress = 'currency_address',
  /** Currency symbol */
  CurrencySymbol = 'currency_symbol',
  /** Date */
  Date = 'date',
  /** Tx To */
  EntityId = 'entity_id',
  /** Gas provided by the sender */
  Gas = 'gas',
  /** Gas price provided by the sender */
  GasPrice = 'gas_price',
  /** Gas value provided by the sender */
  GasValue = 'gas_value',
  /** Block */
  Ledger = 'ledger',
  /** Validator Address */
  Sender = 'sender',
  /** Staking Tx Type */
  StakingTxType = 'staking_tx_type',
  /** Time */
  Time = 'time',
  /** Token ID */
  TokenId = 'token_id',
  /** Token type */
  TokenType = 'token_type',
  /** Transaction Hash */
  TransactionHash = 'transaction_hash',
  /** Token From */
  TransferFrom = 'transfer_from',
  /** Token To */
  TransferTo = 'transfer_to',
  /** Tx Sender */
  TxSender = 'tx_sender',
  /** Tx To */
  TxTo = 'tx_to',
  /** Value transferred in ATTO */
  Value = 'value'
}

export enum BitqueryHarmonyTransfersUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique block */
  Ledger = 'ledger',
  /** Unique sender */
  Sender = 'sender',
  /** Unique time */
  Times = 'times',
  /** Unique transfer from */
  TransferFrom = 'transfer_from',
  /** Unique transfer to */
  TransferTo = 'transfer_to',
  /** Unique transaction hash */
  Txs = 'txs'
}

/** Select by hash */
export type BitqueryHashSelector = {
  /** Hash in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Hash is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Hash not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Hash not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Hedera Chain */
export type BitqueryHedera = {
  __typename?: 'BitqueryHedera';
  /** Basic information about address */
  address: Array<BitqueryHederaAddressInfoWithBalance>;
  /** Blockchain Arguments */
  arguments?: Maybe<Array<BitqueryHederaArgument>>;
  /** Blockhain Calls */
  calls?: Maybe<Array<BitqueryHederaCall>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryHederaCoinpath>>;
  /** Blockhain Inputs */
  inputs?: Maybe<Array<BitqueryHederaInput>>;
  /** Blockhain Messages */
  messages?: Maybe<Array<BitqueryHederaMessage>>;
  /** Blockchain Outputs */
  outputs?: Maybe<Array<BitqueryHederaOutput>>;
  /** Blockchain Transactions */
  transactions?: Maybe<Array<BitqueryHederaTransaction>>;
};


/** Hedera Chain */
export type BitqueryHederaAddressArgs = {
  address: Array<BitqueryAddressSelectorIn>;
};


/** Hedera Chain */
export type BitqueryHederaArgumentsArgs = {
  any?: InputMaybe<Array<BitqueryHederaArgumentFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  smartContractEntity?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Hedera Chain */
export type BitqueryHederaCallsArgs = {
  any?: InputMaybe<Array<BitqueryHederaCallFilter>>;
  callInput?: InputMaybe<BitqueryHashSelector>;
  callResult?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  smartContractEntity?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Hedera Chain */
export type BitqueryHederaCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCoinpathOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Hedera Chain */
export type BitqueryHederaInputsArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  any?: InputMaybe<Array<BitqueryHederaInputFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transferEntity?: InputMaybe<BitqueryStringSelector>;
};


/** Hedera Chain */
export type BitqueryHederaMessagesArgs = {
  any?: InputMaybe<Array<BitqueryHederaMessageFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionRunningHash?: InputMaybe<BitqueryHashSelector>;
};


/** Hedera Chain */
export type BitqueryHederaOutputsArgs = {
  any?: InputMaybe<Array<BitqueryHederaOutputFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transferEntity?: InputMaybe<BitqueryStringSelector>;
};


/** Hedera Chain */
export type BitqueryHederaTransactionsArgs = {
  any?: InputMaybe<Array<BitqueryHederaTransactionFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};

/** Address detailed information for Hedera network */
export type BitqueryHederaAddressInfoWithBalance = {
  __typename?: 'BitqueryHederaAddressInfoWithBalance';
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Native currency balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** Token balances */
  tokenBalances?: Maybe<Array<BitqueryHederaBalance>>;
};


/** Address detailed information for Hedera network */
export type BitqueryHederaAddressInfoWithBalanceBalanceArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};

/** Arguments in Hedera blockchain */
export type BitqueryHederaArgument = {
  __typename?: 'BitqueryHederaArgument';
  any?: Maybe<Scalars['String']['output']>;
  /** Argument type */
  argtype?: Maybe<Scalars['String']['output']>;
  /** Argument */
  argument?: Maybe<Scalars['String']['output']>;
  chargedTxFee?: Maybe<Scalars['BitqueryBigInt']['output']>;
  consensusTimestamp?: Maybe<BitqueryTimestamp>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Currency of transfer */
  feeCurrency?: Maybe<BitqueryCurrency>;
  initialBalance?: Maybe<Scalars['Float']['output']>;
  maxFee?: Maybe<Scalars['Float']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  memo?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /**
   * Used to reference a specific
   *       account of the node the transaction is being sent to
   */
  nodeAccount?: Maybe<BitqueryAccount>;
  /**
   * Used to
   *       reference a specific account in transactions
   */
  payerAccount?: Maybe<BitqueryAccount>;
  /** Transaction result */
  result?: Maybe<BitqueryTransactionResult>;
  /** Smart contract */
  smartContractEntity?: Maybe<BitqueryAccount>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  transactionBytes?: Maybe<Scalars['String']['output']>;
  transactionFee?: Maybe<Scalars['Float']['output']>;
  /** Transaction hash where transfer happened */
  transactionHash?: Maybe<Scalars['String']['output']>;
  transactionValidDurationInSec?: Maybe<Scalars['Int']['output']>;
  validStart?: Maybe<BitqueryTimestamp>;
  /** Value */
  value?: Maybe<Scalars['String']['output']>;
};


/** Arguments in Hedera blockchain */
export type BitqueryHederaArgumentAnyArgs = {
  of: BitqueryHederaArgumentsMeasureable;
};


/** Arguments in Hedera blockchain */
export type BitqueryHederaArgumentCountArgs = {
  uniq?: InputMaybe<BitqueryHederaArgumentsUniq>;
};


/** Arguments in Hedera blockchain */
export type BitqueryHederaArgumentCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryHederaArgumentsUniq>;
};


/** Arguments in Hedera blockchain */
export type BitqueryHederaArgumentExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Arguments in Hedera blockchain */
export type BitqueryHederaArgumentInitialBalanceArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  smartContractEntity?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Arguments in Hedera blockchain */
export type BitqueryHederaArgumentMaxFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  smartContractEntity?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Arguments in Hedera blockchain */
export type BitqueryHederaArgumentMaximumArgs = {
  get?: InputMaybe<BitqueryHederaArgumentsMeasureable>;
  of: BitqueryHederaArgumentsMeasureable;
};


/** Arguments in Hedera blockchain */
export type BitqueryHederaArgumentMinimumArgs = {
  get?: InputMaybe<BitqueryHederaArgumentsMeasureable>;
  of: BitqueryHederaArgumentsMeasureable;
};


/** Arguments in Hedera blockchain */
export type BitqueryHederaArgumentResultArgs = {
  result?: InputMaybe<BitqueryHashSelector>;
};


/** Arguments in Hedera blockchain */
export type BitqueryHederaArgumentSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Arguments in Hedera blockchain */
export type BitqueryHederaArgumentTransactionFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  smartContractEntity?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Arguments in Hedera blockchain */
export type BitqueryHederaArgumentTransactionHashArgs = {
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Arguments in Hedera blockchain */
export type BitqueryHederaArgumentValidStartArgs = {
  nanoseconds?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

export type BitqueryHederaArgumentFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  smartContractEntity?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};

export enum BitqueryHederaArgumentsMeasureable {
  /** Date */
  Date = 'date',
  /** Max Fee */
  MaxFee = 'max_fee',
  /** Time */
  Time = 'time',
  /** Charged Fee */
  TransactionFee = 'transaction_fee',
  /** Transaction Hash */
  TransactionHash = 'transaction_hash',
  /** Valid duration */
  ValidDuration = 'valid_duration',
  /** Valid start */
  ValidStart = 'valid_start'
}

export enum BitqueryHederaArgumentsUniq {
  /** Unique consensus time */
  ConsensusTimes = 'consensus_times',
  /** Unique date count */
  Dates = 'dates',
  /** Unique initial balance */
  InitialBalance = 'initial_balance',
  /** Unique node account */
  NodeAccount = 'node_account',
  /** Unique payer account */
  PayerAccount = 'payer_account',
  /** Unique node account */
  SmartContractEntity = 'smart_contract_entity',
  /** Unique time */
  Times = 'times',
  /** Unique transaction hash */
  Txs = 'txs'
}

/** Token Balance */
export type BitqueryHederaBalance = {
  __typename?: 'BitqueryHederaBalance';
  /** Staking Balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** Token ID */
  tokenId?: Maybe<Scalars['String']['output']>;
};

/** Calls in Hedera blockchain */
export type BitqueryHederaCall = {
  __typename?: 'BitqueryHederaCall';
  any?: Maybe<Scalars['String']['output']>;
  /** Call input */
  callInput?: Maybe<Scalars['String']['output']>;
  /** Call input */
  callResult?: Maybe<Scalars['String']['output']>;
  chargedTxFee?: Maybe<Scalars['BitqueryBigInt']['output']>;
  consensusTimestamp?: Maybe<BitqueryTimestamp>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Currency of transfer */
  feeCurrency?: Maybe<BitqueryCurrency>;
  gas?: Maybe<Scalars['Int']['output']>;
  initialBalance?: Maybe<Scalars['Float']['output']>;
  maxFee?: Maybe<Scalars['Float']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  memo?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /**
   * Used to reference a specific
   *       account of the node the transaction is being sent to
   */
  nodeAccount?: Maybe<BitqueryAccount>;
  /**
   * Used to
   *       reference a specific account in transactions
   */
  payerAccount?: Maybe<BitqueryAccount>;
  /** Transaction result */
  result?: Maybe<BitqueryTransactionResult>;
  /** Smart contract */
  smartContractEntity?: Maybe<BitqueryAccount>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  transactionBytes?: Maybe<Scalars['String']['output']>;
  transactionFee?: Maybe<Scalars['Float']['output']>;
  /** Transaction hash where transfer happened */
  transactionHash?: Maybe<Scalars['String']['output']>;
  transactionValidDurationInSec?: Maybe<Scalars['Int']['output']>;
  validStart?: Maybe<BitqueryTimestamp>;
};


/** Calls in Hedera blockchain */
export type BitqueryHederaCallAnyArgs = {
  of: BitqueryHederaCallsMeasureable;
};


/** Calls in Hedera blockchain */
export type BitqueryHederaCallCallInputArgs = {
  callInput?: InputMaybe<BitqueryHashSelector>;
};


/** Calls in Hedera blockchain */
export type BitqueryHederaCallCallResultArgs = {
  callResult?: InputMaybe<BitqueryHashSelector>;
};


/** Calls in Hedera blockchain */
export type BitqueryHederaCallCountArgs = {
  uniq?: InputMaybe<BitqueryHederaCallsUniq>;
};


/** Calls in Hedera blockchain */
export type BitqueryHederaCallCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryHederaCallsUniq>;
};


/** Calls in Hedera blockchain */
export type BitqueryHederaCallExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Calls in Hedera blockchain */
export type BitqueryHederaCallGasArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  callInput?: InputMaybe<BitqueryHashSelector>;
  callResult?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  smartContractEntity?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Calls in Hedera blockchain */
export type BitqueryHederaCallInitialBalanceArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  smartContractEntity?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Calls in Hedera blockchain */
export type BitqueryHederaCallMaxFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  smartContractEntity?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Calls in Hedera blockchain */
export type BitqueryHederaCallMaximumArgs = {
  get?: InputMaybe<BitqueryHederaCallsMeasureable>;
  of: BitqueryHederaCallsMeasureable;
};


/** Calls in Hedera blockchain */
export type BitqueryHederaCallMinimumArgs = {
  get?: InputMaybe<BitqueryHederaCallsMeasureable>;
  of: BitqueryHederaCallsMeasureable;
};


/** Calls in Hedera blockchain */
export type BitqueryHederaCallResultArgs = {
  result?: InputMaybe<BitqueryHashSelector>;
};


/** Calls in Hedera blockchain */
export type BitqueryHederaCallSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Calls in Hedera blockchain */
export type BitqueryHederaCallTransactionFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  smartContractEntity?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Calls in Hedera blockchain */
export type BitqueryHederaCallTransactionHashArgs = {
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Calls in Hedera blockchain */
export type BitqueryHederaCallValidStartArgs = {
  nanoseconds?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

export type BitqueryHederaCallFilter = {
  callInput?: InputMaybe<BitqueryHashSelector>;
  callResult?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  smartContractEntity?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};

export enum BitqueryHederaCallsMeasureable {
  /** Date */
  Date = 'date',
  /** Max Fee */
  MaxFee = 'max_fee',
  /** Time */
  Time = 'time',
  /** Charged Fee */
  TransactionFee = 'transaction_fee',
  /** Transaction Hash */
  TransactionHash = 'transaction_hash',
  /** Valid duration */
  ValidDuration = 'valid_duration',
  /** Valid start */
  ValidStart = 'valid_start'
}

export enum BitqueryHederaCallsUniq {
  /** Unique consensus time */
  ConsensusTimes = 'consensus_times',
  /** Unique date count */
  Dates = 'dates',
  /** Unique initial balance */
  InitialBalance = 'initial_balance',
  /** Unique node account */
  NodeAccount = 'node_account',
  /** Unique payer account */
  PayerAccount = 'payer_account',
  /** Unique node account */
  SmartContractEntity = 'smart_contract_entity',
  /** Unique time */
  Times = 'times',
  /** Unique transaction hash */
  Txs = 'txs'
}

/** Coinpath */
export type BitqueryHederaCoinpath = {
  __typename?: 'BitqueryHederaCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryAddress>;
  /** Attributes of transaction included in Coinpath result */
  transactions?: Maybe<Array<BitqueryCoinpathEntry>>;
};


/** Coinpath */
export type BitqueryHederaCoinpathAmountArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Coinpath */
export type BitqueryHederaCoinpathAnyArgs = {
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryHederaCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryHederaCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};

/** Currency selector in Hedera blockchain. */
export type BitqueryHederaCurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Currency not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Inputs in Hedera blockchain */
export type BitqueryHederaInput = {
  __typename?: 'BitqueryHederaInput';
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  consensusTimestamp?: Maybe<BitqueryTimestamp>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Entity */
  entity?: Maybe<BitqueryEntity>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Currency of transfer */
  feeCurrency?: Maybe<BitqueryCurrency>;
  initialBalance?: Maybe<Scalars['Float']['output']>;
  maxFee?: Maybe<Scalars['Float']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  memo?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /**
   * Used to reference a specific
   *       account of the node the transaction is being sent to
   */
  nodeAccount?: Maybe<BitqueryAccount>;
  /**
   * Used to
   *       reference a specific account in transactions
   */
  payerAccount?: Maybe<BitqueryAccount>;
  /** Transaction result */
  result?: Maybe<BitqueryTransactionResult>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Calendar time */
  time?: Maybe<BitqueryDateTime>;
  transactionFee?: Maybe<Scalars['Float']['output']>;
  /** Transaction hash where transfer happened */
  transactionHash?: Maybe<Scalars['String']['output']>;
  transactionValidDurationInSec?: Maybe<Scalars['Int']['output']>;
  /** Transfer Account */
  transferEntity?: Maybe<BitqueryAccount>;
  validStart?: Maybe<BitqueryTimestamp>;
};


/** Inputs in Hedera blockchain */
export type BitqueryHederaInputAmountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transferEntity?: InputMaybe<BitqueryStringSelector>;
};


/** Inputs in Hedera blockchain */
export type BitqueryHederaInputAnyArgs = {
  of: BitqueryHederaInputMeasureable;
};


/** Inputs in Hedera blockchain */
export type BitqueryHederaInputCountArgs = {
  uniq?: InputMaybe<BitqueryHederaInputsUniq>;
};


/** Inputs in Hedera blockchain */
export type BitqueryHederaInputCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryHederaInputsUniq>;
};


/** Inputs in Hedera blockchain */
export type BitqueryHederaInputCurrencyArgs = {
  currency?: InputMaybe<BitqueryHederaCurrencySelector>;
};


/** Inputs in Hedera blockchain */
export type BitqueryHederaInputEntityArgs = {
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
};


/** Inputs in Hedera blockchain */
export type BitqueryHederaInputExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Inputs in Hedera blockchain */
export type BitqueryHederaInputInitialBalanceArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transferEntity?: InputMaybe<BitqueryStringSelector>;
};


/** Inputs in Hedera blockchain */
export type BitqueryHederaInputMaxFeeArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transferEntity?: InputMaybe<BitqueryStringSelector>;
};


/** Inputs in Hedera blockchain */
export type BitqueryHederaInputMaximumArgs = {
  get?: InputMaybe<BitqueryHederaInputMeasureable>;
  of: BitqueryHederaInputMeasureable;
};


/** Inputs in Hedera blockchain */
export type BitqueryHederaInputMinimumArgs = {
  get?: InputMaybe<BitqueryHederaInputMeasureable>;
  of: BitqueryHederaInputMeasureable;
};


/** Inputs in Hedera blockchain */
export type BitqueryHederaInputResultArgs = {
  result?: InputMaybe<BitqueryHashSelector>;
};


/** Inputs in Hedera blockchain */
export type BitqueryHederaInputSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Inputs in Hedera blockchain */
export type BitqueryHederaInputTransactionFeeArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transferEntity?: InputMaybe<BitqueryStringSelector>;
};


/** Inputs in Hedera blockchain */
export type BitqueryHederaInputTransactionHashArgs = {
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Inputs in Hedera blockchain */
export type BitqueryHederaInputValidStartArgs = {
  nanoseconds?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

export type BitqueryHederaInputFilter = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transferEntity?: InputMaybe<BitqueryStringSelector>;
};

export enum BitqueryHederaInputMeasureable {
  /** Amount */
  Amount = 'amount',
  /** Currency Address */
  CurrencyAddress = 'currency_address',
  /** Currency Symbol */
  CurrencySymbol = 'currency_symbol',
  /** Date */
  Date = 'date',
  /** Max Fee */
  MaxFee = 'max_fee',
  /** Time */
  Time = 'time',
  /** Token ID */
  TokenId = 'token_id',
  /** Token Type */
  TokenType = 'token_type',
  /** Charged Fee */
  TransactionFee = 'transaction_fee',
  /** Transaction Hash */
  TransactionHash = 'transaction_hash',
  /** Valid duration */
  ValidDuration = 'valid_duration',
  /** Valid start */
  ValidStart = 'valid_start'
}

export enum BitqueryHederaInputsUniq {
  /** Unique consensus time */
  ConsensusTimes = 'consensus_times',
  /** Unique date count */
  Dates = 'dates',
  /** Unique entity id */
  EntityId = 'entity_id',
  /** Unique entity type */
  EntityType = 'entity_type',
  /** Unique initial balance */
  InitialBalance = 'initial_balance',
  /** Unique node account */
  NodeAccount = 'node_account',
  /** Unique payer account */
  PayerAccount = 'payer_account',
  /** Unique time */
  Times = 'times',
  /** Unique transaction hash */
  Txs = 'txs'
}

/** Messages in Hedera blockchain */
export type BitqueryHederaMessage = {
  __typename?: 'BitqueryHederaMessage';
  any?: Maybe<Scalars['String']['output']>;
  consensusTimestamp?: Maybe<BitqueryTimestamp>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Entity */
  entity?: Maybe<BitqueryEntity>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Currency of transfer */
  feeCurrency?: Maybe<BitqueryCurrency>;
  initialBalance?: Maybe<Scalars['Float']['output']>;
  maxFee?: Maybe<Scalars['Float']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  memo?: Maybe<Scalars['String']['output']>;
  message?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /**
   * Used to reference a specific
   *       account of the node the transaction is being sent to
   */
  nodeAccount?: Maybe<BitqueryAccount>;
  /**
   * Used to
   *       reference a specific account in transactions
   */
  payerAccount?: Maybe<BitqueryAccount>;
  /** Transaction result */
  result?: Maybe<BitqueryTransactionResult>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Calendar date time */
  time?: Maybe<BitqueryDateTime>;
  /** Transaction running hash */
  topicRunningHash?: Maybe<Scalars['String']['output']>;
  /** Transaction running hash */
  topicSequenceNumber?: Maybe<Scalars['String']['output']>;
  transactionFee?: Maybe<Scalars['Float']['output']>;
  /** Transaction hash where transfer happened */
  transactionHash?: Maybe<Scalars['String']['output']>;
  transactionValidDurationInSec?: Maybe<Scalars['Int']['output']>;
  validStart?: Maybe<BitqueryTimestamp>;
};


/** Messages in Hedera blockchain */
export type BitqueryHederaMessageAnyArgs = {
  of: BitqueryHederaMessageMeasureable;
};


/** Messages in Hedera blockchain */
export type BitqueryHederaMessageCountArgs = {
  uniq?: InputMaybe<BitqueryHederaMessagesUniq>;
};


/** Messages in Hedera blockchain */
export type BitqueryHederaMessageCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryHederaMessagesUniq>;
};


/** Messages in Hedera blockchain */
export type BitqueryHederaMessageEntityArgs = {
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
};


/** Messages in Hedera blockchain */
export type BitqueryHederaMessageExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Messages in Hedera blockchain */
export type BitqueryHederaMessageInitialBalanceArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionRunningHash?: InputMaybe<BitqueryHashSelector>;
};


/** Messages in Hedera blockchain */
export type BitqueryHederaMessageMaxFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionRunningHash?: InputMaybe<BitqueryHashSelector>;
};


/** Messages in Hedera blockchain */
export type BitqueryHederaMessageMaximumArgs = {
  get?: InputMaybe<BitqueryHederaMessageMeasureable>;
  of: BitqueryHederaMessageMeasureable;
};


/** Messages in Hedera blockchain */
export type BitqueryHederaMessageMinimumArgs = {
  get?: InputMaybe<BitqueryHederaMessageMeasureable>;
  of: BitqueryHederaMessageMeasureable;
};


/** Messages in Hedera blockchain */
export type BitqueryHederaMessageResultArgs = {
  result?: InputMaybe<BitqueryHashSelector>;
};


/** Messages in Hedera blockchain */
export type BitqueryHederaMessageSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Messages in Hedera blockchain */
export type BitqueryHederaMessageTopicRunningHashArgs = {
  topicRunningHash?: InputMaybe<BitqueryStringSelector>;
};


/** Messages in Hedera blockchain */
export type BitqueryHederaMessageTopicSequenceNumberArgs = {
  topicSequenceNumber?: InputMaybe<BitqueryHashSelector>;
};


/** Messages in Hedera blockchain */
export type BitqueryHederaMessageTransactionFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionRunningHash?: InputMaybe<BitqueryHashSelector>;
};


/** Messages in Hedera blockchain */
export type BitqueryHederaMessageTransactionHashArgs = {
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Messages in Hedera blockchain */
export type BitqueryHederaMessageValidStartArgs = {
  nanoseconds?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

export type BitqueryHederaMessageFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionRunningHash?: InputMaybe<BitqueryHashSelector>;
};

export enum BitqueryHederaMessageMeasureable {
  /** Date */
  Date = 'date',
  /** Max Fee */
  MaxFee = 'max_fee',
  /** Time */
  Time = 'time',
  /** Charged Fee */
  TransactionFee = 'transaction_fee',
  /** Transaction Hash */
  TransactionHash = 'transaction_hash',
  /** Valid duration */
  ValidDuration = 'valid_duration',
  /** Valid start */
  ValidStart = 'valid_start'
}

export enum BitqueryHederaMessagesUniq {
  /** Unique consensus time */
  ConsensusTimes = 'consensus_times',
  /** Unique date count */
  Dates = 'dates',
  /** Unique entity id */
  EntityId = 'entity_id',
  /** Unique entity type */
  EntityType = 'entity_type',
  /** Unique initial balance */
  InitialBalance = 'initial_balance',
  /** Unique node account */
  NodeAccount = 'node_account',
  /** Unique payer account */
  PayerAccount = 'payer_account',
  /** Unique time */
  Times = 'times',
  /** Unique transaction hash */
  Txs = 'txs'
}

export enum BitqueryHederaNetwork {
  /** The Hedera mainnet */
  Hedera = 'hedera',
  /** The Hedera testnets */
  HederaTestnets = 'hedera_testnets'
}

/** Outputs in Hedera blockchain */
export type BitqueryHederaOutput = {
  __typename?: 'BitqueryHederaOutput';
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  consensusTimestamp?: Maybe<BitqueryTimestamp>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Entity */
  entity?: Maybe<BitqueryEntity>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Currency of transfer */
  feeCurrency?: Maybe<BitqueryCurrency>;
  initialBalance?: Maybe<Scalars['Float']['output']>;
  maxFee?: Maybe<Scalars['Float']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  memo?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /**
   * Used to reference a specific
   *       account of the node the transaction is being sent to
   */
  nodeAccount?: Maybe<BitqueryAccount>;
  /**
   * Used to
   *       reference a specific account in transactions
   */
  payerAccount?: Maybe<BitqueryAccount>;
  /** Transaction result */
  result?: Maybe<BitqueryTransactionResult>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Calendar time */
  time?: Maybe<BitqueryDateTime>;
  transactionFee?: Maybe<Scalars['Float']['output']>;
  /** Transaction hash where transfer happened */
  transactionHash?: Maybe<Scalars['String']['output']>;
  transactionValidDurationInSec?: Maybe<Scalars['Int']['output']>;
  /** Transfer Account */
  transferEntity?: Maybe<BitqueryAccount>;
  validStart?: Maybe<BitqueryTimestamp>;
};


/** Outputs in Hedera blockchain */
export type BitqueryHederaOutputAmountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transferEntity?: InputMaybe<BitqueryStringSelector>;
};


/** Outputs in Hedera blockchain */
export type BitqueryHederaOutputAnyArgs = {
  of: BitqueryHederaOutputMeasureable;
};


/** Outputs in Hedera blockchain */
export type BitqueryHederaOutputCountArgs = {
  uniq?: InputMaybe<BitqueryHederaOutputUniq>;
};


/** Outputs in Hedera blockchain */
export type BitqueryHederaOutputCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryHederaOutputUniq>;
};


/** Outputs in Hedera blockchain */
export type BitqueryHederaOutputCurrencyArgs = {
  currency?: InputMaybe<BitqueryHederaCurrencySelector>;
};


/** Outputs in Hedera blockchain */
export type BitqueryHederaOutputEntityArgs = {
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
};


/** Outputs in Hedera blockchain */
export type BitqueryHederaOutputExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Outputs in Hedera blockchain */
export type BitqueryHederaOutputInitialBalanceArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transferEntity?: InputMaybe<BitqueryStringSelector>;
};


/** Outputs in Hedera blockchain */
export type BitqueryHederaOutputMaxFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transferEntity?: InputMaybe<BitqueryStringSelector>;
};


/** Outputs in Hedera blockchain */
export type BitqueryHederaOutputMaximumArgs = {
  get?: InputMaybe<BitqueryHederaOutputMeasureable>;
  of: BitqueryHederaOutputMeasureable;
};


/** Outputs in Hedera blockchain */
export type BitqueryHederaOutputMinimumArgs = {
  get?: InputMaybe<BitqueryHederaOutputMeasureable>;
  of: BitqueryHederaOutputMeasureable;
};


/** Outputs in Hedera blockchain */
export type BitqueryHederaOutputResultArgs = {
  result?: InputMaybe<BitqueryHashSelector>;
};


/** Outputs in Hedera blockchain */
export type BitqueryHederaOutputSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Outputs in Hedera blockchain */
export type BitqueryHederaOutputTransactionFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transferEntity?: InputMaybe<BitqueryStringSelector>;
};


/** Outputs in Hedera blockchain */
export type BitqueryHederaOutputTransactionHashArgs = {
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Outputs in Hedera blockchain */
export type BitqueryHederaOutputValidStartArgs = {
  nanoseconds?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

export type BitqueryHederaOutputFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transferEntity?: InputMaybe<BitqueryStringSelector>;
};

export enum BitqueryHederaOutputMeasureable {
  /** Amount */
  Amount = 'amount',
  /** Currency Address */
  CurrencyAddress = 'currency_address',
  /** Currency Symbol */
  CurrencySymbol = 'currency_symbol',
  /** Date */
  Date = 'date',
  /** Max Fee */
  MaxFee = 'max_fee',
  /** Time */
  Time = 'time',
  /** Token ID */
  TokenId = 'token_id',
  /** Token Type */
  TokenType = 'token_type',
  /** Charged Fee */
  TransactionFee = 'transaction_fee',
  /** Transaction Hash */
  TransactionHash = 'transaction_hash',
  /** Valid duration */
  ValidDuration = 'valid_duration',
  /** Valid start */
  ValidStart = 'valid_start'
}

export enum BitqueryHederaOutputUniq {
  /** Unique consensus time */
  ConsensusTimes = 'consensus_times',
  /** Unique date count */
  Dates = 'dates',
  /** Unique entity id */
  EntityId = 'entity_id',
  /** Unique entity type */
  EntityType = 'entity_type',
  /** Unique initial balance */
  InitialBalance = 'initial_balance',
  /** Unique node account */
  NodeAccount = 'node_account',
  /** Unique payer account */
  PayerAccount = 'payer_account',
  /** Unique time */
  Times = 'times',
  /** Unique Transfer entity */
  TransferEntity = 'transfer_entity',
  /** Unique transaction hash */
  Txs = 'txs'
}

/** Transactions in Hedera blockchain */
export type BitqueryHederaTransaction = {
  __typename?: 'BitqueryHederaTransaction';
  any?: Maybe<Scalars['String']['output']>;
  consensusTimestamp?: Maybe<BitqueryTimestamp>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Entity */
  entity?: Maybe<BitqueryEntity>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Currency of transfer */
  feeCurrency?: Maybe<BitqueryCurrency>;
  initialBalance?: Maybe<Scalars['Float']['output']>;
  maxFee?: Maybe<Scalars['Float']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  memo?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /**
   * Used to reference a specific
   *       account of the node the transaction is being sent to
   */
  nodeAccount?: Maybe<BitqueryAccount>;
  /**
   * Used to
   *       reference a specific account in transactions
   */
  payerAccount?: Maybe<BitqueryAccount>;
  /** Transaction result */
  result?: Maybe<BitqueryTransactionResult>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Calendar time */
  time?: Maybe<BitqueryDateTime>;
  transactionBytes?: Maybe<Scalars['String']['output']>;
  transactionFee?: Maybe<Scalars['Float']['output']>;
  /** Transaction hash where transfer happened */
  transactionHash?: Maybe<Scalars['String']['output']>;
  /** Transaction Type */
  transactionType?: Maybe<Scalars['String']['output']>;
  transactionValidDurationInSec?: Maybe<Scalars['Int']['output']>;
  validStart?: Maybe<BitqueryTimestamp>;
};


/** Transactions in Hedera blockchain */
export type BitqueryHederaTransactionAnyArgs = {
  of: BitqueryHederaTransactionMeasureable;
};


/** Transactions in Hedera blockchain */
export type BitqueryHederaTransactionCountArgs = {
  uniq?: InputMaybe<BitqueryHederaTransactionsUniq>;
};


/** Transactions in Hedera blockchain */
export type BitqueryHederaTransactionCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryHederaTransactionsUniq>;
};


/** Transactions in Hedera blockchain */
export type BitqueryHederaTransactionEntityArgs = {
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
};


/** Transactions in Hedera blockchain */
export type BitqueryHederaTransactionExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transactions in Hedera blockchain */
export type BitqueryHederaTransactionInitialBalanceArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Transactions in Hedera blockchain */
export type BitqueryHederaTransactionMaxFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Transactions in Hedera blockchain */
export type BitqueryHederaTransactionMaximumArgs = {
  get?: InputMaybe<BitqueryHederaTransactionMeasureable>;
  of: BitqueryHederaTransactionMeasureable;
};


/** Transactions in Hedera blockchain */
export type BitqueryHederaTransactionMinimumArgs = {
  get?: InputMaybe<BitqueryHederaTransactionMeasureable>;
  of: BitqueryHederaTransactionMeasureable;
};


/** Transactions in Hedera blockchain */
export type BitqueryHederaTransactionResultArgs = {
  result?: InputMaybe<BitqueryHashSelector>;
};


/** Transactions in Hedera blockchain */
export type BitqueryHederaTransactionSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Transactions in Hedera blockchain */
export type BitqueryHederaTransactionTransactionFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Transactions in Hedera blockchain */
export type BitqueryHederaTransactionTransactionHashArgs = {
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Transactions in Hedera blockchain */
export type BitqueryHederaTransactionValidStartArgs = {
  nanoseconds?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

export type BitqueryHederaTransactionFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};

export enum BitqueryHederaTransactionMeasureable {
  /** Date */
  Date = 'date',
  /** Max Fee */
  MaxFee = 'max_fee',
  /** Time */
  Time = 'time',
  /** Charged Fee */
  TransactionFee = 'transaction_fee',
  /** Transaction Hash */
  TransactionHash = 'transaction_hash',
  /** Valid duration */
  ValidDuration = 'valid_duration',
  /** Valid start */
  ValidStart = 'valid_start'
}

export enum BitqueryHederaTransactionsUniq {
  /** Unique consensus time */
  ConsensusTimes = 'consensus_times',
  /** Unique date count */
  Dates = 'dates',
  /** Unique entity id */
  EntityId = 'entity_id',
  /** Unique entity type */
  EntityType = 'entity_type',
  /** Unique initial balance */
  InitialBalance = 'initial_balance',
  /** Unique node account */
  NodeAccount = 'node_account',
  /** Unique payer account */
  PayerAccount = 'payer_account',
  /** Unique time */
  Times = 'times',
  /** Unique transaction type */
  TransactionType = 'transaction_type'
}

/** Input Script Type of UTXO transaction input */
export type BitqueryInputScript = {
  __typename?: 'BitqueryInputScript';
  /** Script annotation */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Long script pattern */
  pattern: Scalars['String']['output'];
  /** Short script pattern */
  shortPattern: Scalars['String']['output'];
  /** Simple script pattern */
  simplePattern: Scalars['String']['output'];
  /** Script type */
  type?: Maybe<Scalars['String']['output']>;
};

/** Solana Instruction */
export type BitqueryInstruction = {
  __typename?: 'BitqueryInstruction';
  action?: Maybe<BitqueryAction>;
  callPath?: Maybe<Scalars['String']['output']>;
  external?: Maybe<Scalars['Boolean']['output']>;
  program?: Maybe<BitqueryProgram>;
};

/** Solana Instruction */
export type BitqueryInstructionWithExternals = {
  __typename?: 'BitqueryInstructionWithExternals';
  action?: Maybe<BitqueryAction>;
  callPath?: Maybe<Scalars['String']['output']>;
  external?: Maybe<Scalars['Boolean']['output']>;
  externalAction?: Maybe<BitqueryAction>;
  externalProgram?: Maybe<BitqueryProgram>;
  program?: Maybe<BitqueryProgram>;
};

/** Select by ID */
export type BitqueryIntIdSelector = {
  /** ID in range */
  between?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** ID greater than */
  gt?: InputMaybe<Scalars['Int']['input']>;
  /** ID greater or equal than */
  gteq?: InputMaybe<Scalars['Int']['input']>;
  /** ID in the list */
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** ID is */
  is?: InputMaybe<Scalars['Int']['input']>;
  /** ID less than */
  lt?: InputMaybe<Scalars['Int']['input']>;
  /** ID less or equal than */
  lteq?: InputMaybe<Scalars['Int']['input']>;
  /** ID not */
  not?: InputMaybe<Scalars['Int']['input']>;
  /** ID not in the list */
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** Select limited upper number */
export type BitqueryIntegerLimitedSelector = {
  /** in range */
  between?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** in the list */
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** is */
  is?: InputMaybe<Scalars['Int']['input']>;
  /** less than */
  lt?: InputMaybe<Scalars['Int']['input']>;
  /** less or equal than */
  lteq?: InputMaybe<Scalars['Int']['input']>;
};

/** Select by number */
export type BitqueryIntegerSelector = {
  /** in range */
  between?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** greater than */
  gt?: InputMaybe<Scalars['Int']['input']>;
  /** greater or equal than */
  gteq?: InputMaybe<Scalars['Int']['input']>;
  /** in the list */
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** is */
  is?: InputMaybe<Scalars['Int']['input']>;
  /** less than */
  lt?: InputMaybe<Scalars['Int']['input']>;
  /** less or equal than */
  lteq?: InputMaybe<Scalars['Int']['input']>;
  /** not */
  not?: InputMaybe<Scalars['Int']['input']>;
  /** not in the list */
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** Libra */
export type BitqueryLibra = {
  __typename?: 'BitqueryLibra';
  /** Libra Network Blocks */
  blocks?: Maybe<Array<BitqueryLibraBlock>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryLibraCoinpath>>;
  /** Libra Network Currency Minting */
  mints?: Maybe<Array<BitqueryLibraMints>>;
  /** Libra Network Transactions */
  transactions?: Maybe<Array<BitqueryLibraTransactions>>;
  /** Libra Network Currency Transfers */
  transfers?: Maybe<Array<BitqueryLibraTransfers>>;
};


/** Libra */
export type BitqueryLibraBlocksArgs = {
  any?: InputMaybe<Array<BitqueryLibraBlockFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  metadata?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  proposer?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Libra */
export type BitqueryLibraCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCoinpathOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Libra */
export type BitqueryLibraMintsArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  any?: InputMaybe<Array<BitqueryLibraMintFilter>>;
  block?: InputMaybe<BitqueryBlockSelector>;
  currency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  minter?: InputMaybe<BitqueryAddressSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Libra */
export type BitqueryLibraTransactionsArgs = {
  any?: InputMaybe<Array<BitqueryLibraTransactionFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  scriptHash?: InputMaybe<BitqueryStringSelector>;
  scriptType?: InputMaybe<BitqueryScriptTypeSelectorSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txSender?: InputMaybe<BitqueryAddressSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Libra */
export type BitqueryLibraTransfersArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  any?: InputMaybe<Array<BitqueryLibraTransferFilter>>;
  currency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  scriptHash?: InputMaybe<BitqueryStringSelector>;
  scriptType?: InputMaybe<BitqueryScriptTypeSelectorSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txSender?: InputMaybe<BitqueryAddressSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};

/** Block */
export type BitqueryLibraBlock = {
  __typename?: 'BitqueryLibraBlock';
  any?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  gasUsed?: Maybe<Scalars['Float']['output']>;
  /** Block round in blockchain */
  height: Scalars['Int']['output'];
  /** Key */
  key?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Metadata */
  metadata?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Proposer */
  proposer?: Maybe<BitqueryAddress>;
  /** Sequence number */
  sequenceNumber?: Maybe<Scalars['Int']['output']>;
  /** Status Name */
  statusName?: Maybe<Scalars['String']['output']>;
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Version of transaction for this block */
  version: Scalars['Int']['output'];
  /** Version hash of transaction for this block */
  versionHash: Scalars['String']['output'];
  /** VM Status */
  vmStatus?: Maybe<Scalars['Int']['output']>;
};


/** Block */
export type BitqueryLibraBlockAnyArgs = {
  of: BitqueryLibraBlocksMeasureable;
};


/** Block */
export type BitqueryLibraBlockCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  metadata?: InputMaybe<BitqueryStringSelector>;
  proposer?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryLibraBlockUniq>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Block */
export type BitqueryLibraBlockCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  metadata?: InputMaybe<BitqueryStringSelector>;
  proposer?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryLibraBlockUniq>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Block */
export type BitqueryLibraBlockExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Block */
export type BitqueryLibraBlockGasUsedArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  metadata?: InputMaybe<BitqueryStringSelector>;
  proposer?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Block */
export type BitqueryLibraBlockHeightArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Block */
export type BitqueryLibraBlockMaximumArgs = {
  get?: InputMaybe<BitqueryLibraBlocksMeasureable>;
  of: BitqueryLibraBlocksMeasureable;
};


/** Block */
export type BitqueryLibraBlockMetadataArgs = {
  metadata?: InputMaybe<BitqueryStringSelector>;
};


/** Block */
export type BitqueryLibraBlockMinimumArgs = {
  get?: InputMaybe<BitqueryLibraBlocksMeasureable>;
  of: BitqueryLibraBlocksMeasureable;
};


/** Block */
export type BitqueryLibraBlockProposerArgs = {
  proposer?: InputMaybe<BitqueryAddressSelector>;
};


/** Block */
export type BitqueryLibraBlockTimestampArgs = {
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Block */
export type BitqueryLibraBlockVersionArgs = {
  version?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryLibraBlockFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  metadata?: InputMaybe<BitqueryStringSelector>;
  proposer?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};

export enum BitqueryLibraBlockUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Proposer */
  Proposer = 'proposer'
}

export enum BitqueryLibraBlocksMeasureable {
  /** Block round */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Gas Used */
  GasUsed = 'gas_used',
  /** Proposer */
  Proposer = 'proposer',
  /** Time */
  Time = 'time',
  /** Version */
  Version = 'version'
}

/** Coinpath */
export type BitqueryLibraCoinpath = {
  __typename?: 'BitqueryLibraCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<BitqueryLibraTransactionValue>;
};


/** Coinpath */
export type BitqueryLibraCoinpathAmountArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Coinpath */
export type BitqueryLibraCoinpathAnyArgs = {
  of: BitqueryLibraCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryLibraCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryLibraCoinpathMeasureable>;
  of: BitqueryLibraCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryLibraCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryLibraCoinpathMeasureable>;
  of: BitqueryLibraCoinpathMeasureable;
};

export enum BitqueryLibraCoinpathMeasureable {
  /** Block */
  Block = 'block',
  /** Depth */
  Depth = 'depth',
  /** Receiver */
  Receiver = 'receiver',
  /** Sender */
  Sender = 'sender',
  /** Time */
  Time = 'time',
  /** Version */
  Version = 'version'
}

/**
 * Currency selector in Libra blockchain.
 * Libra has native chain currency (LBR) and a number of others ( Coin1/Coin2 ) for Testnet.
 * Use name of currency for selection
 */
export type BitqueryLibraCurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Currency not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type BitqueryLibraMintFilter = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  block?: InputMaybe<BitqueryBlockSelector>;
  currency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  minter?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};

/** Mints in Libra blockchain */
export type BitqueryLibraMints = {
  __typename?: 'BitqueryLibraMints';
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BitqueryBlock>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Minter */
  minter?: Maybe<BitqueryAddress>;
  /** Sequence number */
  sequenceNumber?: Maybe<Scalars['Int']['output']>;
  /** Status Name */
  statusName?: Maybe<Scalars['String']['output']>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Mint timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Version of blockchain for this transaction */
  version: Scalars['Int']['output'];
  /** Version hash of blockchain for this transaction */
  versionHash: Scalars['String']['output'];
  /** VM Status */
  vmStatus?: Maybe<Scalars['Int']['output']>;
};


/** Mints in Libra blockchain */
export type BitqueryLibraMintsAmountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  block?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  minter?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Mints in Libra blockchain */
export type BitqueryLibraMintsAnyArgs = {
  of: BitqueryLibraMintsMeasureable;
};


/** Mints in Libra blockchain */
export type BitqueryLibraMintsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Mints in Libra blockchain */
export type BitqueryLibraMintsCountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  block?: InputMaybe<BitqueryBlockSelector>;
  currency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  minter?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryLibraMintsUniq>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Mints in Libra blockchain */
export type BitqueryLibraMintsCountBigIntArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  block?: InputMaybe<BitqueryBlockSelector>;
  currency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  minter?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryLibraMintsUniq>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Mints in Libra blockchain */
export type BitqueryLibraMintsCurrencyArgs = {
  currency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
};


/** Mints in Libra blockchain */
export type BitqueryLibraMintsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Mints in Libra blockchain */
export type BitqueryLibraMintsMaximumArgs = {
  get?: InputMaybe<BitqueryLibraMintsMeasureable>;
  of: BitqueryLibraMintsMeasureable;
};


/** Mints in Libra blockchain */
export type BitqueryLibraMintsMinimumArgs = {
  get?: InputMaybe<BitqueryLibraMintsMeasureable>;
  of: BitqueryLibraMintsMeasureable;
};


/** Mints in Libra blockchain */
export type BitqueryLibraMintsMinterArgs = {
  sender?: InputMaybe<BitqueryAddressSelector>;
};


/** Mints in Libra blockchain */
export type BitqueryLibraMintsSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Mints in Libra blockchain */
export type BitqueryLibraMintsTimestampArgs = {
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Mints in Libra blockchain */
export type BitqueryLibraMintsVersionArgs = {
  version?: InputMaybe<BitqueryIntegerSelector>;
};

export enum BitqueryLibraMintsMeasureable {
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Currency symbol */
  CurrencySymbol = 'currency_symbol',
  /** Date */
  Date = 'date',
  /** Minter */
  Minter = 'minter',
  /** Time */
  Time = 'time',
  /** Version */
  Version = 'version',
  /** Mint version hash */
  VersionHash = 'version_hash'
}

export enum BitqueryLibraMintsUniq {
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique currencies */
  Currencies = 'currencies',
  /** Unique date count */
  Dates = 'dates',
  /** Unique minters */
  Minters = 'minters',
  /** Unique versions */
  Versions = 'versions'
}

export type BitqueryLibraTransactionFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  scriptHash?: InputMaybe<BitqueryStringSelector>;
  scriptType?: InputMaybe<BitqueryScriptTypeSelectorSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txSender?: InputMaybe<BitqueryAddressSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};

/** Blockchain transaction with value */
export type BitqueryLibraTransactionValue = {
  __typename?: 'BitqueryLibraTransactionValue';
  /** Transaction value */
  value: Scalars['Float']['output'];
  /** Transaction version */
  version: Scalars['Int']['output'];
};

/** Transactions in Libra blockchain */
export type BitqueryLibraTransactions = {
  __typename?: 'BitqueryLibraTransactions';
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BitqueryBlock>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Expiration Time */
  expirationTime?: Maybe<BitqueryDateTime>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  gas?: Maybe<Scalars['Int']['output']>;
  /** Currency of gas */
  gasCurrency?: Maybe<BitqueryCurrency>;
  /** Gas unit price */
  gasPrice: Scalars['Float']['output'];
  gasValue?: Maybe<Scalars['Float']['output']>;
  /** Max gas amount */
  maxGasAmount?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Public key */
  publicKey?: Maybe<Scalars['String']['output']>;
  /** Script Hash */
  scriptHash?: Maybe<Scalars['String']['output']>;
  /** Script Type */
  scriptType?: Maybe<BitqueryScriptTypeSelectorSelector>;
  /** Transaction sender */
  sender?: Maybe<BitqueryAddress>;
  /** Sequence number */
  sequenceNumber?: Maybe<Scalars['Int']['output']>;
  /** Signature */
  signature?: Maybe<Scalars['String']['output']>;
  /** Signature scheme */
  signatureScheme?: Maybe<Scalars['String']['output']>;
  /** Status Name */
  statusName?: Maybe<Scalars['String']['output']>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Version of blockchain for this transaction */
  version: Scalars['Int']['output'];
  /** Version hash of blockchain for this transaction */
  versionHash: Scalars['String']['output'];
  /** VM Status */
  vmStatus?: Maybe<Scalars['Int']['output']>;
};


/** Transactions in Libra blockchain */
export type BitqueryLibraTransactionsAnyArgs = {
  of: BitqueryLibraTransactionsMeasureable;
};


/** Transactions in Libra blockchain */
export type BitqueryLibraTransactionsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transactions in Libra blockchain */
export type BitqueryLibraTransactionsCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  scriptHash?: InputMaybe<BitqueryStringSelector>;
  scriptType?: InputMaybe<BitqueryScriptTypeSelectorSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryLibraTransactionsUniq>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transactions in Libra blockchain */
export type BitqueryLibraTransactionsCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  scriptHash?: InputMaybe<BitqueryStringSelector>;
  scriptType?: InputMaybe<BitqueryScriptTypeSelectorSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryLibraTransactionsUniq>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transactions in Libra blockchain */
export type BitqueryLibraTransactionsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transactions in Libra blockchain */
export type BitqueryLibraTransactionsGasArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  scriptHash?: InputMaybe<BitqueryStringSelector>;
  scriptType?: InputMaybe<BitqueryScriptTypeSelectorSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txSender?: InputMaybe<BitqueryAddressSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transactions in Libra blockchain */
export type BitqueryLibraTransactionsGasCurrencyArgs = {
  gasCurrency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
};


/** Transactions in Libra blockchain */
export type BitqueryLibraTransactionsGasPriceArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  scriptHash?: InputMaybe<BitqueryStringSelector>;
  scriptType?: InputMaybe<BitqueryScriptTypeSelectorSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txSender?: InputMaybe<BitqueryAddressSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transactions in Libra blockchain */
export type BitqueryLibraTransactionsGasValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  scriptHash?: InputMaybe<BitqueryStringSelector>;
  scriptType?: InputMaybe<BitqueryScriptTypeSelectorSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txSender?: InputMaybe<BitqueryAddressSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transactions in Libra blockchain */
export type BitqueryLibraTransactionsMaximumArgs = {
  get?: InputMaybe<BitqueryLibraTransactionsMeasureable>;
  of: BitqueryLibraTransactionsMeasureable;
};


/** Transactions in Libra blockchain */
export type BitqueryLibraTransactionsMinimumArgs = {
  get?: InputMaybe<BitqueryLibraTransactionsMeasureable>;
  of: BitqueryLibraTransactionsMeasureable;
};


/** Transactions in Libra blockchain */
export type BitqueryLibraTransactionsScriptHashArgs = {
  scriptHash?: InputMaybe<BitqueryStringSelector>;
};


/** Transactions in Libra blockchain */
export type BitqueryLibraTransactionsSenderArgs = {
  txSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Transactions in Libra blockchain */
export type BitqueryLibraTransactionsSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Transactions in Libra blockchain */
export type BitqueryLibraTransactionsTimestampArgs = {
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transactions in Libra blockchain */
export type BitqueryLibraTransactionsVersionArgs = {
  version?: InputMaybe<BitqueryIntegerSelector>;
};

export enum BitqueryLibraTransactionsMeasureable {
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Gas used */
  Gas = 'gas',
  /** Gas price */
  GasPrice = 'gas_price',
  /** Script Hash */
  ScriptHash = 'script_hash',
  /** Time */
  Time = 'time',
  /** Transaction Sender */
  TxSender = 'tx_sender',
  /** Version */
  Version = 'version'
}

export enum BitqueryLibraTransactionsUniq {
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates',
  /** Unique transaction script hashes */
  Scripts = 'scripts',
  /** Unique transaction senders */
  Senders = 'senders',
  /** Unique versions */
  Versions = 'versions'
}

export type BitqueryLibraTransferFilter = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  scriptHash?: InputMaybe<BitqueryStringSelector>;
  scriptType?: InputMaybe<BitqueryScriptTypeSelectorSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txSender?: InputMaybe<BitqueryAddressSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};

/** Transfers in Libra blockchain */
export type BitqueryLibraTransfers = {
  __typename?: 'BitqueryLibraTransfers';
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BitqueryBlock>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Expiration Time */
  expirationTime?: Maybe<BitqueryDateTime>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  gas?: Maybe<Scalars['Int']['output']>;
  /** Currency of gas */
  gasCurrency?: Maybe<BitqueryCurrency>;
  /** Gas price */
  gasPrice: Scalars['Float']['output'];
  gasValue?: Maybe<Scalars['Float']['output']>;
  /** Max gas amount */
  maxGasAmount?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Public key */
  publicKey?: Maybe<Scalars['String']['output']>;
  /** Transfer receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Script Hash */
  scriptHash?: Maybe<Scalars['String']['output']>;
  /** Script Type */
  scriptType?: Maybe<BitqueryScriptTypeSelectorSelector>;
  /** Transfer sender */
  sender?: Maybe<BitqueryAddress>;
  /** Sequence number */
  sequenceNumber?: Maybe<Scalars['Int']['output']>;
  /** Signature */
  signature?: Maybe<Scalars['String']['output']>;
  /** Signature scheme */
  signatureScheme?: Maybe<Scalars['String']['output']>;
  /** Status Name */
  statusName?: Maybe<Scalars['String']['output']>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Transfer timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction sender */
  txSender?: Maybe<BitqueryAddress>;
  /** Version of blockchain for this transaction */
  version: Scalars['Int']['output'];
  /** Version hash of blockchain for this transaction */
  versionHash: Scalars['String']['output'];
  /** VM Status */
  vmStatus?: Maybe<Scalars['Int']['output']>;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersAmountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  scriptHash?: InputMaybe<BitqueryStringSelector>;
  scriptType?: InputMaybe<BitqueryScriptTypeSelectorSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txSender?: InputMaybe<BitqueryAddressSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersAnyArgs = {
  of: BitqueryLibraTransfersMeasureable;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersCountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  scriptHash?: InputMaybe<BitqueryStringSelector>;
  scriptType?: InputMaybe<BitqueryScriptTypeSelectorSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryTransfersUniq>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersCountBigIntArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  scriptHash?: InputMaybe<BitqueryStringSelector>;
  scriptType?: InputMaybe<BitqueryScriptTypeSelectorSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryTransfersUniq>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersCurrencyArgs = {
  currency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersGasArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  scriptHash?: InputMaybe<BitqueryStringSelector>;
  scriptType?: InputMaybe<BitqueryScriptTypeSelectorSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txSender?: InputMaybe<BitqueryAddressSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersGasCurrencyArgs = {
  gasCurrency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersGasValueArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  scriptHash?: InputMaybe<BitqueryStringSelector>;
  scriptType?: InputMaybe<BitqueryScriptTypeSelectorSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txSender?: InputMaybe<BitqueryAddressSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersMaximumArgs = {
  get?: InputMaybe<BitqueryLibraTransfersMeasureable>;
  of: BitqueryLibraTransfersMeasureable;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersMinimumArgs = {
  get?: InputMaybe<BitqueryLibraTransfersMeasureable>;
  of: BitqueryLibraTransfersMeasureable;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersReceiverArgs = {
  receiver?: InputMaybe<BitqueryAddressSelector>;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersScriptHashArgs = {
  scriptHash?: InputMaybe<BitqueryStringSelector>;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersSenderArgs = {
  sender?: InputMaybe<BitqueryAddressSelector>;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersTimestampArgs = {
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersTxSenderArgs = {
  txSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersVersionArgs = {
  version?: InputMaybe<BitqueryIntegerSelector>;
};

export enum BitqueryLibraTransfersMeasureable {
  /** Amount */
  Amount = 'amount',
  /** Currency symbol */
  CurrencySymbol = 'currency_symbol',
  /** Date */
  Date = 'date',
  /** Gas used */
  Gas = 'gas',
  /** Gas price */
  GasPrice = 'gas_price',
  /** Gas value */
  GasValue = 'gas_value',
  /** Block */
  Height = 'height',
  /** Receiver */
  Receiver = 'receiver',
  /** Script Hash */
  ScriptHash = 'script_hash',
  /** Sender */
  Sender = 'sender',
  /** Time */
  Time = 'time',
  /** Transfer Sender */
  TxSender = 'tx_sender',
  /** Version */
  Version = 'version',
  /** Version hash */
  VersionHash = 'version_hash'
}

/** Limit by definition */
export type BitqueryLimitByOption = {
  /** Take limit for each combination of the field */
  each: Scalars['String']['input'];
  /** Limit number of results */
  limit?: InputMaybe<Scalars['Int']['input']>;
  /** Offset of results, starting from 0 */
  offset?: InputMaybe<Scalars['Int']['input']>;
};

/** Solana Log */
export type BitqueryLog = {
  __typename?: 'BitqueryLog';
  consumed: Scalars['BitqueryBigInt']['output'];
  instruction: Scalars['String']['output'];
  logs: Scalars['String']['output'];
  result: Scalars['String']['output'];
  totalGas: Scalars['BitqueryBigInt']['output'];
};

/** Blockchain message */
export type BitqueryMessageHash = {
  __typename?: 'BitqueryMessageHash';
  /** Message hash hex representation */
  messageHash: Scalars['String']['output'];
};

/** Smart contract method */
export type BitqueryMethod = {
  __typename?: 'BitqueryMethod';
  /** Name */
  name?: Maybe<Scalars['String']['output']>;
  /** Signature */
  signature?: Maybe<Scalars['String']['output']>;
  /** Signature Hash */
  signatureHash: Scalars['String']['output'];
};

/** Smart contract method. In selector you can use the name, signature or hex hash */
export type BitqueryMethodSelector = {
  /** Method signature in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Method signature is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Method signature not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Method signature not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Query metric object */
export type BitqueryMetric = {
  __typename?: 'BitqueryMetric';
  /** Metric cost */
  cost: Scalars['Float']['output'];
  /** Metric divider */
  divider: Scalars['BitqueryBigInt']['output'];
  /** Metric maximum */
  max: Scalars['BitqueryBigInt']['output'];
  /** Metric maximum unit */
  maxUnit: Scalars['Float']['output'];
  /** Metric minimum */
  min: Scalars['BitqueryBigInt']['output'];
  /** Metric minimum unit */
  minUnit: Scalars['Float']['output'];
  /** Metric name */
  name: Scalars['String']['output'];
  /** Metric price */
  price: Scalars['Float']['output'];
  /** Metric value */
  value: Scalars['BitqueryBigInt']['output'];
  /** Metric value unit */
  valueUnit: Scalars['Float']['output'];
};

/** Query metrics */
export type BitqueryMetrics = {
  __typename?: 'BitqueryMetrics';
  /** Graphql query ID */
  id: Scalars['String']['output'];
  /** Metrics */
  list: Array<BitqueryMetric>;
  /** Points */
  points: Scalars['Float']['output'];
  /** SQL requests count */
  sqlRequestsCount: Scalars['Int']['output'];
};

/** Information about miniblock */
export type BitqueryMiniblockElrond = {
  __typename?: 'BitqueryMiniblockElrond';
  /** Miniblock hash */
  hash?: Maybe<Scalars['String']['output']>;
  /** Hash of the receiver block */
  receiverBlockHash?: Maybe<Scalars['String']['output']>;
  /** Number of the receiver shard */
  receiverShard?: Maybe<Scalars['String']['output']>;
  /** Miniblock type */
  type?: Maybe<Scalars['String']['output']>;
};

/** Name with an identifier */
export type BitqueryNameWithId = {
  __typename?: 'BitqueryNameWithId';
  /** ID */
  id?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Name */
  name?: Maybe<Scalars['String']['output']>;
};

export enum BitqueryNetwork {
  /** Algorand Mainnet (ALGO) */
  Algorand = 'algorand',
  /** Algorand Betanet */
  AlgorandBetanet = 'algorand_betanet',
  /** Algorand Testnet */
  AlgorandTestnet = 'algorand_testnet',
  /** Avalanche C-chain */
  Avalanche = 'avalanche',
  /** Binance DEX */
  Binance = 'binance',
  /** Bitcoin Cash ( BCH ) */
  Bitcash = 'bitcash',
  /** Bitcoin ( BTC ) */
  Bitcoin = 'bitcoin',
  /** Bitcoin SV ( BSV ) */
  Bitcoinsv = 'bitcoinsv',
  /** Binance Smart Chain Mainnet */
  Bsc = 'bsc',
  /** Binance Smart Chain Testnet */
  BscTestnet = 'bsc_testnet',
  /** Cardano ( ADA ) */
  Cardano = 'cardano',
  /** Celo Alfajores Testnet */
  CeloAlfajores = 'celo_alfajores',
  /** Celo Baklava Testnet */
  CeloBaklava = 'celo_baklava',
  /** Celo Mainnet */
  CeloMainnet = 'celo_mainnet',
  /** DEPRECATED. Use celo_mainnet */
  CeloRc1 = 'celo_rc1',
  /** Conflux Hydra */
  ConfluxHydra = 'conflux_hydra',
  /** Conflux Oceanus */
  ConfluxOceanus = 'conflux_oceanus',
  /** Conflux Tethys */
  ConfluxTethys = 'conflux_tethys',
  /** Cosmos Hub */
  Cosmoshub = 'cosmoshub',
  /** Cronos Mainnet */
  Cronos = 'cronos',
  /** Crypto.org Mainnet */
  CryptoMainnet = 'crypto_mainnet',
  /** Crypto.org Croeseid Testnet */
  CryptoTestnet = 'crypto_testnet',
  /** Dash ( DASH ) */
  Dash = 'dash',
  /** Diem Testnet */
  DiemTestnet = 'diem_testnet',
  /** Dogecoin ( DOGE ) */
  Dogecoin = 'dogecoin',
  /** Elrond Mainnet */
  Elrond = 'elrond',
  /** EOS Mainnet */
  Eos = 'eos',
  /** Beacon Chain Ethereum 2.0 */
  Eth2 = 'eth2',
  /** Ethereum Classic */
  Ethclassic = 'ethclassic',
  /** Ethereum Classic ( no reorg from block 10904146) */
  EthclassicReorg = 'ethclassic_reorg',
  /** Ethereum Mainnet */
  Ethereum = 'ethereum',
  /** Ethereum PoW */
  Ethpow = 'ethpow',
  /** Everscale */
  Everscale = 'everscale',
  /** Fantom Mainnet */
  Fantom = 'fantom',
  /** Filecoin Mainnet */
  Filecoin = 'filecoin',
  /** Flow Mainnet */
  Flow = 'flow',
  /** Goerli Ethereum Testnet */
  Goerli = 'goerli',
  /** Harmony Mainnet */
  Harmony = 'harmony',
  /** Harmony Testnet */
  HarmonyTestnet = 'harmony_testnet',
  /** Hedera Hashgraph */
  Hedera = 'hedera',
  /** Heimdall (Matic Verification Network) */
  Heimdall = 'heimdall',
  /** Klaytn Mainnet */
  Klaytn = 'klaytn',
  /** Libra Testnet */
  LibraTestnet = 'libra_testnet',
  /** Litecoin ( LTC ) */
  Litecoin = 'litecoin',
  /** Matic (Polygon) Mainnet */
  Matic = 'matic',
  /** Medalla Ethereum 2.0 Beacon Testnet */
  Medalla = 'medalla',
  /** Moonbeam Mainnet */
  Moonbeam = 'moonbeam',
  /** Ripple XRP Ledger */
  Ripple = 'ripple',
  /** Solana Mainnet */
  Solana = 'solana',
  /** Stellar Ledger */
  Stellar = 'stellar',
  /** Terra Mainnet */
  Terra = 'terra',
  /** Tezos */
  Tezos = 'tezos',
  /** TRON Mainnet */
  Tron = 'tron',
  /** Velas Mainnet */
  Velas = 'velas',
  /** Velas Testnet */
  VelasTestnet = 'velas_testnet',
  /** Zcash ( ZEC ) */
  Zcash = 'zcash'
}

/** Blockchain operation */
export type BitqueryOperationIndexed = {
  __typename?: 'BitqueryOperationIndexed';
  /** Operation index */
  index: Scalars['Int']['output'];
  /** Operation name */
  name: Scalars['String']['output'];
};

/** Blockchain operation */
export type BitqueryOperationIndexedWithAccount = {
  __typename?: 'BitqueryOperationIndexedWithAccount';
  /** Operation index */
  index: Scalars['Int']['output'];
  /** Operation name */
  name: Scalars['String']['output'];
  /** Operation account */
  sourceAccount: BitqueryAddress;
};

/** Select order by ID */
export type BitqueryOrderIdSelector = {
  /** Order ID in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Order ID is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Order ID not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Order ID not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Select by order side */
export type BitqueryOrderSideSelector = {
  /** Order Side in the list */
  in?: InputMaybe<Array<BitqueryBinanceOrderSide>>;
  /** Order Side is */
  is?: InputMaybe<BitqueryBinanceOrderSide>;
  /** Order Side not */
  not?: InputMaybe<BitqueryBinanceOrderSide>;
  /** Order Side not in the list */
  notIn?: InputMaybe<Array<BitqueryBinanceOrderSide>>;
};

/** Select by order status */
export type BitqueryOrderStatusSelector = {
  /** Order Status in the list */
  in?: InputMaybe<Array<BitqueryBinanceOrderStatus>>;
  /** Order Status is */
  is?: InputMaybe<BitqueryBinanceOrderStatus>;
  /** Order Status not */
  not?: InputMaybe<BitqueryBinanceOrderStatus>;
  /** Order Status not in the list */
  notIn?: InputMaybe<Array<BitqueryBinanceOrderStatus>>;
};

/** Select by order time in force */
export type BitqueryOrderTimeInForceSelector = {
  /** Order TimeInForce in the list */
  in?: InputMaybe<Array<BitqueryBinanceOrderTimeInForce>>;
  /** Order TimeInForce is */
  is?: InputMaybe<BitqueryBinanceOrderTimeInForce>;
  /** Order TimeInForce not */
  not?: InputMaybe<BitqueryBinanceOrderTimeInForce>;
  /** Order TimeInForce not in the list */
  notIn?: InputMaybe<Array<BitqueryBinanceOrderTimeInForce>>;
};

/** Select by order type */
export type BitqueryOrderTypeSelector = {
  /** Order Type in the list */
  in?: InputMaybe<Array<BitqueryBinanceOrderType>>;
  /** Order Type is */
  is?: InputMaybe<BitqueryBinanceOrderType>;
  /** Order Type not */
  not?: InputMaybe<BitqueryBinanceOrderType>;
  /** Order Type not in the list */
  notIn?: InputMaybe<Array<BitqueryBinanceOrderType>>;
};

/** Select by output index ( o based ) */
export type BitqueryOutputIndexSelector = {
  /** Output index in range */
  between?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Output index greater than */
  gt?: InputMaybe<Scalars['Int']['input']>;
  /** Output index greater or equal than */
  gteq?: InputMaybe<Scalars['Int']['input']>;
  /** Output index in the list */
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Output index is */
  is?: InputMaybe<Scalars['Int']['input']>;
  /** Output index less than */
  lt?: InputMaybe<Scalars['Int']['input']>;
  /** Output index less or equal than */
  lteq?: InputMaybe<Scalars['Int']['input']>;
  /** Output index not */
  not?: InputMaybe<Scalars['Int']['input']>;
  /** Output index not in the list */
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** Output Script Type of UTXO transaction output */
export type BitqueryOutputScript = {
  __typename?: 'BitqueryOutputScript';
  /** Script annotation */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Long script pattern */
  pattern: Scalars['String']['output'];
  /** Short script pattern */
  short: Scalars['String']['output'];
  /** Simple script pattern */
  simplePattern: Scalars['String']['output'];
  /** Script type */
  type?: Maybe<Scalars['String']['output']>;
};

export enum BitqueryPriceAggregateFunction {
  /** Any value */
  Any = 'any',
  /** Last value */
  AnyLast = 'anyLast',
  /** Average */
  Average = 'average',
  /** Maximum */
  Maximum = 'maximum',
  /** Median */
  Median = 'median',
  /** Minimum */
  Minimum = 'minimum',
  /** Aggregated over interval */
  Sum = 'sum'
}

/** Solana Program */
export type BitqueryProgram = {
  __typename?: 'BitqueryProgram';
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
  parsed: Scalars['Boolean']['output'];
  parsedName: Scalars['String']['output'];
};

export enum BitqueryProtocol {
  /** Algorand */
  Algorand = 'algorand',
  /** Binance DEX */
  Binance = 'binance',
  /** Bitcoin */
  Bitcoin = 'bitcoin',
  /** Cardano */
  Cardano = 'cardano',
  /** Conflux */
  Conflux = 'conflux',
  /** Cosmos */
  Cosmos = 'cosmos',
  /** Elrond */
  Elrond = 'elrond',
  /** EOS */
  Eos = 'eos',
  /** Ethereum */
  Ethereum = 'ethereum',
  /** Everscale */
  Everscale = 'everscale',
  /** Filecoin */
  Filecoin = 'filecoin',
  /** Flow */
  Flow = 'flow',
  /** Harmony */
  Harmony = 'harmony',
  /** Hedera Hashgraph */
  Hedera = 'hedera',
  /** Libra */
  Libra = 'libra',
  /** Ripple XRP Ledger */
  Ripple = 'ripple',
  /** Solana */
  Solana = 'solana',
  /** Stellar Ledger */
  Stellar = 'stellar',
  /** Tezos */
  Tezos = 'tezos',
  /** Tron */
  Tron = 'tron'
}

/** Blockchain Unified GraphQL API */
export type BitqueryQuery = {
  __typename?: 'BitqueryQuery';
  /** Algorand Chains Dataset */
  algorand?: Maybe<BitqueryAlgorand>;
  /** Binance DEX Chain Dataset */
  binance?: Maybe<BitqueryBinance>;
  /** Bitcoin and other UTXO Chains Dataset */
  bitcoin?: Maybe<BitqueryBitcoin>;
  /** Cardano Chain Dataset */
  cardano?: Maybe<BitqueryCardano>;
  /** Conflux Chains Dataset */
  conflux?: Maybe<BitqueryConflux>;
  /** Cosmos Dataset */
  cosmos?: Maybe<BitqueryCosmos>;
  /** Diem ( former Libra ) Testnet Dataset */
  diem?: Maybe<BitqueryLibra>;
  /** Elrond Dataset */
  elrond?: Maybe<BitqueryElrond>;
  /** EOS Mainnet Dataset */
  eos?: Maybe<BitqueryEos>;
  /** Ethereum Mainnet / Classic Chain Datasets */
  ethereum?: Maybe<BitqueryEthereum>;
  /** Ethereum v2.0 Beacon Chain Datasets */
  ethereum2?: Maybe<BitqueryEthereum2>;
  /** Everscale Dataset */
  everscale?: Maybe<BitqueryEverscale>;
  /** Filecoin Dataset */
  filecoin?: Maybe<BitqueryFilecoin>;
  /** Flow Dataset */
  flow?: Maybe<BitqueryFlow>;
  /** Harmony Dataset */
  harmony?: Maybe<BitqueryHarmony>;
  /** Hedera Dataset */
  hedera?: Maybe<BitqueryHedera>;
  /**
   * Query metrics
   * @deprecated DEPRECATED! Please use utilities { metrics }
   */
  metrics?: Maybe<BitqueryMetrics>;
  /** Ripple Dataset */
  ripple?: Maybe<BitqueryRipple>;
  /** Search by query string */
  search?: Maybe<Array<BitqueryResult>>;
  /** Solana Dataset */
  solana?: Maybe<BitquerySolana>;
  /** Stellar Dataset */
  stellar?: Maybe<BitqueryStellar>;
  /** Tezos Dataset */
  tezos?: Maybe<BitqueryTezos>;
  /** Tron Mainnet Dataset */
  tron?: Maybe<BitqueryTron>;
  /** Utilities */
  utilities?: Maybe<BitqueryUtilities>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryAlgorandArgs = {
  network?: InputMaybe<BitqueryAlgorandNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryBitcoinArgs = {
  network?: InputMaybe<BitqueryBitcoinNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryCardanoArgs = {
  network?: InputMaybe<BitqueryCardanoNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryConfluxArgs = {
  network?: InputMaybe<BitqueryConfluxNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryCosmosArgs = {
  network?: InputMaybe<BitqueryCosmosNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryDiemArgs = {
  network?: InputMaybe<BitqueryDiemNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryElrondArgs = {
  network?: InputMaybe<BitqueryElrondNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryEosArgs = {
  network?: InputMaybe<BitqueryEosNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryEthereumArgs = {
  network?: InputMaybe<BitqueryEthereumNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryEthereum2Args = {
  network?: InputMaybe<BitqueryEthereum2Network>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryEverscaleArgs = {
  network?: InputMaybe<BitqueryEverscaleNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryFilecoinArgs = {
  network?: InputMaybe<BitqueryFilecoinNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryFlowArgs = {
  network?: InputMaybe<BitqueryFlowNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryHarmonyArgs = {
  network?: InputMaybe<BitqueryHarmonyNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryHederaArgs = {
  network?: InputMaybe<BitqueryHederaNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryMetricsArgs = {
  options?: InputMaybe<BitquerySeedOptions>;
  queryId: Scalars['String']['input'];
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryRippleArgs = {
  network?: InputMaybe<BitqueryRippleNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQuerySearchArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  network?: InputMaybe<BitqueryNetwork>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  string: Scalars['String']['input'];
};


/** Blockchain Unified GraphQL API */
export type BitqueryQuerySolanaArgs = {
  network?: InputMaybe<BitquerySolanaNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryStellarArgs = {
  network?: InputMaybe<BitqueryStellarNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryTezosArgs = {
  network?: InputMaybe<BitqueryTezosNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryTronArgs = {
  network?: InputMaybe<BitqueryTronNetwork>;
};

/** Limits, Ordering, Constraints */
export type BitqueryQueryOptions = {
  /** Ordering field(s) for ascending */
  asc?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Converting field(s) to integer datatype and then ordering field(s) for ascending */
  ascByInteger?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Ordering field(s) for descending */
  desc?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Converting field(s) to integer datatype and then ordering field(s) for descending */
  descByInteger?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Limit number of results */
  limit?: InputMaybe<Scalars['Int']['input']>;
  /** Limit number of results by specific field */
  limitBy?: InputMaybe<BitqueryLimitByOption>;
  /** Offset of results, starting from 0 */
  offset?: InputMaybe<Scalars['Int']['input']>;
};

/** Solana Receiver */
export type BitqueryReceiver = {
  __typename?: 'BitqueryReceiver';
  address: Scalars['String']['output'];
  mintAccount: Scalars['String']['output'];
  type: Scalars['String']['output'];
};

/** Search result item */
export type BitqueryResult = {
  __typename?: 'BitqueryResult';
  /** Blockchain where result is found */
  network: BitqueryBlockchainNetwork;
  /** Subject in blockchain */
  subject: BitquerySubject;
};

/** Select by reward type */
export type BitqueryRewardTypeSelector = {
  /** Type in the list */
  in?: InputMaybe<Array<BitquerySolanaRewardType>>;
  /** Type is */
  is?: InputMaybe<BitquerySolanaRewardType>;
  /** Type not */
  not?: InputMaybe<BitquerySolanaRewardType>;
  /** Type not in the list */
  notIn?: InputMaybe<Array<BitquerySolanaRewardType>>;
};

/** Ripple Chain */
export type BitqueryRipple = {
  __typename?: 'BitqueryRipple';
  /** Ripple Account Roots */
  accountRoots?: Maybe<Array<BitqueryRippleAccountRoot>>;
  /** Basic information about address */
  address: Array<BitqueryRippleAddressInfo>;
  /** Blockchain Address Statistics */
  addressStats?: Maybe<Array<BitqueryRippleAddressStats>>;
  /** Ripple Balances */
  balances?: Maybe<Array<BitqueryRippleBalance>>;
  /** Ripple Blocks */
  blocks?: Maybe<Array<BitqueryRippleBlock>>;
  /** Ripple Checks */
  checks?: Maybe<Array<BitqueryRippleCheck>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryRippleCoinpath>>;
  /** Ripple Escrows */
  escrows?: Maybe<Array<BitqueryRippleEscrow>>;
  /** Ripple NFTokenOffers */
  nftokenOffers?: Maybe<Array<BitqueryRippleNfTokenOffer>>;
  /** Ripple Offers */
  offers?: Maybe<Array<BitqueryRippleOffer>>;
  /** Ripple Payments */
  payments?: Maybe<Array<BitqueryRipplePayment>>;
  /** Ripple Ripple States */
  rippleStates?: Maybe<Array<BitqueryRippleRippleState>>;
  /** Ripple Transactions */
  transactions?: Maybe<Array<BitqueryRippleTransaction>>;
  /** Ripple Transfers */
  transfers?: Maybe<Array<BitqueryRippleTransfer>>;
};


/** Ripple Chain */
export type BitqueryRippleAccountRootsArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  any?: InputMaybe<Array<BitqueryRippleAccountRootFilter>>;
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  domain?: InputMaybe<BitqueryStringSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  ownerCount?: InputMaybe<BitqueryBigIntIdSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  transferRate?: InputMaybe<BitqueryBigIntIdSelector>;
};


/** Ripple Chain */
export type BitqueryRippleAddressArgs = {
  address: Array<BitqueryAddressSelectorIn>;
};


/** Ripple Chain */
export type BitqueryRippleAddressStatsArgs = {
  address: BitqueryAddressSelector;
  options?: InputMaybe<BitqueryQueryOptions>;
};


/** Ripple Chain */
export type BitqueryRippleBalancesArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  any?: InputMaybe<Array<BitqueryRippleBalanceFilter>>;
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};


/** Ripple Chain */
export type BitqueryRippleBlocksArgs = {
  accountHash?: InputMaybe<BitqueryHashSelector>;
  any?: InputMaybe<Array<BitqueryRippleBlockFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBigIntIdSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  totalCoins?: InputMaybe<BitqueryFloatSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Ripple Chain */
export type BitqueryRippleChecksArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  any?: InputMaybe<Array<BitqueryRippleCheckFilter>>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destination?: InputMaybe<BitqueryStringSelector>;
  destinationTag?: InputMaybe<BitqueryBigIntIdSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  invoiceId?: InputMaybe<BitqueryStringSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sendMax?: InputMaybe<BitqueryFloatSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  sourceTag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};


/** Ripple Chain */
export type BitqueryRippleCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currencyFrom?: InputMaybe<BitqueryCurrencySelector>;
  currencyTo?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCoinpathOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Ripple Chain */
export type BitqueryRippleEscrowsArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  any?: InputMaybe<Array<BitqueryRippleEscrowFilter>>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  cancelAfter?: InputMaybe<BitqueryBigIntIdSelector>;
  condition?: InputMaybe<BitqueryStringSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destination?: InputMaybe<BitqueryStringSelector>;
  destinationTag?: InputMaybe<BitqueryBigIntIdSelector>;
  finishAfter?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sourceTag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};


/** Ripple Chain */
export type BitqueryRippleNftokenOffersArgs = {
  any?: InputMaybe<Array<BitqueryRippleNftokenOfferFilter>>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  bookDirectory?: InputMaybe<BitqueryStringSelector>;
  bookNode?: InputMaybe<BitqueryStringSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationAccount?: InputMaybe<BitqueryAddressSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  fromAccount?: InputMaybe<BitqueryAddressSelector>;
  mount?: InputMaybe<BitqueryFloatSelector>;
  nftokenAmount?: InputMaybe<BitqueryFloatSelector>;
  nftokenCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryBigIntIdSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};


/** Ripple Chain */
export type BitqueryRippleOffersArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  any?: InputMaybe<Array<BitqueryRippleOfferFilter>>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  bookDirectory?: InputMaybe<BitqueryStringSelector>;
  bookNode?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  preTakerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  preTakerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryBigIntIdSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  takerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  takerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};


/** Ripple Chain */
export type BitqueryRipplePaymentsArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  amountCurrency?: InputMaybe<BitqueryCurrencySelector>;
  amountIssuer?: InputMaybe<BitqueryAddressSelector>;
  any?: InputMaybe<Array<BitqueryRipplePaymentFilter>>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  deliverMinAmount?: InputMaybe<BitqueryFloatSelector>;
  deliverMinCurrency?: InputMaybe<BitqueryCurrencySelector>;
  deliverMinIssuer?: InputMaybe<BitqueryAddressSelector>;
  deliveredAmount?: InputMaybe<BitqueryFloatSelector>;
  deliveredCurrency?: InputMaybe<BitqueryCurrencySelector>;
  deliveredIssuer?: InputMaybe<BitqueryAddressSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  invoice?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  partial?: InputMaybe<BitqueryBooleanSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sendMaxAmount?: InputMaybe<BitqueryFloatSelector>;
  sendMaxCurrency?: InputMaybe<BitqueryCurrencySelector>;
  sendMaxIssuer?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  tag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Ripple Chain */
export type BitqueryRippleRippleStatesArgs = {
  any?: InputMaybe<Array<BitqueryRippleRippleStateFilter>>;
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  highAccount?: InputMaybe<BitqueryAddressSelector>;
  lowAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};


/** Ripple Chain */
export type BitqueryRippleTransactionsArgs = {
  accountTxnId?: InputMaybe<BitqueryAddressSelector>;
  any?: InputMaybe<Array<BitqueryRippleTransactionFilter>>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  lastLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  memos?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  result?: InputMaybe<BitqueryStringSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  sourceTag?: InputMaybe<BitqueryBigIntIdSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Ripple Chain */
export type BitqueryRippleTransfersArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  any?: InputMaybe<Array<BitqueryRippleTransferFilter>>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  currencyFromSymbol?: InputMaybe<BitqueryCurrencySelector>;
  currencyToSymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  direction?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};

/** Account root in Ripple blockchain */
export type BitqueryRippleAccountRoot = {
  __typename?: 'BitqueryRippleAccountRoot';
  /** Account */
  account?: Maybe<BitqueryAddress>;
  any?: Maybe<Scalars['String']['output']>;
  balance?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Domain */
  domain?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Flags */
  flags?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<Scalars['String']['output']>;
  ownerCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  prevBalance?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  /** Prev ledger sequence */
  prevLedgerSequence?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Prev txn */
  prevTxnId?: Maybe<Scalars['String']['output']>;
  /** Sequence */
  sequence?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryRippleTransactionDimension>;
  transferRate?: Maybe<Scalars['BitqueryBigInt']['output']>;
};


/** Account root in Ripple blockchain */
export type BitqueryRippleAccountRootAnyArgs = {
  of: BitqueryRippleAccountRootMeasurable;
};


/** Account root in Ripple blockchain */
export type BitqueryRippleAccountRootBalanceArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  domain?: InputMaybe<BitqueryStringSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  operation?: InputMaybe<BitqueryStringSelector>;
  ownerCount?: InputMaybe<BitqueryBigIntIdSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  transferRate?: InputMaybe<BitqueryBigIntIdSelector>;
};


/** Account root in Ripple blockchain */
export type BitqueryRippleAccountRootCountArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  domain?: InputMaybe<BitqueryStringSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  ownerCount?: InputMaybe<BitqueryBigIntIdSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  transferRate?: InputMaybe<BitqueryBigIntIdSelector>;
  uniq?: InputMaybe<BitqueryRippleAccountRootUniq>;
};


/** Account root in Ripple blockchain */
export type BitqueryRippleAccountRootCountBigIntArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  domain?: InputMaybe<BitqueryStringSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  ownerCount?: InputMaybe<BitqueryBigIntIdSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  transferRate?: InputMaybe<BitqueryBigIntIdSelector>;
  uniq?: InputMaybe<BitqueryRippleAccountRootUniq>;
};


/** Account root in Ripple blockchain */
export type BitqueryRippleAccountRootExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Account root in Ripple blockchain */
export type BitqueryRippleAccountRootMaximumArgs = {
  get?: InputMaybe<BitqueryRippleAccountRootMeasurable>;
  of: BitqueryRippleAccountRootMeasurable;
};


/** Account root in Ripple blockchain */
export type BitqueryRippleAccountRootMinimumArgs = {
  get?: InputMaybe<BitqueryRippleAccountRootMeasurable>;
  of: BitqueryRippleAccountRootMeasurable;
};


/** Account root in Ripple blockchain */
export type BitqueryRippleAccountRootOwnerCountArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  domain?: InputMaybe<BitqueryStringSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  operation?: InputMaybe<BitqueryStringSelector>;
  ownerCount?: InputMaybe<BitqueryBigIntIdSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  transferRate?: InputMaybe<BitqueryBigIntIdSelector>;
};


/** Account root in Ripple blockchain */
export type BitqueryRippleAccountRootPrevBalanceArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  domain?: InputMaybe<BitqueryStringSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  operation?: InputMaybe<BitqueryStringSelector>;
  ownerCount?: InputMaybe<BitqueryBigIntIdSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  transferRate?: InputMaybe<BitqueryBigIntIdSelector>;
};


/** Account root in Ripple blockchain */
export type BitqueryRippleAccountRootTransferRateArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  domain?: InputMaybe<BitqueryStringSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  operation?: InputMaybe<BitqueryStringSelector>;
  ownerCount?: InputMaybe<BitqueryBigIntIdSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  transferRate?: InputMaybe<BitqueryBigIntIdSelector>;
};

export type BitqueryRippleAccountRootFilter = {
  account?: InputMaybe<BitqueryAddressSelector>;
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  domain?: InputMaybe<BitqueryStringSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  ownerCount?: InputMaybe<BitqueryBigIntIdSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  transferRate?: InputMaybe<BitqueryBigIntIdSelector>;
};

export enum BitqueryRippleAccountRootMeasurable {
  /** Account */
  Account = 'account',
  /** Balance */
  Balance = 'balance',
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Domain */
  Domain = 'domain',
  /** Flags */
  Flags = 'flags',
  /** Operation */
  Operation = 'operation',
  /** Owner count */
  OwnerCount = 'ownerCount',
  /** Prev balance */
  PrevBalance = 'prevBalance',
  /** Prev ledger sequence */
  PrevLedgerSequence = 'prevLedgerSequence',
  /** Prev txn */
  PrevTxnId = 'prevTxnId',
  /** Sequence */
  Sequence = 'sequence',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TransactionHash = 'transactionHash',
  /** Transaction index */
  TransactionIndex = 'transactionIndex',
  /** Transaction sender */
  TransactionSender = 'transactionSender',
  /** Transaction type */
  TransactionType = 'transactionType',
  /** Transfer rate */
  TransferRate = 'transferRate'
}

export enum BitqueryRippleAccountRootUniq {
  /** Uniq accounts count */
  Accounts = 'accounts',
  /** Uniq blocks count */
  Blocks = 'blocks',
  /** Uniq dates count */
  Dates = 'dates',
  /** Uniq domains count */
  Domains = 'domains',
  /** Uniq flags count */
  Flags = 'flags',
  /** Uniq operations count */
  Operations = 'operations',
  /** Uniq prev ledger sequences count */
  PrevLedgerSequences = 'prevLedgerSequences',
  /** Uniq prev txn ids count */
  PrevTxnIds = 'prevTxnIds',
  /** Uniq sequences count */
  Sequences = 'sequences',
  /** Uniq times count */
  Times = 'times',
  /** Uniq transaction hashes count */
  TransactionHashes = 'transactionHashes',
  /** Uniq transaction indices count */
  TransactionIndices = 'transactionIndices',
  /** Uniq transaction senders count */
  TransactionSenders = 'transactionSenders',
  /** Uniq transaction types count */
  TransactionTypes = 'transactionTypes'
}

/** Address detailed information for Ripple network */
export type BitqueryRippleAddressInfo = {
  __typename?: 'BitqueryRippleAddressInfo';
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** XRP balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** Token Balances */
  tokenBalances?: Maybe<Array<BitqueryRippleTokenBalances>>;
};


/** Address detailed information for Ripple network */
export type BitqueryRippleAddressInfoBalanceArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};

/**
 * Counts and aggregates for the address, transfer count,
 *                   amount, number of distinct currencies,
 *                   times of the first and the last transactions
 */
export type BitqueryRippleAddressStat = {
  __typename?: 'BitqueryRippleAddressStat';
  /** Address */
  address?: Maybe<BitqueryAddress>;
  /** Balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** Days with received */
  daysWithReceived?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Days with sent */
  daysWithSent?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Days with transactions */
  daysWithTransactions?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Days with transfers */
  daysWithTransfers?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** First transfer at */
  firstTransferAt?: Maybe<BitqueryDateTime>;
  /** First tx at */
  firstTxAt?: Maybe<BitqueryDateTime>;
  /** Last transfer at */
  lastTransferAt?: Maybe<BitqueryDateTime>;
  /** Last tx at */
  lastTxAt?: Maybe<BitqueryDateTime>;
  /** Receive Amount */
  receiveAmount?: Maybe<Scalars['Float']['output']>;
  /** Receive from Count */
  receiveFromCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Receive from currencies */
  receiveFromCurrencies?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Receive tx Count */
  receiveTxCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Send Amount */
  sendAmount?: Maybe<Scalars['Float']['output']>;
  /** Send to count */
  sendToCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Send to currencies */
  sendToCurrencies?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Send tx count */
  sendTxCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
};

/** AddressStat */
export type BitqueryRippleAddressStats = {
  __typename?: 'BitqueryRippleAddressStats';
  /** Address With Statistics */
  address?: Maybe<BitqueryRippleAddressStat>;
};

/** Balance in Ripple blockchain */
export type BitqueryRippleBalance = {
  __typename?: 'BitqueryRippleBalance';
  /** Account */
  account?: Maybe<BitqueryAddress>;
  any?: Maybe<Scalars['String']['output']>;
  balance?: Maybe<Scalars['Float']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Flags */
  flags?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Issuer */
  issuer?: Maybe<BitqueryAddress>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<Scalars['String']['output']>;
  prevBalance?: Maybe<Scalars['Float']['output']>;
  /** Prev ledger sequence */
  prevLedgerSequence?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryRippleTransactionDimension>;
};


/** Balance in Ripple blockchain */
export type BitqueryRippleBalanceAnyArgs = {
  of: BitqueryRippleBalanceMeasurable;
};


/** Balance in Ripple blockchain */
export type BitqueryRippleBalanceBalanceArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};


/** Balance in Ripple blockchain */
export type BitqueryRippleBalanceCountArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryRippleBalanceUniq>;
};


/** Balance in Ripple blockchain */
export type BitqueryRippleBalanceCountBigIntArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryRippleBalanceUniq>;
};


/** Balance in Ripple blockchain */
export type BitqueryRippleBalanceExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Balance in Ripple blockchain */
export type BitqueryRippleBalanceMaximumArgs = {
  get?: InputMaybe<BitqueryRippleBalanceMeasurable>;
  of: BitqueryRippleBalanceMeasurable;
};


/** Balance in Ripple blockchain */
export type BitqueryRippleBalanceMinimumArgs = {
  get?: InputMaybe<BitqueryRippleBalanceMeasurable>;
  of: BitqueryRippleBalanceMeasurable;
};


/** Balance in Ripple blockchain */
export type BitqueryRippleBalancePrevBalanceArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryRippleBalanceFilter = {
  account?: InputMaybe<BitqueryAddressSelector>;
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};

export enum BitqueryRippleBalanceMeasurable {
  /** Account */
  Account = 'account',
  /** Balance */
  Balance = 'balance',
  /** Block */
  Block = 'block',
  /** Currency name */
  CurrencyName = 'currencyName',
  /** Currency symbol */
  CurrencySymbol = 'currencySymbol',
  /** Date */
  Date = 'date',
  /** Flags */
  Flags = 'flags',
  /** Issuer */
  Issuer = 'issuer',
  /** Operation */
  Operation = 'operation',
  /** Prev balance */
  PrevBalance = 'prevBalance',
  /** Prev ledger sequence */
  PrevLedgerSequence = 'prevLedgerSequence',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TransactionHash = 'transactionHash',
  /** Transaction index */
  TransactionIndex = 'transactionIndex',
  /** Transaction sender */
  TransactionSender = 'transactionSender',
  /** Transaction type */
  TransactionType = 'transactionType'
}

export enum BitqueryRippleBalanceUniq {
  /** Uniq accounts count */
  Accounts = 'accounts',
  /** Uniq blocks count */
  Blocks = 'blocks',
  /** Uniq currency names count */
  CurrencyNames = 'currencyNames',
  /** Uniq currency symbols count */
  CurrencySymbols = 'currencySymbols',
  /** Uniq dates count */
  Dates = 'dates',
  /** Uniq flags count */
  Flags = 'flags',
  /** Uniq issuers count */
  Issuers = 'issuers',
  /** Uniq operations count */
  Operations = 'operations',
  /** Uniq prev ledger sequences count */
  PrevLedgerSequences = 'prevLedgerSequences',
  /** Uniq times count */
  Times = 'times',
  /** Uniq transaction hashes count */
  TransactionHashes = 'transactionHashes',
  /** Uniq transaction indices count */
  TransactionIndices = 'transactionIndices',
  /** Uniq transaction senders count */
  TransactionSenders = 'transactionSenders',
  /** Uniq transaction types count */
  TransactionTypes = 'transactionTypes'
}

/** Block in Ripple blockchain */
export type BitqueryRippleBlock = {
  __typename?: 'BitqueryRippleBlock';
  /** Account hash */
  accountHash?: Maybe<Scalars['String']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Block hash */
  hash?: Maybe<Scalars['String']['output']>;
  /** Block number (height) in blockchain */
  height?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  totalCoins?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  /** Transaction hash */
  transactionHash?: Maybe<Scalars['String']['output']>;
};


/** Block in Ripple blockchain */
export type BitqueryRippleBlockAnyArgs = {
  of: BitqueryRippleBlockMeasurable;
};


/** Block in Ripple blockchain */
export type BitqueryRippleBlockCountArgs = {
  accountHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  totalCoins?: InputMaybe<BitqueryFloatSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryRippleBlockUniq>;
};


/** Block in Ripple blockchain */
export type BitqueryRippleBlockCountBigIntArgs = {
  accountHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  totalCoins?: InputMaybe<BitqueryFloatSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryRippleBlockUniq>;
};


/** Block in Ripple blockchain */
export type BitqueryRippleBlockExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Block in Ripple blockchain */
export type BitqueryRippleBlockMaximumArgs = {
  get?: InputMaybe<BitqueryRippleBlockMeasurable>;
  of: BitqueryRippleBlockMeasurable;
};


/** Block in Ripple blockchain */
export type BitqueryRippleBlockMinimumArgs = {
  get?: InputMaybe<BitqueryRippleBlockMeasurable>;
  of: BitqueryRippleBlockMeasurable;
};


/** Block in Ripple blockchain */
export type BitqueryRippleBlockTotalCoinsArgs = {
  accountHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  totalCoins?: InputMaybe<BitqueryFloatSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};

export type BitqueryRippleBlockFilter = {
  accountHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  totalCoins?: InputMaybe<BitqueryFloatSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};

export enum BitqueryRippleBlockMeasurable {
  /** Account hash */
  AccountHash = 'accountHash',
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Hash */
  Hash = 'hash',
  /** Time */
  Time = 'time',
  /** Total coins */
  TotalCoins = 'totalCoins',
  /** Transaction hash */
  TransactionHash = 'transactionHash'
}

export enum BitqueryRippleBlockUniq {
  /** Uniq account hashes count */
  AccountHashes = 'accountHashes',
  /** Uniq blocks count */
  Blocks = 'blocks',
  /** Uniq dates count */
  Dates = 'dates',
  /** Uniq hashes count */
  Hashes = 'hashes',
  /** Uniq transaction hashes count */
  TransactionHashes = 'transactionHashes'
}

/** Check in Ripple blockchain */
export type BitqueryRippleCheck = {
  __typename?: 'BitqueryRippleCheck';
  /** Account */
  account?: Maybe<BitqueryAddress>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Destination */
  destination?: Maybe<BitqueryAddress>;
  /** Destination tag */
  destinationTag?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Expiration */
  expiration?: Maybe<Scalars['BitqueryBigInt']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Flags */
  flags?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Invoice */
  invoiceId?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<Scalars['String']['output']>;
  /** Prev ledger sequence */
  prevLedgerSequence?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Prev txn */
  prevTxnId?: Maybe<Scalars['String']['output']>;
  sendMax?: Maybe<Scalars['Float']['output']>;
  /** Sequence */
  sequence?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Source tag */
  sourceTag?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryRippleTransactionDimension>;
};


/** Check in Ripple blockchain */
export type BitqueryRippleCheckAnyArgs = {
  of: BitqueryRippleCheckMeasurable;
};


/** Check in Ripple blockchain */
export type BitqueryRippleCheckCountArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destination?: InputMaybe<BitqueryStringSelector>;
  destinationTag?: InputMaybe<BitqueryBigIntIdSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  invoiceId?: InputMaybe<BitqueryStringSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sendMax?: InputMaybe<BitqueryFloatSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  sourceTag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryRippleCheckUniq>;
};


/** Check in Ripple blockchain */
export type BitqueryRippleCheckCountBigIntArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destination?: InputMaybe<BitqueryStringSelector>;
  destinationTag?: InputMaybe<BitqueryBigIntIdSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  invoiceId?: InputMaybe<BitqueryStringSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sendMax?: InputMaybe<BitqueryFloatSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  sourceTag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryRippleCheckUniq>;
};


/** Check in Ripple blockchain */
export type BitqueryRippleCheckExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Check in Ripple blockchain */
export type BitqueryRippleCheckMaximumArgs = {
  get?: InputMaybe<BitqueryRippleCheckMeasurable>;
  of: BitqueryRippleCheckMeasurable;
};


/** Check in Ripple blockchain */
export type BitqueryRippleCheckMinimumArgs = {
  get?: InputMaybe<BitqueryRippleCheckMeasurable>;
  of: BitqueryRippleCheckMeasurable;
};


/** Check in Ripple blockchain */
export type BitqueryRippleCheckSendMaxArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destination?: InputMaybe<BitqueryStringSelector>;
  destinationTag?: InputMaybe<BitqueryBigIntIdSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  invoiceId?: InputMaybe<BitqueryStringSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sendMax?: InputMaybe<BitqueryFloatSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  sourceTag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryRippleCheckFilter = {
  account?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destination?: InputMaybe<BitqueryStringSelector>;
  destinationTag?: InputMaybe<BitqueryBigIntIdSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  invoiceId?: InputMaybe<BitqueryStringSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sendMax?: InputMaybe<BitqueryFloatSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  sourceTag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};

export enum BitqueryRippleCheckMeasurable {
  /** Account */
  Account = 'account',
  /** Block */
  Block = 'block',
  /** Currency name */
  CurrencyName = 'currencyName',
  /** Currency symbol */
  CurrencySymbol = 'currencySymbol',
  /** Date */
  Date = 'date',
  /** Destination */
  Destination = 'destination',
  /** Destination tag */
  DestinationTag = 'destinationTag',
  /** Expiration */
  Expiration = 'expiration',
  /** Flags */
  Flags = 'flags',
  /** Invoice */
  InvoiceId = 'invoiceId',
  /** Operation */
  Operation = 'operation',
  /** Prev ledger sequence */
  PrevLedgerSequence = 'prevLedgerSequence',
  /** Prev txn */
  PrevTxnId = 'prevTxnId',
  /** Send max */
  SendMax = 'sendMax',
  /** Sequence */
  Sequence = 'sequence',
  /** Source tag */
  SourceTag = 'sourceTag',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TransactionHash = 'transactionHash',
  /** Transaction index */
  TransactionIndex = 'transactionIndex',
  /** Transaction sender */
  TransactionSender = 'transactionSender',
  /** Transaction type */
  TransactionType = 'transactionType'
}

export enum BitqueryRippleCheckUniq {
  /** Uniq accounts count */
  Accounts = 'accounts',
  /** Uniq blocks count */
  Blocks = 'blocks',
  /** Uniq currency names count */
  CurrencyNames = 'currencyNames',
  /** Uniq currency symbols count */
  CurrencySymbols = 'currencySymbols',
  /** Uniq dates count */
  Dates = 'dates',
  /** Uniq destination tags count */
  DestinationTags = 'destinationTags',
  /** Uniq destinations count */
  Destinations = 'destinations',
  /** Uniq expirations count */
  Expirations = 'expirations',
  /** Uniq flags count */
  Flags = 'flags',
  /** Uniq invoice ids count */
  InvoiceIds = 'invoiceIds',
  /** Uniq operations count */
  Operations = 'operations',
  /** Uniq prev ledger sequences count */
  PrevLedgerSequences = 'prevLedgerSequences',
  /** Uniq prev txn ids count */
  PrevTxnIds = 'prevTxnIds',
  /** Uniq sequences count */
  Sequences = 'sequences',
  /** Uniq source tags count */
  SourceTags = 'sourceTags',
  /** Uniq times count */
  Times = 'times',
  /** Uniq transaction hashes count */
  TransactionHashes = 'transactionHashes',
  /** Uniq transaction indices count */
  TransactionIndices = 'transactionIndices',
  /** Uniq transaction senders count */
  TransactionSenders = 'transactionSenders',
  /** Uniq transaction types count */
  TransactionTypes = 'transactionTypes'
}

/** Ripple Coinpath */
export type BitqueryRippleCoinpath = {
  __typename?: 'BitqueryRippleCoinpath';
  /** Summary of transfered value from */
  amountFrom?: Maybe<Scalars['Float']['output']>;
  /** Summary of transfered value to */
  amountTo?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency From of transfer */
  currencyFrom?: Maybe<BitqueryCurrency>;
  /** Currency To of transfer */
  currencyTo?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  /** Destination tag */
  destinationTag?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryStellarCoinpathAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryStellarCoinpathAddress>;
  /** Source tag */
  sourceTag?: Maybe<Scalars['String']['output']>;
  /** Transaction of transfer happened */
  transaction?: Maybe<BitqueryStellarTransactionCoinpathDimension>;
};


/** Ripple Coinpath */
export type BitqueryRippleCoinpathAmountFromArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Ripple Coinpath */
export type BitqueryRippleCoinpathAmountToArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Ripple Coinpath */
export type BitqueryRippleCoinpathAnyArgs = {
  of: BitqueryRippleCoinpathMeasureable;
};


/** Ripple Coinpath */
export type BitqueryRippleCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryRippleCoinpathMeasureable>;
  of: BitqueryRippleCoinpathMeasureable;
};


/** Ripple Coinpath */
export type BitqueryRippleCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryRippleCoinpathMeasureable>;
  of: BitqueryRippleCoinpathMeasureable;
};

export enum BitqueryRippleCoinpathMeasureable {
  /** Block */
  Block = 'block',
  /** Depth */
  Depth = 'depth',
  /** Receiver */
  Receiver = 'receiver',
  /** Sender */
  Sender = 'sender',
  /** Time */
  Time = 'time',
  /** Version */
  TxHash = 'tx_hash'
}

/** Escrow in Ripple blockchain */
export type BitqueryRippleEscrow = {
  __typename?: 'BitqueryRippleEscrow';
  /** Account */
  account?: Maybe<BitqueryAddress>;
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Cancel after */
  cancelAfter?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Condition */
  condition?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Destination */
  destination?: Maybe<BitqueryAddress>;
  /** Destination tag */
  destinationTag?: Maybe<Scalars['BitqueryBigInt']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Finish after */
  finishAfter?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Flags */
  flags?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<Scalars['String']['output']>;
  /** Prev ledger sequence */
  prevLedgerSequence?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Prev txn */
  prevTxnId?: Maybe<Scalars['String']['output']>;
  /** Source tag */
  sourceTag?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryRippleTransactionDimension>;
};


/** Escrow in Ripple blockchain */
export type BitqueryRippleEscrowAmountArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  cancelAfter?: InputMaybe<BitqueryBigIntIdSelector>;
  condition?: InputMaybe<BitqueryStringSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destination?: InputMaybe<BitqueryStringSelector>;
  destinationTag?: InputMaybe<BitqueryBigIntIdSelector>;
  finishAfter?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sourceTag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};


/** Escrow in Ripple blockchain */
export type BitqueryRippleEscrowAnyArgs = {
  of: BitqueryRippleEscrowMeasurable;
};


/** Escrow in Ripple blockchain */
export type BitqueryRippleEscrowCountArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  cancelAfter?: InputMaybe<BitqueryBigIntIdSelector>;
  condition?: InputMaybe<BitqueryStringSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destination?: InputMaybe<BitqueryStringSelector>;
  destinationTag?: InputMaybe<BitqueryBigIntIdSelector>;
  finishAfter?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sourceTag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryRippleEscrowUniq>;
};


/** Escrow in Ripple blockchain */
export type BitqueryRippleEscrowCountBigIntArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  cancelAfter?: InputMaybe<BitqueryBigIntIdSelector>;
  condition?: InputMaybe<BitqueryStringSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destination?: InputMaybe<BitqueryStringSelector>;
  destinationTag?: InputMaybe<BitqueryBigIntIdSelector>;
  finishAfter?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sourceTag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryRippleEscrowUniq>;
};


/** Escrow in Ripple blockchain */
export type BitqueryRippleEscrowExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Escrow in Ripple blockchain */
export type BitqueryRippleEscrowMaximumArgs = {
  get?: InputMaybe<BitqueryRippleEscrowMeasurable>;
  of: BitqueryRippleEscrowMeasurable;
};


/** Escrow in Ripple blockchain */
export type BitqueryRippleEscrowMinimumArgs = {
  get?: InputMaybe<BitqueryRippleEscrowMeasurable>;
  of: BitqueryRippleEscrowMeasurable;
};

export type BitqueryRippleEscrowFilter = {
  account?: InputMaybe<BitqueryAddressSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  cancelAfter?: InputMaybe<BitqueryBigIntIdSelector>;
  condition?: InputMaybe<BitqueryStringSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destination?: InputMaybe<BitqueryStringSelector>;
  destinationTag?: InputMaybe<BitqueryBigIntIdSelector>;
  finishAfter?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sourceTag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};

export enum BitqueryRippleEscrowMeasurable {
  /** Account */
  Account = 'account',
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Cancel after */
  CancelAfter = 'cancelAfter',
  /** Condition */
  Condition = 'condition',
  /** Currency name */
  CurrencyName = 'currencyName',
  /** Currency symbol */
  CurrencySymbol = 'currencySymbol',
  /** Date */
  Date = 'date',
  /** Destination */
  Destination = 'destination',
  /** Destination tag */
  DestinationTag = 'destinationTag',
  /** Finish after */
  FinishAfter = 'finishAfter',
  /** Flags */
  Flags = 'flags',
  /** Operation */
  Operation = 'operation',
  /** Prev ledger sequence */
  PrevLedgerSequence = 'prevLedgerSequence',
  /** Prev txn */
  PrevTxnId = 'prevTxnId',
  /** Source tag */
  SourceTag = 'sourceTag',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TransactionHash = 'transactionHash',
  /** Transaction index */
  TransactionIndex = 'transactionIndex',
  /** Transaction sender */
  TransactionSender = 'transactionSender',
  /** Transaction type */
  TransactionType = 'transactionType'
}

export enum BitqueryRippleEscrowUniq {
  /** Uniq accounts count */
  Accounts = 'accounts',
  /** Uniq blocks count */
  Blocks = 'blocks',
  /** Uniq cancel afters count */
  CancelAfters = 'cancelAfters',
  /** Uniq conditions count */
  Conditions = 'conditions',
  /** Uniq currency names count */
  CurrencyNames = 'currencyNames',
  /** Uniq currency symbols count */
  CurrencySymbols = 'currencySymbols',
  /** Uniq dates count */
  Dates = 'dates',
  /** Uniq destination tags count */
  DestinationTags = 'destinationTags',
  /** Uniq destinations count */
  Destinations = 'destinations',
  /** Uniq finish afters count */
  FinishAfters = 'finishAfters',
  /** Uniq flags count */
  Flags = 'flags',
  /** Uniq operations count */
  Operations = 'operations',
  /** Uniq prev ledger sequences count */
  PrevLedgerSequences = 'prevLedgerSequences',
  /** Uniq prev txn ids count */
  PrevTxnIds = 'prevTxnIds',
  /** Uniq source tags count */
  SourceTags = 'sourceTags',
  /** Uniq times count */
  Times = 'times',
  /** Uniq transaction hashes count */
  TransactionHashes = 'transactionHashes',
  /** Uniq transaction indices count */
  TransactionIndices = 'transactionIndices',
  /** Uniq transaction senders count */
  TransactionSenders = 'transactionSenders',
  /** Uniq transaction types count */
  TransactionTypes = 'transactionTypes'
}

/** NFTokenOffer in Ripple blockchain */
export type BitqueryRippleNfTokenOffer = {
  __typename?: 'BitqueryRippleNFTokenOffer';
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Book directory */
  bookDirectory?: Maybe<Scalars['String']['output']>;
  /** Book node */
  bookNode?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Taker pays currency */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Destination Account */
  destinationAccount?: Maybe<BitqueryAddress>;
  /** Expiration */
  expiration?: Maybe<Scalars['BitqueryBigInt']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Flags */
  flags?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** From Account */
  fromAccount?: Maybe<BitqueryAddress>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  nftokenAmount?: Maybe<Scalars['Float']['output']>;
  /** NFToken Buy Offer */
  nftokenBuyOffer?: Maybe<Scalars['String']['output']>;
  /** Taker gets currency */
  nftokenCurrency?: Maybe<BitqueryCurrency>;
  /** NFToken Sell Offer */
  nftokenSellOffer?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<Scalars['String']['output']>;
  /** Prev ledger sequence */
  prevLedgerSequence?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Prev txn */
  prevTxnId?: Maybe<Scalars['String']['output']>;
  /** Sequence */
  sequence?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryRippleTransactionDimension>;
};


/** NFTokenOffer in Ripple blockchain */
export type BitqueryRippleNfTokenOfferAmountArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  bookDirectory?: InputMaybe<BitqueryStringSelector>;
  bookNode?: InputMaybe<BitqueryStringSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  operation?: InputMaybe<BitqueryStringSelector>;
  preTakerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  preTakerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryBigIntIdSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  takerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  takerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};


/** NFTokenOffer in Ripple blockchain */
export type BitqueryRippleNfTokenOfferAnyArgs = {
  of: BitqueryRippleOfferMeasurable;
};


/** NFTokenOffer in Ripple blockchain */
export type BitqueryRippleNfTokenOfferCountArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  bookDirectory?: InputMaybe<BitqueryStringSelector>;
  bookNode?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  preTakerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  preTakerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryBigIntIdSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  takerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  takerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryRippleOfferUniq>;
};


/** NFTokenOffer in Ripple blockchain */
export type BitqueryRippleNfTokenOfferCountBigIntArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  bookDirectory?: InputMaybe<BitqueryStringSelector>;
  bookNode?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  preTakerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  preTakerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryBigIntIdSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  takerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  takerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryRippleOfferUniq>;
};


/** NFTokenOffer in Ripple blockchain */
export type BitqueryRippleNfTokenOfferExpressionArgs = {
  get: Scalars['String']['input'];
};


/** NFTokenOffer in Ripple blockchain */
export type BitqueryRippleNfTokenOfferMaximumArgs = {
  get?: InputMaybe<BitqueryRippleOfferMeasurable>;
  of: BitqueryRippleOfferMeasurable;
};


/** NFTokenOffer in Ripple blockchain */
export type BitqueryRippleNfTokenOfferMinimumArgs = {
  get?: InputMaybe<BitqueryRippleOfferMeasurable>;
  of: BitqueryRippleOfferMeasurable;
};


/** NFTokenOffer in Ripple blockchain */
export type BitqueryRippleNfTokenOfferNftokenAmountArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  bookDirectory?: InputMaybe<BitqueryStringSelector>;
  bookNode?: InputMaybe<BitqueryStringSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  operation?: InputMaybe<BitqueryStringSelector>;
  preTakerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  preTakerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryBigIntIdSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  takerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  takerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};

export enum BitqueryRippleNetwork {
  /** Ripple XRP Ledger */
  Ripple = 'ripple'
}

export type BitqueryRippleNftokenOfferFilter = {
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  bookDirectory?: InputMaybe<BitqueryStringSelector>;
  bookNode?: InputMaybe<BitqueryStringSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationAccount?: InputMaybe<BitqueryAddressSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  fromAccount?: InputMaybe<BitqueryAddressSelector>;
  mount?: InputMaybe<BitqueryFloatSelector>;
  nftokenAmount?: InputMaybe<BitqueryFloatSelector>;
  nftokenCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryBigIntIdSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};

/** Offer in Ripple blockchain */
export type BitqueryRippleOffer = {
  __typename?: 'BitqueryRippleOffer';
  /** Account */
  account?: Maybe<BitqueryAddress>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Book directory */
  bookDirectory?: Maybe<Scalars['String']['output']>;
  /** Book node */
  bookNode?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Expiration */
  expiration?: Maybe<Scalars['BitqueryBigInt']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Flags */
  flags?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<Scalars['String']['output']>;
  preTakerGetsAmount?: Maybe<Scalars['Float']['output']>;
  preTakerPaysAmount?: Maybe<Scalars['Float']['output']>;
  /** Prev ledger sequence */
  prevLedgerSequence?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Prev txn */
  prevTxnId?: Maybe<Scalars['String']['output']>;
  /** Sequence */
  sequence?: Maybe<Scalars['BitqueryBigInt']['output']>;
  takerGetsAmount?: Maybe<Scalars['Float']['output']>;
  /** Taker gets currency */
  takerGetsCurrency?: Maybe<BitqueryCurrency>;
  takerPaysAmount?: Maybe<Scalars['Float']['output']>;
  /** Taker pays currency */
  takerPaysCurrency?: Maybe<BitqueryCurrency>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryRippleTransactionDimension>;
};


/** Offer in Ripple blockchain */
export type BitqueryRippleOfferAnyArgs = {
  of: BitqueryRippleOfferMeasurable;
};


/** Offer in Ripple blockchain */
export type BitqueryRippleOfferCountArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  bookDirectory?: InputMaybe<BitqueryStringSelector>;
  bookNode?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  preTakerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  preTakerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryBigIntIdSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  takerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  takerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryRippleOfferUniq>;
};


/** Offer in Ripple blockchain */
export type BitqueryRippleOfferCountBigIntArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  bookDirectory?: InputMaybe<BitqueryStringSelector>;
  bookNode?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  preTakerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  preTakerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryBigIntIdSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  takerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  takerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryRippleOfferUniq>;
};


/** Offer in Ripple blockchain */
export type BitqueryRippleOfferExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Offer in Ripple blockchain */
export type BitqueryRippleOfferMaximumArgs = {
  get?: InputMaybe<BitqueryRippleOfferMeasurable>;
  of: BitqueryRippleOfferMeasurable;
};


/** Offer in Ripple blockchain */
export type BitqueryRippleOfferMinimumArgs = {
  get?: InputMaybe<BitqueryRippleOfferMeasurable>;
  of: BitqueryRippleOfferMeasurable;
};


/** Offer in Ripple blockchain */
export type BitqueryRippleOfferPreTakerGetsAmountArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  bookDirectory?: InputMaybe<BitqueryStringSelector>;
  bookNode?: InputMaybe<BitqueryStringSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  operation?: InputMaybe<BitqueryStringSelector>;
  preTakerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  preTakerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryBigIntIdSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  takerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  takerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};


/** Offer in Ripple blockchain */
export type BitqueryRippleOfferPreTakerPaysAmountArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  bookDirectory?: InputMaybe<BitqueryStringSelector>;
  bookNode?: InputMaybe<BitqueryStringSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  operation?: InputMaybe<BitqueryStringSelector>;
  preTakerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  preTakerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryBigIntIdSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  takerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  takerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};


/** Offer in Ripple blockchain */
export type BitqueryRippleOfferTakerGetsAmountArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  bookDirectory?: InputMaybe<BitqueryStringSelector>;
  bookNode?: InputMaybe<BitqueryStringSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  operation?: InputMaybe<BitqueryStringSelector>;
  preTakerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  preTakerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryBigIntIdSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  takerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  takerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};


/** Offer in Ripple blockchain */
export type BitqueryRippleOfferTakerPaysAmountArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  bookDirectory?: InputMaybe<BitqueryStringSelector>;
  bookNode?: InputMaybe<BitqueryStringSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  operation?: InputMaybe<BitqueryStringSelector>;
  preTakerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  preTakerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryBigIntIdSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  takerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  takerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryRippleOfferFilter = {
  account?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  bookDirectory?: InputMaybe<BitqueryStringSelector>;
  bookNode?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  preTakerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  preTakerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryBigIntIdSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  takerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  takerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};

export enum BitqueryRippleOfferMeasurable {
  /** Account */
  Account = 'account',
  /** Block */
  Block = 'block',
  /** Book directory */
  BookDirectory = 'bookDirectory',
  /** Book node */
  BookNode = 'bookNode',
  /** Date */
  Date = 'date',
  /** Expiration */
  Expiration = 'expiration',
  /** Flags */
  Flags = 'flags',
  /** Operation */
  Operation = 'operation',
  /** Pre taker gets amount */
  PreTakerGetsAmount = 'preTakerGetsAmount',
  /** Pre taker pays amount */
  PreTakerPaysAmount = 'preTakerPaysAmount',
  /** Prev ledger sequence */
  PrevLedgerSequence = 'prevLedgerSequence',
  /** Prev txn */
  PrevTxnId = 'prevTxnId',
  /** Sequence */
  Sequence = 'sequence',
  /** Taker gets amount */
  TakerGetsAmount = 'takerGetsAmount',
  /** Taker gets currency name */
  TakerGetsCurrencyName = 'takerGetsCurrencyName',
  /** Taker gets currency symbol */
  TakerGetsCurrencySymbol = 'takerGetsCurrencySymbol',
  /** Taker pays amount */
  TakerPaysAmount = 'takerPaysAmount',
  /** Taker pays currency name */
  TakerPaysCurrencyName = 'takerPaysCurrencyName',
  /** Taker pays currency symbol */
  TakerPaysCurrencySymbol = 'takerPaysCurrencySymbol',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TransactionHash = 'transactionHash',
  /** Transaction index */
  TransactionIndex = 'transactionIndex',
  /** Transaction sender */
  TransactionSender = 'transactionSender',
  /** Transaction type */
  TransactionType = 'transactionType'
}

export enum BitqueryRippleOfferUniq {
  /** Uniq accounts count */
  Accounts = 'accounts',
  /** Uniq blocks count */
  Blocks = 'blocks',
  /** Uniq book directories count */
  BookDirectories = 'bookDirectories',
  /** Uniq book nodes count */
  BookNodes = 'bookNodes',
  /** Uniq dates count */
  Dates = 'dates',
  /** Uniq expirations count */
  Expirations = 'expirations',
  /** Uniq flags count */
  Flags = 'flags',
  /** Uniq operations count */
  Operations = 'operations',
  /** Uniq prev ledger sequences count */
  PrevLedgerSequences = 'prevLedgerSequences',
  /** Uniq prev txn ids count */
  PrevTxnIds = 'prevTxnIds',
  /** Uniq sequences count */
  Sequences = 'sequences',
  /** Uniq taker gets currency names count */
  TakerGetsCurrencyNames = 'takerGetsCurrencyNames',
  /** Uniq taker gets currency symbols count */
  TakerGetsCurrencySymbols = 'takerGetsCurrencySymbols',
  /** Uniq taker pays currency names count */
  TakerPaysCurrencyNames = 'takerPaysCurrencyNames',
  /** Uniq taker pays currency symbols count */
  TakerPaysCurrencySymbols = 'takerPaysCurrencySymbols',
  /** Uniq times count */
  Times = 'times',
  /** Uniq transaction hashes count */
  TransactionHashes = 'transactionHashes',
  /** Uniq transaction indices count */
  TransactionIndices = 'transactionIndices',
  /** Uniq transaction senders count */
  TransactionSenders = 'transactionSenders',
  /** Uniq transaction types count */
  TransactionTypes = 'transactionTypes'
}

/** Payment in Ripple blockchain */
export type BitqueryRipplePayment = {
  __typename?: 'BitqueryRipplePayment';
  amount?: Maybe<Scalars['Float']['output']>;
  /** Amount currency */
  amountCurrency?: Maybe<BitqueryCurrency>;
  /** Amount issuer */
  amountIssuer?: Maybe<BitqueryAddress>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  deliverMinAmount?: Maybe<Scalars['Float']['output']>;
  /** Deliver min currency */
  deliverMinCurrency?: Maybe<BitqueryCurrency>;
  /** Deliver min issuer */
  deliverMinIssuer?: Maybe<BitqueryAddress>;
  deliveredAmount?: Maybe<Scalars['Float']['output']>;
  /** Delivered currency */
  deliveredCurrency?: Maybe<BitqueryCurrency>;
  /** Delivered issuer */
  deliveredIssuer?: Maybe<BitqueryAddress>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Flags */
  flags?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Invoice */
  invoice?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Partial */
  partial?: Maybe<Scalars['Boolean']['output']>;
  /** Receiver */
  receiver?: Maybe<BitqueryAddress>;
  sendMaxAmount?: Maybe<Scalars['Float']['output']>;
  /** Send max currency */
  sendMaxCurrency?: Maybe<BitqueryCurrency>;
  /** Send max issuer */
  sendMaxIssuer?: Maybe<BitqueryAddress>;
  /** Sender */
  sender?: Maybe<BitqueryAddress>;
  /** Tag */
  tag?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryRippleTransactionHashIndexDimension>;
};


/** Payment in Ripple blockchain */
export type BitqueryRipplePaymentAmountArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  amountCurrency?: InputMaybe<BitqueryCurrencySelector>;
  amountIssuer?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  deliverMinAmount?: InputMaybe<BitqueryFloatSelector>;
  deliverMinCurrency?: InputMaybe<BitqueryCurrencySelector>;
  deliverMinIssuer?: InputMaybe<BitqueryAddressSelector>;
  deliveredAmount?: InputMaybe<BitqueryFloatSelector>;
  deliveredCurrency?: InputMaybe<BitqueryCurrencySelector>;
  deliveredIssuer?: InputMaybe<BitqueryAddressSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  invoice?: InputMaybe<BitqueryStringSelector>;
  partial?: InputMaybe<BitqueryBooleanSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sendMaxAmount?: InputMaybe<BitqueryFloatSelector>;
  sendMaxCurrency?: InputMaybe<BitqueryCurrencySelector>;
  sendMaxIssuer?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  tag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Payment in Ripple blockchain */
export type BitqueryRipplePaymentAnyArgs = {
  of: BitqueryRipplePaymentMeasurable;
};


/** Payment in Ripple blockchain */
export type BitqueryRipplePaymentCountArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  amountCurrency?: InputMaybe<BitqueryCurrencySelector>;
  amountIssuer?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  deliverMinAmount?: InputMaybe<BitqueryFloatSelector>;
  deliverMinCurrency?: InputMaybe<BitqueryCurrencySelector>;
  deliverMinIssuer?: InputMaybe<BitqueryAddressSelector>;
  deliveredAmount?: InputMaybe<BitqueryFloatSelector>;
  deliveredCurrency?: InputMaybe<BitqueryCurrencySelector>;
  deliveredIssuer?: InputMaybe<BitqueryAddressSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  invoice?: InputMaybe<BitqueryStringSelector>;
  partial?: InputMaybe<BitqueryBooleanSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sendMaxAmount?: InputMaybe<BitqueryFloatSelector>;
  sendMaxCurrency?: InputMaybe<BitqueryCurrencySelector>;
  sendMaxIssuer?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  tag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryRipplePaymentUniq>;
};


/** Payment in Ripple blockchain */
export type BitqueryRipplePaymentCountBigIntArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  amountCurrency?: InputMaybe<BitqueryCurrencySelector>;
  amountIssuer?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  deliverMinAmount?: InputMaybe<BitqueryFloatSelector>;
  deliverMinCurrency?: InputMaybe<BitqueryCurrencySelector>;
  deliverMinIssuer?: InputMaybe<BitqueryAddressSelector>;
  deliveredAmount?: InputMaybe<BitqueryFloatSelector>;
  deliveredCurrency?: InputMaybe<BitqueryCurrencySelector>;
  deliveredIssuer?: InputMaybe<BitqueryAddressSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  invoice?: InputMaybe<BitqueryStringSelector>;
  partial?: InputMaybe<BitqueryBooleanSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sendMaxAmount?: InputMaybe<BitqueryFloatSelector>;
  sendMaxCurrency?: InputMaybe<BitqueryCurrencySelector>;
  sendMaxIssuer?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  tag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryRipplePaymentUniq>;
};


/** Payment in Ripple blockchain */
export type BitqueryRipplePaymentDeliverMinAmountArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  amountCurrency?: InputMaybe<BitqueryCurrencySelector>;
  amountIssuer?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  deliverMinAmount?: InputMaybe<BitqueryFloatSelector>;
  deliverMinCurrency?: InputMaybe<BitqueryCurrencySelector>;
  deliverMinIssuer?: InputMaybe<BitqueryAddressSelector>;
  deliveredAmount?: InputMaybe<BitqueryFloatSelector>;
  deliveredCurrency?: InputMaybe<BitqueryCurrencySelector>;
  deliveredIssuer?: InputMaybe<BitqueryAddressSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  invoice?: InputMaybe<BitqueryStringSelector>;
  partial?: InputMaybe<BitqueryBooleanSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sendMaxAmount?: InputMaybe<BitqueryFloatSelector>;
  sendMaxCurrency?: InputMaybe<BitqueryCurrencySelector>;
  sendMaxIssuer?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  tag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Payment in Ripple blockchain */
export type BitqueryRipplePaymentDeliveredAmountArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  amountCurrency?: InputMaybe<BitqueryCurrencySelector>;
  amountIssuer?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  deliverMinAmount?: InputMaybe<BitqueryFloatSelector>;
  deliverMinCurrency?: InputMaybe<BitqueryCurrencySelector>;
  deliverMinIssuer?: InputMaybe<BitqueryAddressSelector>;
  deliveredAmount?: InputMaybe<BitqueryFloatSelector>;
  deliveredCurrency?: InputMaybe<BitqueryCurrencySelector>;
  deliveredIssuer?: InputMaybe<BitqueryAddressSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  invoice?: InputMaybe<BitqueryStringSelector>;
  partial?: InputMaybe<BitqueryBooleanSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sendMaxAmount?: InputMaybe<BitqueryFloatSelector>;
  sendMaxCurrency?: InputMaybe<BitqueryCurrencySelector>;
  sendMaxIssuer?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  tag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Payment in Ripple blockchain */
export type BitqueryRipplePaymentExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Payment in Ripple blockchain */
export type BitqueryRipplePaymentMaximumArgs = {
  get?: InputMaybe<BitqueryRipplePaymentMeasurable>;
  of: BitqueryRipplePaymentMeasurable;
};


/** Payment in Ripple blockchain */
export type BitqueryRipplePaymentMinimumArgs = {
  get?: InputMaybe<BitqueryRipplePaymentMeasurable>;
  of: BitqueryRipplePaymentMeasurable;
};


/** Payment in Ripple blockchain */
export type BitqueryRipplePaymentSendMaxAmountArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  amountCurrency?: InputMaybe<BitqueryCurrencySelector>;
  amountIssuer?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  deliverMinAmount?: InputMaybe<BitqueryFloatSelector>;
  deliverMinCurrency?: InputMaybe<BitqueryCurrencySelector>;
  deliverMinIssuer?: InputMaybe<BitqueryAddressSelector>;
  deliveredAmount?: InputMaybe<BitqueryFloatSelector>;
  deliveredCurrency?: InputMaybe<BitqueryCurrencySelector>;
  deliveredIssuer?: InputMaybe<BitqueryAddressSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  invoice?: InputMaybe<BitqueryStringSelector>;
  partial?: InputMaybe<BitqueryBooleanSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sendMaxAmount?: InputMaybe<BitqueryFloatSelector>;
  sendMaxCurrency?: InputMaybe<BitqueryCurrencySelector>;
  sendMaxIssuer?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  tag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryRipplePaymentFilter = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  amountCurrency?: InputMaybe<BitqueryCurrencySelector>;
  amountIssuer?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  deliverMinAmount?: InputMaybe<BitqueryFloatSelector>;
  deliverMinCurrency?: InputMaybe<BitqueryCurrencySelector>;
  deliverMinIssuer?: InputMaybe<BitqueryAddressSelector>;
  deliveredAmount?: InputMaybe<BitqueryFloatSelector>;
  deliveredCurrency?: InputMaybe<BitqueryCurrencySelector>;
  deliveredIssuer?: InputMaybe<BitqueryAddressSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  invoice?: InputMaybe<BitqueryStringSelector>;
  partial?: InputMaybe<BitqueryBooleanSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sendMaxAmount?: InputMaybe<BitqueryFloatSelector>;
  sendMaxCurrency?: InputMaybe<BitqueryCurrencySelector>;
  sendMaxIssuer?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  tag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
};

export enum BitqueryRipplePaymentMeasurable {
  /** Amount */
  Amount = 'amount',
  /** Amount currency name */
  AmountCurrencyName = 'amountCurrencyName',
  /** Amount currency symbol */
  AmountCurrencySymbol = 'amountCurrencySymbol',
  /** Amount issuer */
  AmountIssuer = 'amountIssuer',
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Deliver min amount */
  DeliverMinAmount = 'deliverMinAmount',
  /** Deliver min currency name */
  DeliverMinCurrencyName = 'deliverMinCurrencyName',
  /** Deliver min currency symbol */
  DeliverMinCurrencySymbol = 'deliverMinCurrencySymbol',
  /** Deliver min issuer */
  DeliverMinIssuer = 'deliverMinIssuer',
  /** Delivered amount */
  DeliveredAmount = 'deliveredAmount',
  /** Delivered currency name */
  DeliveredCurrencyName = 'deliveredCurrencyName',
  /** Delivered currency symbol */
  DeliveredCurrencySymbol = 'deliveredCurrencySymbol',
  /** Delivered issuer */
  DeliveredIssuer = 'deliveredIssuer',
  /** Flags */
  Flags = 'flags',
  /** Invoice */
  Invoice = 'invoice',
  /** Partial */
  Partial = 'partial',
  /** Receiver */
  Receiver = 'receiver',
  /** Send max amount */
  SendMaxAmount = 'sendMaxAmount',
  /** Send max currency name */
  SendMaxCurrencyName = 'sendMaxCurrencyName',
  /** Send max currency symbol */
  SendMaxCurrencySymbol = 'sendMaxCurrencySymbol',
  /** Send max issuer */
  SendMaxIssuer = 'sendMaxIssuer',
  /** Sender */
  Sender = 'sender',
  /** Tag */
  Tag = 'tag',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TransactionHash = 'transactionHash',
  /** Transaction index */
  TransactionIndex = 'transactionIndex'
}

export enum BitqueryRipplePaymentUniq {
  /** Uniq amount currency names count */
  AmountCurrencyNames = 'amountCurrencyNames',
  /** Uniq amount currency symbols count */
  AmountCurrencySymbols = 'amountCurrencySymbols',
  /** Uniq amount issuers count */
  AmountIssuers = 'amountIssuers',
  /** Uniq blocks count */
  Blocks = 'blocks',
  /** Uniq dates count */
  Dates = 'dates',
  /** Uniq deliver min currency names count */
  DeliverMinCurrencyNames = 'deliverMinCurrencyNames',
  /** Uniq deliver min currency symbols count */
  DeliverMinCurrencySymbols = 'deliverMinCurrencySymbols',
  /** Uniq deliver min issuers count */
  DeliverMinIssuers = 'deliverMinIssuers',
  /** Uniq delivered currency names count */
  DeliveredCurrencyNames = 'deliveredCurrencyNames',
  /** Uniq delivered currency symbols count */
  DeliveredCurrencySymbols = 'deliveredCurrencySymbols',
  /** Uniq delivered issuers count */
  DeliveredIssuers = 'deliveredIssuers',
  /** Uniq flags count */
  Flags = 'flags',
  /** Uniq invoices count */
  Invoices = 'invoices',
  /** Uniq receivers count */
  Receivers = 'receivers',
  /** Uniq send max currency names count */
  SendMaxCurrencyNames = 'sendMaxCurrencyNames',
  /** Uniq send max currency symbols count */
  SendMaxCurrencySymbols = 'sendMaxCurrencySymbols',
  /** Uniq send max issuers count */
  SendMaxIssuers = 'sendMaxIssuers',
  /** Uniq senders count */
  Senders = 'senders',
  /** Uniq tags count */
  Tags = 'tags',
  /** Uniq time count */
  Time = 'time',
  /** Uniq transaction hashes count */
  TransactionHashes = 'transactionHashes',
  /** Uniq transaction indices count */
  TransactionIndices = 'transactionIndices'
}

/** Ripple state in Ripple blockchain */
export type BitqueryRippleRippleState = {
  __typename?: 'BitqueryRippleRippleState';
  any?: Maybe<Scalars['String']['output']>;
  balance?: Maybe<Scalars['Float']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Flags */
  flags?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** High account */
  highAccount?: Maybe<BitqueryAddress>;
  /** Low account */
  lowAccount?: Maybe<BitqueryAddress>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<Scalars['String']['output']>;
  prevBalance?: Maybe<Scalars['Float']['output']>;
  /** Prev ledger sequence */
  prevLedgerSequence?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Prev txn */
  prevTxnId?: Maybe<Scalars['String']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryRippleTransactionDimension>;
};


/** Ripple state in Ripple blockchain */
export type BitqueryRippleRippleStateAnyArgs = {
  of: BitqueryRippleRippleStateMeasurable;
};


/** Ripple state in Ripple blockchain */
export type BitqueryRippleRippleStateBalanceArgs = {
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  highAccount?: InputMaybe<BitqueryAddressSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  lowAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};


/** Ripple state in Ripple blockchain */
export type BitqueryRippleRippleStateCountArgs = {
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  highAccount?: InputMaybe<BitqueryAddressSelector>;
  lowAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryRippleRippleStateUniq>;
};


/** Ripple state in Ripple blockchain */
export type BitqueryRippleRippleStateCountBigIntArgs = {
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  highAccount?: InputMaybe<BitqueryAddressSelector>;
  lowAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryRippleRippleStateUniq>;
};


/** Ripple state in Ripple blockchain */
export type BitqueryRippleRippleStateExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Ripple state in Ripple blockchain */
export type BitqueryRippleRippleStateMaximumArgs = {
  get?: InputMaybe<BitqueryRippleRippleStateMeasurable>;
  of: BitqueryRippleRippleStateMeasurable;
};


/** Ripple state in Ripple blockchain */
export type BitqueryRippleRippleStateMinimumArgs = {
  get?: InputMaybe<BitqueryRippleRippleStateMeasurable>;
  of: BitqueryRippleRippleStateMeasurable;
};


/** Ripple state in Ripple blockchain */
export type BitqueryRippleRippleStatePrevBalanceArgs = {
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  highAccount?: InputMaybe<BitqueryAddressSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  lowAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryRippleRippleStateFilter = {
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  highAccount?: InputMaybe<BitqueryAddressSelector>;
  lowAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};

export enum BitqueryRippleRippleStateMeasurable {
  /** Balance */
  Balance = 'balance',
  /** Block */
  Block = 'block',
  /** Currency name */
  CurrencyName = 'currencyName',
  /** Currency symbol */
  CurrencySymbol = 'currencySymbol',
  /** Date */
  Date = 'date',
  /** Flags */
  Flags = 'flags',
  /** High account */
  HighAccount = 'highAccount',
  /** Low account */
  LowAccount = 'lowAccount',
  /** Operation */
  Operation = 'operation',
  /** Pre balance */
  PrevBalance = 'prevBalance',
  /** Prev ledger sequence */
  PrevLedgerSequence = 'prevLedgerSequence',
  /** Prev txn */
  PrevTxnId = 'prevTxnId',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TransactionHash = 'transactionHash',
  /** Transaction index */
  TransactionIndex = 'transactionIndex',
  /** Transaction sender */
  TransactionSender = 'transactionSender',
  /** Transaction type */
  TransactionType = 'transactionType'
}

export enum BitqueryRippleRippleStateUniq {
  /** Uniq blocks count */
  Blocks = 'blocks',
  /** Uniq currency names count */
  CurrencyNames = 'currencyNames',
  /** Uniq currency symbols count */
  CurrencySymbols = 'currencySymbols',
  /** Uniq dates count */
  Dates = 'dates',
  /** Uniq flags count */
  Flags = 'flags',
  /** Uniq high accounts count */
  HighAccounts = 'highAccounts',
  /** Uniq low accounts count */
  LowAccounts = 'lowAccounts',
  /** Uniq operations count */
  Operations = 'operations',
  /** Uniq prev ledger sequences count */
  PrevLedgerSequences = 'prevLedgerSequences',
  /** Uniq prev txn ids count */
  PrevTxnIds = 'prevTxnIds',
  /** Uniq times count */
  Times = 'times',
  /** Uniq transaction hashes count */
  TransactionHashes = 'transactionHashes',
  /** Uniq transaction indices count */
  TransactionIndices = 'transactionIndices',
  /** Uniq transaction senders count */
  TransactionSenders = 'transactionSenders',
  /** Uniq transaction types count */
  TransactionTypes = 'transactionTypes'
}

/** Token Balance */
export type BitqueryRippleTokenBalances = {
  __typename?: 'BitqueryRippleTokenBalances';
  /** The unique Address of the counterparty to this trust line. */
  account?: Maybe<Scalars['String']['output']>;
  /** Balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** Currency */
  currency?: Maybe<Scalars['String']['output']>;
};

/** Transaction in Ripple blockchain */
export type BitqueryRippleTransaction = {
  __typename?: 'BitqueryRippleTransaction';
  /** Account txn id */
  accountTxnId?: Maybe<Scalars['String']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  fee?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  /** Flags */
  flags?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Hash */
  hash?: Maybe<Scalars['String']['output']>;
  /** Index */
  index?: Maybe<Scalars['Int']['output']>;
  /** Last ledger sequence */
  lastLedgerSequence?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Memos */
  memos?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Result */
  result?: Maybe<Scalars['String']['output']>;
  /** Sender */
  sender?: Maybe<BitqueryAddress>;
  /** Sequence */
  sequence?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Source tag */
  sourceTag?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Tx signers */
  txSigners?: Maybe<Scalars['String']['output']>;
  /** Type */
  type?: Maybe<Scalars['String']['output']>;
};


/** Transaction in Ripple blockchain */
export type BitqueryRippleTransactionAnyArgs = {
  of: BitqueryRippleTransactionMeasurable;
};


/** Transaction in Ripple blockchain */
export type BitqueryRippleTransactionCountArgs = {
  accountTxnId?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  lastLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  memos?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryStringSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  sourceTag?: InputMaybe<BitqueryBigIntIdSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryRippleTransactionUniq>;
};


/** Transaction in Ripple blockchain */
export type BitqueryRippleTransactionCountBigIntArgs = {
  accountTxnId?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  lastLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  memos?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryStringSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  sourceTag?: InputMaybe<BitqueryBigIntIdSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryRippleTransactionUniq>;
};


/** Transaction in Ripple blockchain */
export type BitqueryRippleTransactionExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transaction in Ripple blockchain */
export type BitqueryRippleTransactionFeeArgs = {
  accountTxnId?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  lastLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  memos?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryStringSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  sourceTag?: InputMaybe<BitqueryBigIntIdSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Transaction in Ripple blockchain */
export type BitqueryRippleTransactionMaximumArgs = {
  get?: InputMaybe<BitqueryRippleTransactionMeasurable>;
  of: BitqueryRippleTransactionMeasurable;
};


/** Transaction in Ripple blockchain */
export type BitqueryRippleTransactionMinimumArgs = {
  get?: InputMaybe<BitqueryRippleTransactionMeasurable>;
  of: BitqueryRippleTransactionMeasurable;
};

/** Ripple transaction */
export type BitqueryRippleTransactionDimension = {
  __typename?: 'BitqueryRippleTransactionDimension';
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction index in block */
  index: Scalars['Int']['output'];
  /** Transaction sender */
  sender?: Maybe<Scalars['String']['output']>;
  /** Transaction type */
  type?: Maybe<Scalars['String']['output']>;
};

export type BitqueryRippleTransactionFilter = {
  accountTxnId?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  lastLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  memos?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryStringSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  sourceTag?: InputMaybe<BitqueryBigIntIdSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};

/** Ripple transaction with hash and index */
export type BitqueryRippleTransactionHashIndexDimension = {
  __typename?: 'BitqueryRippleTransactionHashIndexDimension';
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction index in block */
  index: Scalars['Int']['output'];
};

export enum BitqueryRippleTransactionMeasurable {
  /** Account txn id */
  AccountTxnId = 'accountTxnId',
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Fee */
  Fee = 'fee',
  /** Flags */
  Flags = 'flags',
  /** Hash */
  Hash = 'hash',
  /** Index */
  Index = 'index',
  /** Last ledger sequence */
  LastLedgerSequence = 'lastLedgerSequence',
  /** Memos */
  Memos = 'memos',
  /** Result */
  Result = 'result',
  /** Sender */
  Sender = 'sender',
  /** Sequence */
  Sequence = 'sequence',
  /** Source tag */
  SourceTag = 'sourceTag',
  /** Success */
  Success = 'success',
  /** Time */
  Time = 'time',
  /** Type */
  Type = 'type'
}

export enum BitqueryRippleTransactionUniq {
  /** Uniq account txn id bins count */
  AccountTxnIds = 'accountTxnIds',
  /** Uniq blocks count */
  Blocks = 'blocks',
  /** Uniq dates count */
  Dates = 'dates',
  /** Uniq flags count */
  Flags = 'flags',
  /** Uniq hashes count */
  Hashes = 'hashes',
  /** Uniq indices count */
  Indices = 'indices',
  /** Uniq last ledger sequences count */
  LastLedgerSequences = 'lastLedgerSequences',
  /** Uniq results count */
  Results = 'results',
  /** Uniq senders count */
  Senders = 'senders',
  /** Uniq sequences count */
  Sequences = 'sequences',
  /** Uniq source tags count */
  SourceTags = 'sourceTags',
  /** Uniq types count */
  Types = 'types'
}

/** Transfer in Ripple blockchain */
export type BitqueryRippleTransfer = {
  __typename?: 'BitqueryRippleTransfer';
  amountFrom?: Maybe<Scalars['Float']['output']>;
  amountTo?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency from */
  currencyFrom?: Maybe<BitqueryCurrency>;
  /** Currency to */
  currencyTo?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Direction */
  direction?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Sender */
  sender?: Maybe<BitqueryAddress>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryRippleTransactionDimension>;
};


/** Transfer in Ripple blockchain */
export type BitqueryRippleTransferAmountFromArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currencyFromSymbol?: InputMaybe<BitqueryCurrencySelector>;
  currencyToSymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  direction?: InputMaybe<BitqueryStringSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};


/** Transfer in Ripple blockchain */
export type BitqueryRippleTransferAmountToArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currencyFromSymbol?: InputMaybe<BitqueryCurrencySelector>;
  currencyToSymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  direction?: InputMaybe<BitqueryStringSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};


/** Transfer in Ripple blockchain */
export type BitqueryRippleTransferAnyArgs = {
  of: BitqueryRippleTransferMeasurable;
};


/** Transfer in Ripple blockchain */
export type BitqueryRippleTransferCountArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  currencyFromSymbol?: InputMaybe<BitqueryCurrencySelector>;
  currencyToSymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  direction?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryRippleTransferUniq>;
};


/** Transfer in Ripple blockchain */
export type BitqueryRippleTransferCountBigIntArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  currencyFromSymbol?: InputMaybe<BitqueryCurrencySelector>;
  currencyToSymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  direction?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryRippleTransferUniq>;
};


/** Transfer in Ripple blockchain */
export type BitqueryRippleTransferExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transfer in Ripple blockchain */
export type BitqueryRippleTransferMaximumArgs = {
  get?: InputMaybe<BitqueryRippleTransferMeasurable>;
  of: BitqueryRippleTransferMeasurable;
};


/** Transfer in Ripple blockchain */
export type BitqueryRippleTransferMinimumArgs = {
  get?: InputMaybe<BitqueryRippleTransferMeasurable>;
  of: BitqueryRippleTransferMeasurable;
};

export type BitqueryRippleTransferFilter = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  currencyFromSymbol?: InputMaybe<BitqueryCurrencySelector>;
  currencyToSymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  direction?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};

export enum BitqueryRippleTransferMeasurable {
  /** Amount from */
  AmountFrom = 'amountFrom',
  /** Amount to */
  AmountTo = 'amountTo',
  /** Block */
  Block = 'block',
  /** Currency from name */
  CurrencyFromName = 'currencyFromName',
  /** Currency from symbol */
  CurrencyFromSymbol = 'currencyFromSymbol',
  /** Currency to name */
  CurrencyToName = 'currencyToName',
  /** Currency to symbol */
  CurrencyToSymbol = 'currencyToSymbol',
  /** Date */
  Date = 'date',
  /** Direction */
  Direction = 'direction',
  /** Receiver */
  Receiver = 'receiver',
  /** Sender */
  Sender = 'sender',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TransactionHash = 'transactionHash',
  /** Transaction index */
  TransactionIndex = 'transactionIndex',
  /** Transaction sender */
  TransactionSender = 'transactionSender',
  /** Transaction type */
  TransactionType = 'transactionType'
}

export enum BitqueryRippleTransferUniq {
  /** Uniq blocks count */
  Blocks = 'blocks',
  /** Uniq currencies from name count */
  CurrencyFromNames = 'currencyFromNames',
  /** Uniq currencies from symbol count */
  CurrencyFromSymbols = 'currencyFromSymbols',
  /** Uniq currencies to name count */
  CurrencyToNames = 'currencyToNames',
  /** Uniq currencies to symbol count */
  CurrencyToSymbols = 'currencyToSymbols',
  /** Uniq dates count */
  Dates = 'dates',
  /** Uniq directions count */
  Directions = 'directions',
  /** Uniq receivers count */
  Receivers = 'receivers',
  /** Uniq senders count */
  Senders = 'senders',
  /** Uniq times count */
  Times = 'times',
  /** Uniq transaction hashes count */
  TransactionHashes = 'transactionHashes',
  /** Uniq transaction indices count */
  TransactionIndices = 'transactionIndices',
  /** Uniq transaction senders count */
  TransactionSenders = 'transactionSenders',
  /** Uniq transaction types count */
  TransactionTypes = 'transactionTypes'
}

/** Smart contract crypto currency ( token, coin, currency ) */
export type BitqueryScCurrency = {
  __typename?: 'BitqueryScCurrency';
  /** Decimals */
  decimals: Scalars['Int']['output'];
  /** Currency name */
  name?: Maybe<Scalars['String']['output']>;
  /** Currency symbol */
  symbol: Scalars['String']['output'];
  /** Token Type */
  tokenType?: Maybe<Scalars['String']['output']>;
};

export enum BitqueryScriptTypeSelectorSelector {
  /** Peer-to-peer */
  PeerToPeerTransaction = 'peer_to_peer_transaction',
  /** Unknown Transaction */
  UnknownTransaction = 'unknown_transaction'
}

export type BitquerySeedOptions = {
  /** Invalidating cache seed */
  seed?: InputMaybe<Scalars['Int']['input']>;
};

/** Solana Sender */
export type BitquerySender = {
  __typename?: 'BitquerySender';
  address: Scalars['String']['output'];
  mintAccount: Scalars['String']['output'];
  type: Scalars['String']['output'];
};

/** Smart contract method or event */
export type BitquerySignature = BitqueryEvent | BitqueryMethod;

export enum BitquerySignatureTypeSelector {
  /** Smart contract event */
  Event = 'Event',
  /** Smart contract method */
  Function = 'Function'
}

/** Blockchain smart contract */
export type BitquerySmartContract = {
  __typename?: 'BitquerySmartContract';
  /** String address representation */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Smart Contract Type */
  contractType: BitquerySmartContractType;
  /** Smart Contract Protocol Type */
  protocol?: Maybe<Scalars['String']['output']>;
};

export enum BitquerySmartContractArgumentsUniq {
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique callers count */
  Callers = 'callers',
  /** Calls or events */
  Calls = 'calls',
  /** Unique date count */
  Dates = 'dates',
  /** Unique transaction senders */
  Senders = 'senders',
  /** Unique signatures count */
  Signatures = 'signatures',
  /** Unique smart contracts count */
  SmartContracts = 'smart_contracts',
  /** Unique transactions count */
  Txs = 'txs',
  /** Unique values */
  Values = 'values'
}

export enum BitquerySmartContractCallsUniq {
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique callers count */
  Callers = 'callers',
  /** Calls */
  Calls = 'calls',
  /** Unique date count */
  Dates = 'dates',
  /** Unique transaction senders */
  Senders = 'senders',
  /** Unique smart contract methods count */
  SmartContractMethods = 'smart_contract_methods',
  /** Unique smart contracts count */
  SmartContracts = 'smart_contracts',
  /** Unique transactions count */
  Txs = 'txs'
}

export enum BitquerySmartContractEventsUniq {
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates',
  /** Shard ID */
  ShardId = 'shard_id',
  /** Unique smart contract methods count */
  SmartContractMethods = 'smart_contract_methods',
  /** Unique smart contracts count */
  SmartContracts = 'smart_contracts',
  /** To Shard ID */
  ToShardId = 'to_shard_id',
  /** Unique transaction senders */
  TxFrom = 'tx_from',
  /** Unique callers count */
  TxTo = 'tx_to',
  /** Unique transactions count */
  Txs = 'txs'
}

/** Blockchain smart contract */
export type BitquerySmartContractInfo = {
  __typename?: 'BitquerySmartContractInfo';
  /** Smart Contract Type */
  contractType?: Maybe<BitquerySmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<BitqueryScCurrency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']['output']>;
};

export type BitquerySmartContractReadonlyAttribute = {
  __typename?: 'BitquerySmartContractReadonlyAttribute';
  /** Value as address if applicable */
  address?: Maybe<BitqueryEthereumAddressInfo>;
  /** Method name */
  name: Scalars['String']['output'];
  /** Method return type */
  type: Scalars['String']['output'];
  /** Method return value */
  value: Scalars['String']['output'];
};

export enum BitquerySmartContractType {
  /** Decentralized exchange */
  Dex = 'DEX',
  /** General Purpose Smart contract */
  Generic = 'Generic',
  /** Smart contract for token derivatives */
  MarginPositionToken = 'MarginPositionToken',
  /** Multi signature wallet */
  Multisig = 'Multisig',
  /** Not A Smart contract */
  None = 'None',
  /** Transaction Execution Approval Language */
  Teal = 'TEAL',
  /** Token */
  Token = 'Token',
  /** Token Sale */
  TokenSale = 'TokenSale'
}

/** Selector of smart contract type */
export type BitquerySmartContractTypeSelector = {
  /** Smart Contract type in the list */
  in?: InputMaybe<Array<BitquerySmartContractType>>;
  /** Smart Contract type is */
  is?: InputMaybe<BitquerySmartContractType>;
  /** Smart Contract type not */
  not?: InputMaybe<BitquerySmartContractType>;
  /** Smart Contract type not in the list */
  notIn?: InputMaybe<Array<BitquerySmartContractType>>;
};

/** Solana Chain */
export type BitquerySolana = {
  __typename?: 'BitquerySolana';
  /** Basic information about address */
  address: Array<BitquerySolanaAddressInfoWithBalance>;
  /** BlockRewards of Smart Contract Calls and Events */
  blockRewards?: Maybe<Array<BitquerySolanaBlockReward>>;
  /** Solana Blocks */
  blocks?: Maybe<Array<BitquerySolanaBlock>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitquerySolanaCoinpath>>;
  /**
   * Each instruction specifies a single program, a subset of the transaction`s accounts
   *         that should be passed to the program.
   */
  instructionAccounts?: Maybe<Array<BitquerySolanaInstructionAccount>>;
  /**
   * Each instruction specifies a single program, a subset of the transaction`s accounts
   *         that should be passed to the program.
   */
  instructions?: Maybe<Array<BitquerySolanaInstruction>>;
  /** Solana Transaction */
  transactions?: Maybe<Array<BitquerySolanaTransaction>>;
  /** Currency transfers from/to addresses in crypto currencies */
  transfers?: Maybe<Array<BitquerySolanaTransfer>>;
};


/** Solana Chain */
export type BitquerySolanaAddressArgs = {
  address: Array<BitqueryAddressSelectorIn>;
};


/** Solana Chain */
export type BitquerySolanaBlockRewardsArgs = {
  account?: InputMaybe<BitqueryStringSelector>;
  any?: InputMaybe<Array<BitquerySolanaBlockRewardFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  parentSlot?: InputMaybe<BitqueryIntegerSelector>;
  postBalance?: InputMaybe<BitqueryAmountSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  reward?: InputMaybe<BitqueryAmountSelector>;
  rewardType?: InputMaybe<BitqueryRewardTypeSelector>;
};


/** Solana Chain */
export type BitquerySolanaBlocksArgs = {
  any?: InputMaybe<Array<BitquerySolanaBlockFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  parentSlot?: InputMaybe<BitqueryIntegerSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  rewards?: InputMaybe<BitqueryAmountSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
};


/** Solana Chain */
export type BitquerySolanaCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCoinpathOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Solana Chain */
export type BitquerySolanaInstructionAccountsArgs = {
  account?: InputMaybe<BitqueryStringSelector>;
  accountIndex?: InputMaybe<BitqueryIntegerSelector>;
  accountOwner?: InputMaybe<BitqueryStringSelector>;
  accountType?: InputMaybe<BitqueryStringSelector>;
  any?: InputMaybe<Array<BitquerySolanaInstructionAccountFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  callPath?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<BitqueryIntegerSelector>;
  fee?: InputMaybe<BitqueryIntegerSelector>;
  feePayer?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  parsed?: InputMaybe<BitqueryIntegerSelector>;
  parsedActionName?: InputMaybe<BitqueryStringSelector>;
  parsedProgramName?: InputMaybe<BitqueryStringSelector>;
  parsedType?: InputMaybe<BitqueryStringSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  programId?: InputMaybe<BitqueryStringSelector>;
  signature?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Solana Chain */
export type BitquerySolanaInstructionsArgs = {
  any?: InputMaybe<Array<BitquerySolanaInstructionFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  callPath?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<BitqueryIntegerSelector>;
  externalParsed?: InputMaybe<BitqueryIntegerSelector>;
  externalParsedActionName?: InputMaybe<BitqueryStringSelector>;
  externalParsedProgramName?: InputMaybe<BitqueryStringSelector>;
  externalParsedType?: InputMaybe<BitqueryStringSelector>;
  externalProgramId?: InputMaybe<BitqueryStringSelector>;
  fee?: InputMaybe<BitqueryIntegerSelector>;
  feePayer?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  parsed?: InputMaybe<BitqueryIntegerSelector>;
  parsedActionName?: InputMaybe<BitqueryStringSelector>;
  parsedProgramName?: InputMaybe<BitqueryStringSelector>;
  parsedType?: InputMaybe<BitqueryStringSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  programId?: InputMaybe<BitqueryStringSelector>;
  signature?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Solana Chain */
export type BitquerySolanaTransactionsArgs = {
  accountsCount?: InputMaybe<BitqueryIntegerSelector>;
  any?: InputMaybe<Array<BitquerySolanaTransactionFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryIntegerSelector>;
  feePayer?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  innerInstructionsCount?: InputMaybe<BitqueryIntegerSelector>;
  instructionsCount?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  parentSlot?: InputMaybe<BitqueryBlockSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  recentBlockHash?: InputMaybe<BitqueryHashSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  signer?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  transactionFee?: InputMaybe<BitqueryAmountSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Solana Chain */
export type BitquerySolanaTransfersArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  any?: InputMaybe<Array<BitquerySolanaTransferFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  callPath?: InputMaybe<BitqueryStringSelector>;
  currency?: InputMaybe<Array<BitquerySolanaCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<BitqueryStringSelector>;
  externalParsed?: InputMaybe<BitqueryIntegerSelector>;
  externalParsedActionName?: InputMaybe<BitqueryStringSelector>;
  externalParsedProgramName?: InputMaybe<BitqueryStringSelector>;
  externalParsedType?: InputMaybe<BitqueryStringSelector>;
  externalProgramId?: InputMaybe<BitqueryStringSelector>;
  feePayer?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  parsed?: InputMaybe<BitqueryIntegerSelector>;
  parsedActionName?: InputMaybe<BitqueryStringSelector>;
  parsedProgramName?: InputMaybe<BitqueryStringSelector>;
  parsedType?: InputMaybe<BitqueryStringSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  programId?: InputMaybe<BitqueryStringSelector>;
  receiverAddress?: InputMaybe<BitqueryStringSelector>;
  receiverMintAddress?: InputMaybe<BitqueryStringSelector>;
  receiverType?: InputMaybe<BitqueryStringSelector>;
  recentBlockHash?: InputMaybe<BitqueryHashSelector>;
  senderAddress?: InputMaybe<BitqueryStringSelector>;
  senderMintAddress?: InputMaybe<BitqueryStringSelector>;
  senderType?: InputMaybe<BitqueryStringSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  signer?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tokenAccount?: InputMaybe<Array<BitqueryStringSelector>>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transferType?: InputMaybe<BitquerySolanaTransferTypeSelector>;
};

/** Solana Account */
export type BitquerySolanaAccount = {
  __typename?: 'BitquerySolanaAccount';
  index: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  owner: Scalars['String']['output'];
  type: Scalars['String']['output'];
};

/** Blockchain address */
export type BitquerySolanaAddressInfoWithBalance = {
  __typename?: 'BitquerySolanaAddressInfoWithBalance';
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Current address balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<BitquerySmartContractInfo>;
};


/** Blockchain address */
export type BitquerySolanaAddressInfoWithBalanceBalanceArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};

/** Block in Solana  blockchain */
export type BitquerySolanaBlock = {
  __typename?: 'BitquerySolanaBlock';
  any?: Maybe<Scalars['String']['output']>;
  /** Hash of the the block */
  blockHash?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** The slot index of this block`s parent */
  parentSlot?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The block hash of this block`s parent */
  previousBlockHash?: Maybe<Scalars['String']['output']>;
  rewards?: Maybe<Scalars['Float']['output']>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Count of transactions in this block */
  transactionCount?: Maybe<Scalars['Int']['output']>;
};


/** Block in Solana  blockchain */
export type BitquerySolanaBlockAnyArgs = {
  of: BitquerySolanaBlockMeasureable;
};


/** Block in Solana  blockchain */
export type BitquerySolanaBlockBlockHashArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
};


/** Block in Solana  blockchain */
export type BitquerySolanaBlockCountArgs = {
  uniq?: InputMaybe<BitquerySolanaBlockUniq>;
};


/** Block in Solana  blockchain */
export type BitquerySolanaBlockCountBigIntArgs = {
  uniq?: InputMaybe<BitquerySolanaBlockUniq>;
};


/** Block in Solana  blockchain */
export type BitquerySolanaBlockExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Block in Solana  blockchain */
export type BitquerySolanaBlockHeightArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Block in Solana  blockchain */
export type BitquerySolanaBlockMaximumArgs = {
  get?: InputMaybe<BitquerySolanaBlockMeasureable>;
  of: BitquerySolanaBlockMeasureable;
};


/** Block in Solana  blockchain */
export type BitquerySolanaBlockMinimumArgs = {
  get?: InputMaybe<BitquerySolanaBlockMeasureable>;
  of: BitquerySolanaBlockMeasureable;
};


/** Block in Solana  blockchain */
export type BitquerySolanaBlockParentSlotArgs = {
  parentSlot?: InputMaybe<BitqueryIntegerSelector>;
};


/** Block in Solana  blockchain */
export type BitquerySolanaBlockPreviousBlockHashArgs = {
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
};


/** Block in Solana  blockchain */
export type BitquerySolanaBlockRewardsArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  parentSlot?: InputMaybe<BitqueryIntegerSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  rewards?: InputMaybe<BitqueryAmountSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
};


/** Block in Solana  blockchain */
export type BitquerySolanaBlockTransactionCountArgs = {
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitquerySolanaBlockFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  parentSlot?: InputMaybe<BitqueryIntegerSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  rewards?: InputMaybe<BitqueryAmountSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
};

/** Solana Block Info */
export type BitquerySolanaBlockInfo = {
  __typename?: 'BitquerySolanaBlockInfo';
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Block number (height) in blockchain */
  height: Scalars['Int']['output'];
  parentSlot?: Maybe<Scalars['BitqueryBigInt']['output']>;
  previousBlockHash?: Maybe<Scalars['String']['output']>;
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
};

export enum BitquerySolanaBlockMeasureable {
  /** Hash of the the block */
  BlockHash = 'block_hash',
  /** Date */
  Date = 'date',
  /** Number of block in the blockhains */
  Height = 'height',
  /** The slot index of this block`s parent */
  ParentSlot = 'parent_slot',
  /** The block hash of this block`s parent */
  PreviousBlockHash = 'previous_block_hash',
  /** Number of reward lamports credited or debited by the account */
  Rewards = 'rewards',
  /** Time */
  Time = 'time',
  /** Count of transactions in this block */
  TransactionCount = 'transaction_count'
}

/** BlockReward in Solana  blockchain */
export type BitquerySolanaBlockReward = {
  __typename?: 'BitquerySolanaBlockReward';
  /** Account */
  account?: Maybe<Scalars['String']['output']>;
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where  transaction is included */
  block?: Maybe<BitquerySolanaBlockInfo>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  postBalance?: Maybe<Scalars['Float']['output']>;
  /** Type of reward */
  rewardType?: Maybe<Scalars['String']['output']>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
};


/** BlockReward in Solana  blockchain */
export type BitquerySolanaBlockRewardAccountArgs = {
  account?: InputMaybe<BitqueryHashSelector>;
};


/** BlockReward in Solana  blockchain */
export type BitquerySolanaBlockRewardAmountArgs = {
  account?: InputMaybe<BitqueryStringSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  parentSlot?: InputMaybe<BitqueryIntegerSelector>;
  postBalance?: InputMaybe<BitqueryAmountSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  reward?: InputMaybe<BitqueryAmountSelector>;
  rewardType?: InputMaybe<BitqueryRewardTypeSelector>;
};


/** BlockReward in Solana  blockchain */
export type BitquerySolanaBlockRewardAnyArgs = {
  of: BitquerySolanaBlockRewardMeasureable;
};


/** BlockReward in Solana  blockchain */
export type BitquerySolanaBlockRewardBlockArgs = {
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  parentSlot?: InputMaybe<BitqueryStringSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** BlockReward in Solana  blockchain */
export type BitquerySolanaBlockRewardCountArgs = {
  uniq?: InputMaybe<BitquerySolanaBlockRewardUniq>;
};


/** BlockReward in Solana  blockchain */
export type BitquerySolanaBlockRewardCountBigIntArgs = {
  uniq?: InputMaybe<BitquerySolanaBlockRewardUniq>;
};


/** BlockReward in Solana  blockchain */
export type BitquerySolanaBlockRewardExpressionArgs = {
  get: Scalars['String']['input'];
};


/** BlockReward in Solana  blockchain */
export type BitquerySolanaBlockRewardMaximumArgs = {
  get?: InputMaybe<BitquerySolanaBlockRewardMeasureable>;
  of: BitquerySolanaBlockRewardMeasureable;
};


/** BlockReward in Solana  blockchain */
export type BitquerySolanaBlockRewardMinimumArgs = {
  get?: InputMaybe<BitquerySolanaBlockRewardMeasureable>;
  of: BitquerySolanaBlockRewardMeasureable;
};


/** BlockReward in Solana  blockchain */
export type BitquerySolanaBlockRewardPostBalanceArgs = {
  account?: InputMaybe<BitqueryStringSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  parentSlot?: InputMaybe<BitqueryIntegerSelector>;
  postBalance?: InputMaybe<BitqueryAmountSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  reward?: InputMaybe<BitqueryAmountSelector>;
  rewardType?: InputMaybe<BitqueryRewardTypeSelector>;
};


/** BlockReward in Solana  blockchain */
export type BitquerySolanaBlockRewardRewardTypeArgs = {
  rewardType?: InputMaybe<BitqueryRewardTypeSelector>;
};

export type BitquerySolanaBlockRewardFilter = {
  account?: InputMaybe<BitqueryStringSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  parentSlot?: InputMaybe<BitqueryIntegerSelector>;
  postBalance?: InputMaybe<BitqueryAmountSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  reward?: InputMaybe<BitqueryAmountSelector>;
  rewardType?: InputMaybe<BitqueryRewardTypeSelector>;
};

export enum BitquerySolanaBlockRewardMeasureable {
  /** Account */
  Account = 'account',
  /** Number of reward lamports credited or debited by the account */
  Amount = 'amount',
  /** Hash of the the block */
  BlockHash = 'block_hash',
  /** Date */
  Date = 'date',
  /** Number of block in the blockhains */
  Height = 'height',
  /** The slot index of this block`s parent */
  ParentSlot = 'parent_slot',
  /** Account balances after the transaction was processed */
  PostBalance = 'post_balance',
  /** The block hash of this block`s parent */
  PreviousBlockHash = 'previous_block_hash',
  /** Time */
  Time = 'time'
}

export enum BitquerySolanaBlockRewardUniq {
  /** Unique accounts */
  Account = 'account',
  /** Unique hash of the the block */
  BlockHash = 'block_hash',
  /** Unique currencies */
  Currencies = 'currencies',
  /** Unique date count */
  Dates = 'dates',
  /** Unique time */
  Times = 'times'
}

export enum BitquerySolanaBlockUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique Number of block in the blockchains */
  Height = 'height',
  /** Unique time */
  Times = 'times'
}

/** Solana Coinpath */
export type BitquerySolanaCoinpath = {
  __typename?: 'BitquerySolanaCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryAddress>;
  /** Transaction of transfer happened */
  signature?: Maybe<BitquerySolanaSignatureValueDimension>;
};


/** Solana Coinpath */
export type BitquerySolanaCoinpathAmountArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Solana Coinpath */
export type BitquerySolanaCoinpathAnyArgs = {
  of: BitquerySolanaCoinpathMeasureable;
};


/** Solana Coinpath */
export type BitquerySolanaCoinpathMaximumArgs = {
  get?: InputMaybe<BitquerySolanaCoinpathMeasureable>;
  of: BitquerySolanaCoinpathMeasureable;
};


/** Solana Coinpath */
export type BitquerySolanaCoinpathMinimumArgs = {
  get?: InputMaybe<BitquerySolanaCoinpathMeasureable>;
  of: BitquerySolanaCoinpathMeasureable;
};

export enum BitquerySolanaCoinpathMeasureable {
  /** Block */
  Block = 'block',
  /** Depth */
  Depth = 'depth',
  /** Receiver */
  Receiver = 'receiver',
  /** Sender */
  Sender = 'sender',
  /** Signature */
  Signature = 'signature',
  /** Time */
  Time = 'time'
}

/** Crypto currency ( token, coin, currency ) */
export type BitquerySolanaCryptoCurrency = {
  __typename?: 'BitquerySolanaCryptoCurrency';
  /** Token Smart Contract Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Decimals */
  decimals: Scalars['Int']['output'];
  /** Currency name */
  name?: Maybe<Scalars['String']['output']>;
  /** Currency symbol */
  symbol: Scalars['String']['output'];
  /** Token ID */
  tokenId?: Maybe<Scalars['String']['output']>;
  /** Token Type */
  tokenType?: Maybe<Scalars['String']['output']>;
};

/** Currency is defined by a mint address. Solana coin defined as 'SOL'. You can use filter bby symbol, bbut it only works if there is just one token with that symbol */
export type BitquerySolanaCurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Currency not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Instruction in Solana  blockchain */
export type BitquerySolanaInstruction = {
  __typename?: 'BitquerySolanaInstruction';
  /** Accounts count */
  accountsCount?: Maybe<Scalars['Int']['output']>;
  /** Action */
  action?: Maybe<BitqueryAction>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where  transaction is included */
  block?: Maybe<BitquerySolanaBlockInfo>;
  /** Call Path */
  callPath?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Instruction Data */
  data?: Maybe<BitqueryData>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** External */
  external?: Maybe<Scalars['Boolean']['output']>;
  /** External Action */
  externalAction?: Maybe<BitqueryAction>;
  /** External Program */
  externalProgram?: Maybe<BitqueryProgram>;
  log?: Maybe<BitqueryLog>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Program */
  program?: Maybe<BitqueryProgram>;
  /** Transaction where instruction is included */
  transaction?: Maybe<BitquerySolanaTransactionInfo>;
};


/** Instruction in Solana  blockchain */
export type BitquerySolanaInstructionActionArgs = {
  parsedActionName?: InputMaybe<BitqueryStringSelector>;
  parsedType?: InputMaybe<BitqueryStringSelector>;
};


/** Instruction in Solana  blockchain */
export type BitquerySolanaInstructionAnyArgs = {
  of: BitquerySolanaInstructionMeasureable;
};


/** Instruction in Solana  blockchain */
export type BitquerySolanaInstructionBlockArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Instruction in Solana  blockchain */
export type BitquerySolanaInstructionCallPathArgs = {
  callPath?: InputMaybe<BitqueryStringSelector>;
};


/** Instruction in Solana  blockchain */
export type BitquerySolanaInstructionCountArgs = {
  uniq?: InputMaybe<BitquerySolanaInstructionUniq>;
};


/** Instruction in Solana  blockchain */
export type BitquerySolanaInstructionCountBigIntArgs = {
  uniq?: InputMaybe<BitquerySolanaInstructionUniq>;
};


/** Instruction in Solana  blockchain */
export type BitquerySolanaInstructionDataArgs = {
  dataBase58?: InputMaybe<BitqueryStringSelector>;
  dataHex?: InputMaybe<BitqueryStringSelector>;
};


/** Instruction in Solana  blockchain */
export type BitquerySolanaInstructionExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Instruction in Solana  blockchain */
export type BitquerySolanaInstructionExternalArgs = {
  external?: InputMaybe<BitqueryBooleanSelector>;
};


/** Instruction in Solana  blockchain */
export type BitquerySolanaInstructionExternalActionArgs = {
  externalParsedActionName?: InputMaybe<BitqueryStringSelector>;
  externalParsedType?: InputMaybe<BitqueryStringSelector>;
};


/** Instruction in Solana  blockchain */
export type BitquerySolanaInstructionExternalProgramArgs = {
  externalParsedProgramName?: InputMaybe<BitqueryStringSelector>;
  externalProgramId?: InputMaybe<BitqueryStringSelector>;
  externalProgramName?: InputMaybe<BitqueryStringSelector>;
};


/** Instruction in Solana  blockchain */
export type BitquerySolanaInstructionMaximumArgs = {
  get?: InputMaybe<BitquerySolanaInstructionMeasureable>;
  of: BitquerySolanaInstructionMeasureable;
};


/** Instruction in Solana  blockchain */
export type BitquerySolanaInstructionMinimumArgs = {
  get?: InputMaybe<BitquerySolanaInstructionMeasureable>;
  of: BitquerySolanaInstructionMeasureable;
};


/** Instruction in Solana  blockchain */
export type BitquerySolanaInstructionProgramArgs = {
  parsedProgramName?: InputMaybe<BitqueryStringSelector>;
  programId?: InputMaybe<BitqueryStringSelector>;
  programName?: InputMaybe<BitqueryStringSelector>;
};


/** Instruction in Solana  blockchain */
export type BitquerySolanaInstructionTransactionArgs = {
  signature?: InputMaybe<BitqueryHashSelector>;
};

/** InstructionAccount in Solana  blockchain */
export type BitquerySolanaInstructionAccount = {
  __typename?: 'BitquerySolanaInstructionAccount';
  /** Information about account */
  account?: Maybe<BitquerySolanaAccount>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BitquerySolanaBlockInfo>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Instruction */
  instruction?: Maybe<BitqueryInstruction>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Transaction */
  transaction?: Maybe<BitquerySolanaTransactionInfo>;
};


/** InstructionAccount in Solana  blockchain */
export type BitquerySolanaInstructionAccountAccountArgs = {
  accountIndex?: InputMaybe<BitqueryIntegerSelector>;
  accountName?: InputMaybe<BitqueryStringSelector>;
  accountOwner?: InputMaybe<BitqueryStringSelector>;
  accountType?: InputMaybe<BitqueryStringSelector>;
};


/** InstructionAccount in Solana  blockchain */
export type BitquerySolanaInstructionAccountAnyArgs = {
  of: BitquerySolanaInstructionAccountMeasureable;
};


/** InstructionAccount in Solana  blockchain */
export type BitquerySolanaInstructionAccountBlockArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** InstructionAccount in Solana  blockchain */
export type BitquerySolanaInstructionAccountCountArgs = {
  uniq?: InputMaybe<BitquerySolanaInstructionAccountUniq>;
};


/** InstructionAccount in Solana  blockchain */
export type BitquerySolanaInstructionAccountCountBigIntArgs = {
  uniq?: InputMaybe<BitquerySolanaInstructionAccountUniq>;
};


/** InstructionAccount in Solana  blockchain */
export type BitquerySolanaInstructionAccountExpressionArgs = {
  get: Scalars['String']['input'];
};


/** InstructionAccount in Solana  blockchain */
export type BitquerySolanaInstructionAccountMaximumArgs = {
  get?: InputMaybe<BitquerySolanaInstructionAccountMeasureable>;
  of: BitquerySolanaInstructionAccountMeasureable;
};


/** InstructionAccount in Solana  blockchain */
export type BitquerySolanaInstructionAccountMinimumArgs = {
  get?: InputMaybe<BitquerySolanaInstructionAccountMeasureable>;
  of: BitquerySolanaInstructionAccountMeasureable;
};


/** InstructionAccount in Solana  blockchain */
export type BitquerySolanaInstructionAccountTransactionArgs = {
  signature?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitquerySolanaInstructionAccountFilter = {
  account?: InputMaybe<BitqueryStringSelector>;
  accountIndex?: InputMaybe<BitqueryIntegerSelector>;
  accountOwner?: InputMaybe<BitqueryStringSelector>;
  accountType?: InputMaybe<BitqueryStringSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  callPath?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<BitqueryIntegerSelector>;
  fee?: InputMaybe<BitqueryIntegerSelector>;
  feePayer?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  parsed?: InputMaybe<BitqueryIntegerSelector>;
  parsedActionName?: InputMaybe<BitqueryStringSelector>;
  parsedProgramName?: InputMaybe<BitqueryStringSelector>;
  parsedType?: InputMaybe<BitqueryStringSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  programId?: InputMaybe<BitqueryStringSelector>;
  signature?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
};

export enum BitquerySolanaInstructionAccountMeasureable {
  /** Hash of the the block */
  BlockHash = 'block_hash',
  /** Date */
  Date = 'date',
  /** Number of block in the blockhains */
  Height = 'height',
  /** The block hash of this block`s parent */
  PreviousBlockHash = 'previous_block_hash',
  /** Transaction Hash */
  Signature = 'signature',
  /** Time */
  Time = 'time'
}

export enum BitquerySolanaInstructionAccountUniq {
  /** Account name */
  AccountName = 'account_name',
  /** Unique date count */
  Dates = 'dates',
  /** Number of block in the blockchains */
  Height = 'height',
  /** Transaction Hash */
  Signature = 'signature',
  /** Unique time */
  Times = 'times'
}

export type BitquerySolanaInstructionFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  callPath?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<BitqueryIntegerSelector>;
  externalParsed?: InputMaybe<BitqueryIntegerSelector>;
  externalParsedActionName?: InputMaybe<BitqueryStringSelector>;
  externalParsedProgramName?: InputMaybe<BitqueryStringSelector>;
  externalParsedType?: InputMaybe<BitqueryStringSelector>;
  externalProgramId?: InputMaybe<BitqueryStringSelector>;
  fee?: InputMaybe<BitqueryIntegerSelector>;
  feePayer?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  parsed?: InputMaybe<BitqueryIntegerSelector>;
  parsedActionName?: InputMaybe<BitqueryStringSelector>;
  parsedProgramName?: InputMaybe<BitqueryStringSelector>;
  parsedType?: InputMaybe<BitqueryStringSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  programId?: InputMaybe<BitqueryStringSelector>;
  signature?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
};

export enum BitquerySolanaInstructionMeasureable {
  /** Hash of the the block */
  BlockHash = 'block_hash',
  /** Date */
  Date = 'date',
  /** Transaction Fee */
  Fee = 'fee',
  /** Number of block in the blockhains */
  Height = 'height',
  /** The block hash of this block`s parent */
  PreviousBlockHash = 'previous_block_hash',
  /** Transaction Hash */
  Signature = 'signature',
  /** Time */
  Time = 'time'
}

export enum BitquerySolanaInstructionUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Number of block in the blockchains */
  Height = 'height',
  /** Transaction Hash */
  Signature = 'signature',
  /** Unique time */
  Times = 'times'
}

export enum BitquerySolanaNetwork {
  /** Solana Mainnat */
  Solana = 'solana'
}

export enum BitquerySolanaRewardType {
  /** fee type */
  Fee = 'Fee',
  /** rent type */
  Rent = 'Rent',
  /** staking type */
  Staking = 'Staking',
  /** voing type */
  Voting = 'Voting'
}

/** Blockchain transaction with value */
export type BitquerySolanaSignatureValueDimension = {
  __typename?: 'BitquerySolanaSignatureValueDimension';
  /** Transaction hash */
  hash: Scalars['String']['output'];
  /** Transaction value */
  value: Scalars['Float']['output'];
};

/** Transaction in Solana  blockchain */
export type BitquerySolanaTransaction = {
  __typename?: 'BitquerySolanaTransaction';
  /** Count of inner instructions */
  accountsCount?: Maybe<Scalars['Int']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where  transaction is included */
  block?: Maybe<BitquerySolanaBlockInfo>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  /** Error */
  error?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Fee Payer */
  feePayer?: Maybe<Scalars['String']['output']>;
  /** Count of inner instructions */
  innerInstructionsCount?: Maybe<Scalars['Int']['output']>;
  /** Count of instructions */
  instructionsCount?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Recent blockhash prevents duplication and to give transactions lifetimes */
  recentBlockHash?: Maybe<Scalars['String']['output']>;
  /** Transaction Hash */
  signature?: Maybe<Scalars['String']['output']>;
  /** Accounts` public keys */
  signer?: Maybe<Scalars['String']['output']>;
  /** Successed or failed */
  success?: Maybe<Scalars['Boolean']['output']>;
  transactionFee?: Maybe<Scalars['Float']['output']>;
  /** Transaction Index */
  transactionIndex?: Maybe<Scalars['Int']['output']>;
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionAccountsCountArgs = {
  accountsCount?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionAnyArgs = {
  of: BitquerySolanaTransactionMeasureable;
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionBlockArgs = {
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionCountArgs = {
  uniq?: InputMaybe<BitquerySolanaTransactionUniq>;
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionCountBigIntArgs = {
  uniq?: InputMaybe<BitquerySolanaTransactionUniq>;
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionErrorArgs = {
  error?: InputMaybe<BitqueryStringSelector>;
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionFeePayerArgs = {
  feePayer?: InputMaybe<BitqueryHashSelector>;
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionInnerInstructionsCountArgs = {
  innerInstructionsCount?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionInstructionsCountArgs = {
  instructionsCount?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionMaximumArgs = {
  get?: InputMaybe<BitquerySolanaTransactionMeasureable>;
  of: BitquerySolanaTransactionMeasureable;
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionMinimumArgs = {
  get?: InputMaybe<BitquerySolanaTransactionMeasureable>;
  of: BitquerySolanaTransactionMeasureable;
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionRecentBlockHashArgs = {
  recentBlockHash?: InputMaybe<BitqueryHashSelector>;
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionSignatureArgs = {
  signature?: InputMaybe<BitqueryHashSelector>;
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionSignerArgs = {
  signer?: InputMaybe<BitqueryHashSelector>;
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionSuccessArgs = {
  success?: InputMaybe<BitqueryBooleanSelector>;
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionTransactionFeeArgs = {
  accountsCount?: InputMaybe<BitqueryIntegerSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryIntegerSelector>;
  feePayer?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  innerInstructionsCount?: InputMaybe<BitqueryIntegerSelector>;
  instructionsCount?: InputMaybe<BitqueryIntegerSelector>;
  parentSlot?: InputMaybe<BitqueryBlockSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  recentBlockHash?: InputMaybe<BitqueryHashSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  signer?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  transactionFee?: InputMaybe<BitqueryAmountSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionTransactionIndexArgs = {
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitquerySolanaTransactionFilter = {
  accountsCount?: InputMaybe<BitqueryIntegerSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryIntegerSelector>;
  feePayer?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  innerInstructionsCount?: InputMaybe<BitqueryIntegerSelector>;
  instructionsCount?: InputMaybe<BitqueryIntegerSelector>;
  parentSlot?: InputMaybe<BitqueryBlockSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  recentBlockHash?: InputMaybe<BitqueryHashSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  signer?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  transactionFee?: InputMaybe<BitqueryAmountSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
};

/** Solana Transaction Info */
export type BitquerySolanaTransactionInfo = {
  __typename?: 'BitquerySolanaTransactionInfo';
  feePayer?: Maybe<Scalars['String']['output']>;
  signature?: Maybe<Scalars['String']['output']>;
  success?: Maybe<Scalars['Boolean']['output']>;
  transactionIndex?: Maybe<Scalars['BitqueryBigInt']['output']>;
};

/** Solana Transaction Info Extended */
export type BitquerySolanaTransactionInfoExt = {
  __typename?: 'BitquerySolanaTransactionInfoExt';
  accountsCount?: Maybe<Scalars['Int']['output']>;
  error?: Maybe<Scalars['String']['output']>;
  fee?: Maybe<Scalars['Float']['output']>;
  feePayer?: Maybe<Scalars['String']['output']>;
  innerInstructionsCount?: Maybe<Scalars['Int']['output']>;
  instructionsCount?: Maybe<Scalars['Int']['output']>;
  recentBlockHash?: Maybe<Scalars['String']['output']>;
  signature?: Maybe<Scalars['String']['output']>;
  signer?: Maybe<Scalars['String']['output']>;
  success?: Maybe<Scalars['Boolean']['output']>;
  transactionIndex?: Maybe<Scalars['BitqueryBigInt']['output']>;
};

export enum BitquerySolanaTransactionMeasureable {
  /** Hash of the the block */
  BlockHash = 'block_hash',
  /** Date */
  Date = 'date',
  /** Transaction Fee */
  Fee = 'fee',
  /** Number of block in the blockhains */
  Height = 'height',
  /** The slot index of this block`s parent */
  ParentSlot = 'parent_slot',
  /** The block hash of this block`s parent */
  PreviousBlockHash = 'previous_block_hash',
  /** Transaction Hash */
  Signature = 'signature',
  /** Time */
  Time = 'time',
  /** Transaction Fee */
  TransactionFee = 'transaction_fee'
}

export enum BitquerySolanaTransactionUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Number of block in the blockchains */
  Height = 'height',
  /** Transaction Hash */
  Signature = 'signature',
  /** Accounts` public key */
  Signer = 'signer',
  /** Unique time */
  Times = 'times'
}

/** Currency transfers from/to addresses in crypto currencies */
export type BitquerySolanaTransfer = {
  __typename?: 'BitquerySolanaTransfer';
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BitquerySolanaBlockInfo>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitquerySolanaCryptoCurrency>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Instruction where transfer is included */
  instruction?: Maybe<BitqueryInstructionWithExternals>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver */
  receiver?: Maybe<BitqueryReceiver>;
  /** Sender */
  sender?: Maybe<BitquerySender>;
  /** Transaction where transfer is included */
  transaction?: Maybe<BitquerySolanaTransactionInfoExt>;
  /** Transfer Type */
  transferType?: Maybe<Scalars['String']['output']>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitquerySolanaTransferAmountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  callPath?: InputMaybe<BitqueryStringSelector>;
  currency?: InputMaybe<Array<BitquerySolanaCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<BitqueryStringSelector>;
  externalParsed?: InputMaybe<BitqueryIntegerSelector>;
  externalParsedActionName?: InputMaybe<BitqueryStringSelector>;
  externalParsedProgramName?: InputMaybe<BitqueryStringSelector>;
  externalParsedType?: InputMaybe<BitqueryStringSelector>;
  externalProgramId?: InputMaybe<BitqueryStringSelector>;
  feePayer?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  parsed?: InputMaybe<BitqueryIntegerSelector>;
  parsedActionName?: InputMaybe<BitqueryStringSelector>;
  parsedProgramName?: InputMaybe<BitqueryStringSelector>;
  parsedType?: InputMaybe<BitqueryStringSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  programId?: InputMaybe<BitqueryStringSelector>;
  receiverAddress?: InputMaybe<BitqueryStringSelector>;
  receiverMintAddress?: InputMaybe<BitqueryStringSelector>;
  receiverType?: InputMaybe<BitqueryStringSelector>;
  recentBlockHash?: InputMaybe<BitqueryHashSelector>;
  senderAddress?: InputMaybe<BitqueryStringSelector>;
  senderMintAddress?: InputMaybe<BitqueryStringSelector>;
  senderType?: InputMaybe<BitqueryStringSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  signer?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tokenAccount?: InputMaybe<Array<BitqueryStringSelector>>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transferType?: InputMaybe<BitquerySolanaTransferTypeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitquerySolanaTransferAnyArgs = {
  of: BitquerySolanaTransferMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitquerySolanaTransferBlockArgs = {
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitquerySolanaTransferCountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  callPath?: InputMaybe<BitqueryStringSelector>;
  currency?: InputMaybe<Array<BitquerySolanaCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<BitqueryStringSelector>;
  externalParsed?: InputMaybe<BitqueryIntegerSelector>;
  externalParsedActionName?: InputMaybe<BitqueryStringSelector>;
  externalParsedProgramName?: InputMaybe<BitqueryStringSelector>;
  externalParsedType?: InputMaybe<BitqueryStringSelector>;
  externalProgramId?: InputMaybe<BitqueryStringSelector>;
  feePayer?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  parsed?: InputMaybe<BitqueryIntegerSelector>;
  parsedActionName?: InputMaybe<BitqueryStringSelector>;
  parsedProgramName?: InputMaybe<BitqueryStringSelector>;
  parsedType?: InputMaybe<BitqueryStringSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  programId?: InputMaybe<BitqueryStringSelector>;
  receiverAddress?: InputMaybe<BitqueryStringSelector>;
  receiverMintAddress?: InputMaybe<BitqueryStringSelector>;
  receiverType?: InputMaybe<BitqueryStringSelector>;
  recentBlockHash?: InputMaybe<BitqueryHashSelector>;
  senderAddress?: InputMaybe<BitqueryStringSelector>;
  senderMintAddress?: InputMaybe<BitqueryStringSelector>;
  senderType?: InputMaybe<BitqueryStringSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  signer?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tokenAccount?: InputMaybe<Array<BitqueryStringSelector>>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transferType?: InputMaybe<BitquerySolanaTransferTypeSelector>;
  uniq?: InputMaybe<BitquerySolanaTransferUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitquerySolanaTransferCountBigIntArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  callPath?: InputMaybe<BitqueryStringSelector>;
  currency?: InputMaybe<Array<BitquerySolanaCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<BitqueryStringSelector>;
  externalParsed?: InputMaybe<BitqueryIntegerSelector>;
  externalParsedActionName?: InputMaybe<BitqueryStringSelector>;
  externalParsedProgramName?: InputMaybe<BitqueryStringSelector>;
  externalParsedType?: InputMaybe<BitqueryStringSelector>;
  externalProgramId?: InputMaybe<BitqueryStringSelector>;
  feePayer?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  parsed?: InputMaybe<BitqueryIntegerSelector>;
  parsedActionName?: InputMaybe<BitqueryStringSelector>;
  parsedProgramName?: InputMaybe<BitqueryStringSelector>;
  parsedType?: InputMaybe<BitqueryStringSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  programId?: InputMaybe<BitqueryStringSelector>;
  receiverAddress?: InputMaybe<BitqueryStringSelector>;
  receiverMintAddress?: InputMaybe<BitqueryStringSelector>;
  receiverType?: InputMaybe<BitqueryStringSelector>;
  recentBlockHash?: InputMaybe<BitqueryHashSelector>;
  senderAddress?: InputMaybe<BitqueryStringSelector>;
  senderMintAddress?: InputMaybe<BitqueryStringSelector>;
  senderType?: InputMaybe<BitqueryStringSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  signer?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tokenAccount?: InputMaybe<Array<BitqueryStringSelector>>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transferType?: InputMaybe<BitquerySolanaTransferTypeSelector>;
  uniq?: InputMaybe<BitquerySolanaTransferUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitquerySolanaTransferExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitquerySolanaTransferMaximumArgs = {
  get?: InputMaybe<BitquerySolanaTransferMeasureable>;
  of: BitquerySolanaTransferMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitquerySolanaTransferMinimumArgs = {
  get?: InputMaybe<BitquerySolanaTransferMeasureable>;
  of: BitquerySolanaTransferMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitquerySolanaTransferTransactionArgs = {
  signature?: InputMaybe<BitqueryHashSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitquerySolanaTransferTransferTypeArgs = {
  transferType?: InputMaybe<BitquerySolanaTransferTypeSelector>;
};

export type BitquerySolanaTransferFilter = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  callPath?: InputMaybe<BitqueryStringSelector>;
  currency?: InputMaybe<Array<BitquerySolanaCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<BitqueryStringSelector>;
  externalParsed?: InputMaybe<BitqueryIntegerSelector>;
  externalParsedActionName?: InputMaybe<BitqueryStringSelector>;
  externalParsedProgramName?: InputMaybe<BitqueryStringSelector>;
  externalParsedType?: InputMaybe<BitqueryStringSelector>;
  externalProgramId?: InputMaybe<BitqueryStringSelector>;
  feePayer?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  parsed?: InputMaybe<BitqueryIntegerSelector>;
  parsedActionName?: InputMaybe<BitqueryStringSelector>;
  parsedProgramName?: InputMaybe<BitqueryStringSelector>;
  parsedType?: InputMaybe<BitqueryStringSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  programId?: InputMaybe<BitqueryStringSelector>;
  receiverAddress?: InputMaybe<BitqueryStringSelector>;
  receiverMintAddress?: InputMaybe<BitqueryStringSelector>;
  receiverType?: InputMaybe<BitqueryStringSelector>;
  recentBlockHash?: InputMaybe<BitqueryHashSelector>;
  senderAddress?: InputMaybe<BitqueryStringSelector>;
  senderMintAddress?: InputMaybe<BitqueryStringSelector>;
  senderType?: InputMaybe<BitqueryStringSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  signer?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tokenAccount?: InputMaybe<Array<BitqueryStringSelector>>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transferType?: InputMaybe<BitquerySolanaTransferTypeSelector>;
};

export enum BitquerySolanaTransferMeasureable {
  /** Amount Transfer */
  Amount = 'amount',
  /** Hash of the the block */
  BlockHash = 'block_hash',
  /** Currency Name */
  CurrencyName = 'currency_name',
  /** Currency Symbol */
  CurrencySymbol = 'currency_symbol',
  /** Date */
  Date = 'date',
  /** Transaction Fee */
  FeePayer = 'fee_payer',
  /** Number of block in the blockhains */
  Height = 'height',
  /** The block hash of this block`s parent */
  PreviousBlockHash = 'previous_block_hash',
  /** Transaction Hash */
  Signature = 'signature',
  /** Time */
  Time = 'time',
  /** Token ID */
  TokenId = 'token_id',
  /** Token Type */
  TokenType = 'token_type',
  /** Transfer Type */
  TransferType = 'transfer_type'
}

export enum BitquerySolanaTransferType {
  /** Burn */
  Burn = 'burn',
  /** Close Account */
  CloseAccount = 'close_account',
  /** Create Account */
  CreateAccount = 'create_account',
  /** Mint */
  Mint = 'mint',
  /** Nonce Withdraw */
  NonceWithdraw = 'nonce_withdraw',
  /** Rent Exemption */
  RentExemption = 'rent_exemption',
  /** Self */
  Self = 'self',
  /** Stake */
  Stake = 'stake',
  /** Stake Withdraw */
  StakeWithdraw = 'stake_withdraw',
  /** Trade Unknown */
  TradeUnknown = 'trade_unknown',
  /** Transfer */
  Transfer = 'transfer',
  /** Vote */
  Vote = 'vote'
}

/** Select by transfer type */
export type BitquerySolanaTransferTypeSelector = {
  /** Type in the list */
  in?: InputMaybe<Array<BitquerySolanaTransferType>>;
  /** Type is */
  is?: InputMaybe<BitquerySolanaTransferType>;
  /** Type not */
  not?: InputMaybe<BitquerySolanaTransferType>;
  /** Type not in the list */
  notIn?: InputMaybe<Array<BitquerySolanaTransferType>>;
};

export enum BitquerySolanaTransferUniq {
  /** Currencies */
  Currencies = 'currencies',
  /** Unique date count */
  Dates = 'dates',
  /** Fee Payer */
  FeePayer = 'fee_payer',
  /** Number of block in the blockchains */
  Height = 'height',
  /** Transfer To */
  ReceiverAddress = 'receiver_address',
  /** Transfer To Mint Address */
  ReceiverMintAddress = 'receiver_mint_address',
  /** Transfer From */
  SenderAddress = 'sender_address',
  /** Transfer From Mint Address */
  SenderMintAddress = 'sender_mint_address',
  /** Transaction Hash */
  Signature = 'signature',
  /** Signer */
  Signer = 'signer',
  /** Unique time */
  Times = 'times',
  /** Token Account Address */
  TokenAccount = 'token_account'
}

export enum BitqueryStakingTransactionsTypeEnum {
  CollectRewards = 'CollectRewards',
  CreateValidator = 'CreateValidator',
  Delegate = 'Delegate',
  EditValidator = 'EditValidator',
  Undelegate = 'Undelegate'
}

/** Indicates what type of operation the transaction is supposed to do. */
export type BitqueryStakingTransactionsTypeSelector = {
  /** Type in the list */
  in?: InputMaybe<Array<BitqueryStakingTransactionsTypeEnum>>;
  /** Type is */
  is?: InputMaybe<BitqueryStakingTransactionsTypeEnum>;
  /** Type not */
  not?: InputMaybe<BitqueryStakingTransactionsTypeEnum>;
  /** Type not in the list */
  notIn?: InputMaybe<Array<BitqueryStakingTransactionsTypeEnum>>;
};

/** Stellar Chain */
export type BitqueryStellar = {
  __typename?: 'BitqueryStellar';
  /** Basic information about address */
  address: Array<BitqueryStellarAddressInfo>;
  /** Blockchain Address Statistics */
  addressStats?: Maybe<Array<BitqueryStellarAddressStats>>;
  /** Stellar Balance Effects */
  balanceEffects?: Maybe<Array<BitqueryStellarBalanceEffect>>;
  /** Stellar Ledgers */
  blocks?: Maybe<Array<BitqueryStellarBlock>>;
  /** Stellar Claimable Balance Effects */
  claimableBalanceEffects?: Maybe<Array<BitqueryStellarClaimableBalanceEffect>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryStellarCoinpath>>;
  /** Stellar Effect Arguments */
  effectArguments?: Maybe<Array<BitqueryStellarEffectArgument>>;
  /** Stellar Effects */
  effects?: Maybe<Array<BitqueryStellarEffect>>;
  /** Stellar Liquidity Pool Effects */
  liquidityPoolEffects?: Maybe<Array<BitqueryStellarLiquidityPoolEffect>>;
  /** Stellar Liquidity Pool Trade Effects */
  liquidityPoolTradeEffects?: Maybe<Array<BitqueryStellarLiquidityPoolTradeEffect>>;
  /** Stellar Operations */
  operations?: Maybe<Array<BitqueryStellarOperation>>;
  /** Stellar Payments */
  payments?: Maybe<Array<BitqueryStellarPayment>>;
  /** Stellar Trade Effects */
  tradeEffects?: Maybe<Array<BitqueryStellarTradeEffect>>;
  /** Stellar Transactions */
  transactions?: Maybe<Array<BitqueryStellarTransaction>>;
  /** Stellar Transfers */
  transfers?: Maybe<Array<BitqueryStellarTransfer>>;
};


/** Stellar Chain */
export type BitqueryStellarAddressArgs = {
  address: Array<BitqueryAddressSelectorIn>;
};


/** Stellar Chain */
export type BitqueryStellarAddressStatsArgs = {
  address: BitqueryAddressSelector;
  options?: InputMaybe<BitqueryQueryOptions>;
};


/** Stellar Chain */
export type BitqueryStellarBalanceEffectsArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  any?: InputMaybe<Array<BitqueryStellarBalanceEffectFilter>>;
  block?: InputMaybe<BitqueryBlockSelector>;
  currencyName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Stellar Chain */
export type BitqueryStellarBlocksArgs = {
  any?: InputMaybe<Array<BitqueryStellarBlockFilter>>;
  baseFee?: InputMaybe<BitqueryFloatSelector>;
  baseReserve?: InputMaybe<BitqueryFloatSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  feePool?: InputMaybe<BitqueryFloatSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maxTxSetSize?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  protocolVersion?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  totalCoins?: InputMaybe<BitqueryFloatSelector>;
};


/** Stellar Chain */
export type BitqueryStellarClaimableBalanceEffectsArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  any?: InputMaybe<Array<BitqueryStellarClaimableBalanceEffectFilter>>;
  balanceId?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  claimant?: InputMaybe<BitqueryAddressSelector>;
  currencyName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  sponsor?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Stellar Chain */
export type BitqueryStellarCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currencyFrom?: InputMaybe<BitqueryCurrencySelector>;
  currencyTo?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCoinpathOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Stellar Chain */
export type BitqueryStellarEffectArgumentsArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  any?: InputMaybe<Array<BitqueryStellarEffectArgumentFilter>>;
  argname?: InputMaybe<BitqueryStringSelector>;
  argvalue?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Stellar Chain */
export type BitqueryStellarEffectsArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  any?: InputMaybe<Array<BitqueryStellarEffectFilter>>;
  block?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  details?: InputMaybe<BitqueryStringSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Stellar Chain */
export type BitqueryStellarLiquidityPoolEffectsArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  any?: InputMaybe<Array<BitqueryStellarLiquidityPoolEffectFilter>>;
  block?: InputMaybe<BitqueryBlockSelector>;
  currencyName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  liquidityPoolDetails?: InputMaybe<BitqueryStringSelector>;
  liquidityPoolId?: InputMaybe<BitqueryStringSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  shares?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Stellar Chain */
export type BitqueryStellarLiquidityPoolTradeEffectsArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  any?: InputMaybe<Array<BitqueryStellarLiquidityPoolTradeEffectFilter>>;
  block?: InputMaybe<BitqueryBlockSelector>;
  buyAmount?: InputMaybe<BitqueryFloatSelector>;
  buyCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  buyIssuer?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  liquidityPoolDetails?: InputMaybe<BitqueryStringSelector>;
  liquidityPoolId?: InputMaybe<BitqueryStringSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  sellAmount?: InputMaybe<BitqueryFloatSelector>;
  sellCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  sellIssuer?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Stellar Chain */
export type BitqueryStellarOperationsArgs = {
  any?: InputMaybe<Array<BitqueryStellarOperationFilter>>;
  block?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  details?: InputMaybe<BitqueryStringSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  sourceAccount?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Stellar Chain */
export type BitqueryStellarPaymentsArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  any?: InputMaybe<Array<BitqueryStellarPaymentFilter>>;
  block?: InputMaybe<BitqueryBlockSelector>;
  creditedToValue?: InputMaybe<BitqueryFloatSelector>;
  currencyFromName?: InputMaybe<BitqueryCurrencySelector>;
  currencyToName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  debitedFromValue?: InputMaybe<BitqueryFloatSelector>;
  issuerFrom?: InputMaybe<BitqueryAddressSelector>;
  issuerTo?: InputMaybe<BitqueryAddressSelector>;
  maxValueFrom?: InputMaybe<BitqueryFloatSelector>;
  minValueTo?: InputMaybe<BitqueryFloatSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  path?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Stellar Chain */
export type BitqueryStellarTradeEffectsArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  any?: InputMaybe<Array<BitqueryStellarTradeEffectFilter>>;
  block?: InputMaybe<BitqueryBlockSelector>;
  buyAmount?: InputMaybe<BitqueryFloatSelector>;
  buyCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  buyIssuer?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  offerId?: InputMaybe<BitqueryIntegerSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  sellAmount?: InputMaybe<BitqueryFloatSelector>;
  sellCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  sellIssuer?: InputMaybe<BitqueryAddressSelector>;
  seller?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Stellar Chain */
export type BitqueryStellarTransactionsArgs = {
  any?: InputMaybe<Array<BitqueryStellarTransactionFilter>>;
  block?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  maxFee?: InputMaybe<BitqueryFloatSelector>;
  memoType?: InputMaybe<BitqueryStringSelector>;
  memos?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  sequence?: InputMaybe<BitqueryIntegerSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  timeBounds?: InputMaybe<BitqueryStringSelector>;
};


/** Stellar Chain */
export type BitqueryStellarTransfersArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  any?: InputMaybe<Array<BitqueryStellarTransferFilter>>;
  block?: InputMaybe<BitqueryBlockSelector>;
  currencyFromName?: InputMaybe<BitqueryCurrencySelector>;
  currencyToName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  direction?: InputMaybe<BitqueryStringSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};

/** Address detailed information for Stellar network */
export type BitqueryStellarAddressInfo = {
  __typename?: 'BitqueryStellarAddressInfo';
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** XLM balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** Token Balances */
  tokenBalances?: Maybe<Array<BitqueryStellarTokenBalances>>;
};


/** Address detailed information for Stellar network */
export type BitqueryStellarAddressInfoBalanceArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};

/**
 * Counts and aggregates for the address, transfer count,
 *                   amount, number of distinct currencies,
 *                   times of the first and the last transactions
 */
export type BitqueryStellarAddressStat = {
  __typename?: 'BitqueryStellarAddressStat';
  /** Address */
  address?: Maybe<BitqueryAddress>;
  /** Balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** Days with received */
  daysWithReceived?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Days with sent */
  daysWithSent?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Days with transactions */
  daysWithTransactions?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Days with transfers */
  daysWithTransfers?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** First transfer at */
  firstTransferAt?: Maybe<BitqueryDateTime>;
  /** First tx at */
  firstTxAt?: Maybe<BitqueryDateTime>;
  /** Last transfer at */
  lastTransferAt?: Maybe<BitqueryDateTime>;
  /** Last tx at */
  lastTxAt?: Maybe<BitqueryDateTime>;
  /** Receive Amount */
  receiveAmount?: Maybe<Scalars['Float']['output']>;
  /** Receive from Count */
  receiveFromCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Receive from currencies */
  receiveFromCurrencies?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Receive tx Count */
  receiveTxCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Send Amount */
  sendAmount?: Maybe<Scalars['Float']['output']>;
  /** Send to count */
  sendToCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Send to currencies */
  sendToCurrencies?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Send tx count */
  sendTxCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
};

/** AddressStat */
export type BitqueryStellarAddressStats = {
  __typename?: 'BitqueryStellarAddressStats';
  /** Address With Statistics */
  address?: Maybe<BitqueryStellarAddressStat>;
};

/** Balance effect in Stellar blockchain */
export type BitqueryStellarBalanceEffect = {
  __typename?: 'BitqueryStellarBalanceEffect';
  /** Address */
  address?: Maybe<BitqueryAddress>;
  amount?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Effect index */
  effectIndex?: Maybe<Scalars['Int']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Issuer */
  issuer?: Maybe<BitqueryAddress>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<BitqueryOperationIndexedWithAccount>;
  /** Order */
  order?: Maybe<Scalars['Int']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryStellarTransactionDimension>;
};


/** Balance effect in Stellar blockchain */
export type BitqueryStellarBalanceEffectAmountArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currencyName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Balance effect in Stellar blockchain */
export type BitqueryStellarBalanceEffectAnyArgs = {
  of: BitqueryStellarBalanceEffectMeasurable;
};


/** Balance effect in Stellar blockchain */
export type BitqueryStellarBalanceEffectCountArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  currencyName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarBalanceEffectUniq>;
};


/** Balance effect in Stellar blockchain */
export type BitqueryStellarBalanceEffectCountBigIntArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  currencyName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarBalanceEffectUniq>;
};


/** Balance effect in Stellar blockchain */
export type BitqueryStellarBalanceEffectExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Balance effect in Stellar blockchain */
export type BitqueryStellarBalanceEffectMaximumArgs = {
  get?: InputMaybe<BitqueryStellarBalanceEffectMeasurable>;
  of: BitqueryStellarBalanceEffectMeasurable;
};


/** Balance effect in Stellar blockchain */
export type BitqueryStellarBalanceEffectMinimumArgs = {
  get?: InputMaybe<BitqueryStellarBalanceEffectMeasurable>;
  of: BitqueryStellarBalanceEffectMeasurable;
};

export type BitqueryStellarBalanceEffectFilter = {
  address?: InputMaybe<BitqueryAddressSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  currencyName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};

export enum BitqueryStellarBalanceEffectMeasurable {
  /** Address */
  Address = 'address',
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Currency name */
  CurrencyName = 'currencyName',
  /** Currency symbol */
  CurrencySymbol = 'currencySymbol',
  /** Date */
  Date = 'date',
  /** Effect index */
  EffectIndex = 'effectIndex',
  /** Issuer */
  Issuer = 'issuer',
  /** Operation index */
  OpIndex = 'opIndex',
  /** Operation source account */
  OpSourceAccount = 'opSourceAccount',
  /** Operation */
  Operation = 'operation',
  /** Order */
  Order = 'order',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TransactionHash = 'transactionHash',
  /** Transaction index */
  TransactionIndex = 'transactionIndex',
  /** Transaction sender */
  TransactionSender = 'transactionSender'
}

export enum BitqueryStellarBalanceEffectUniq {
  /** Uniq addresses count */
  Addresses = 'addresses',
  /** Uniq blocks count */
  Blocks = 'blocks',
  /** Uniq currencies name count */
  CurrenciesName = 'currenciesName',
  /** Uniq currencies symbol count */
  CurrenciesSymbol = 'currenciesSymbol',
  /** Uniq dates count */
  Dates = 'dates',
  /** Uniq effect indices count */
  EffectIndices = 'effectIndices',
  /** Uniq issuers count */
  Issuers = 'issuers',
  /** Uniq operation indices count */
  OpIndices = 'opIndices',
  /** Uniq operation source accounts count */
  OpSourceAccounts = 'opSourceAccounts',
  /** Uniq operations count */
  Operations = 'operations',
  /** Uniq orders count */
  Orders = 'orders',
  /** Uniq times count */
  Times = 'times',
  /** Uniq transaction hashes count */
  TransactionHashes = 'transactionHashes',
  /** Uniq transaction indices count */
  TransactionIndices = 'transactionIndices',
  /** Uniq transaction senders count */
  TransactionSenders = 'transactionSenders'
}

/** Block in Stellar blockchain */
export type BitqueryStellarBlock = {
  __typename?: 'BitqueryStellarBlock';
  any?: Maybe<Scalars['String']['output']>;
  baseFee?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  baseReserve?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  feePool?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  /** Block hash */
  hash: Scalars['String']['output'];
  /** Ledger number (block|height) in blockchain */
  height: Scalars['Int']['output'];
  /** Max transaction set size */
  maxTxSetSize: Scalars['Int']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Protocol version */
  protocolVersion: Scalars['Int']['output'];
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  totalCoins?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
};


/** Block in Stellar blockchain */
export type BitqueryStellarBlockAnyArgs = {
  of: BitqueryStellarBlockMeasurable;
};


/** Block in Stellar blockchain */
export type BitqueryStellarBlockBaseFeeArgs = {
  baseFee?: InputMaybe<BitqueryFloatSelector>;
  baseReserve?: InputMaybe<BitqueryFloatSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feePool?: InputMaybe<BitqueryFloatSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maxTxSetSize?: InputMaybe<BitqueryIntegerSelector>;
  protocolVersion?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  totalCoins?: InputMaybe<BitqueryFloatSelector>;
};


/** Block in Stellar blockchain */
export type BitqueryStellarBlockBaseReserveArgs = {
  baseFee?: InputMaybe<BitqueryFloatSelector>;
  baseReserve?: InputMaybe<BitqueryFloatSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feePool?: InputMaybe<BitqueryFloatSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maxTxSetSize?: InputMaybe<BitqueryIntegerSelector>;
  protocolVersion?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  totalCoins?: InputMaybe<BitqueryFloatSelector>;
};


/** Block in Stellar blockchain */
export type BitqueryStellarBlockCountArgs = {
  baseFee?: InputMaybe<BitqueryFloatSelector>;
  baseReserve?: InputMaybe<BitqueryFloatSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  feePool?: InputMaybe<BitqueryFloatSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maxTxSetSize?: InputMaybe<BitqueryIntegerSelector>;
  protocolVersion?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  totalCoins?: InputMaybe<BitqueryFloatSelector>;
  uniq?: InputMaybe<BitqueryStellarBlockUniq>;
};


/** Block in Stellar blockchain */
export type BitqueryStellarBlockCountBigIntArgs = {
  baseFee?: InputMaybe<BitqueryFloatSelector>;
  baseReserve?: InputMaybe<BitqueryFloatSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  feePool?: InputMaybe<BitqueryFloatSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maxTxSetSize?: InputMaybe<BitqueryIntegerSelector>;
  protocolVersion?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  totalCoins?: InputMaybe<BitqueryFloatSelector>;
  uniq?: InputMaybe<BitqueryStellarBlockUniq>;
};


/** Block in Stellar blockchain */
export type BitqueryStellarBlockExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Block in Stellar blockchain */
export type BitqueryStellarBlockFeePoolArgs = {
  baseFee?: InputMaybe<BitqueryFloatSelector>;
  baseReserve?: InputMaybe<BitqueryFloatSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feePool?: InputMaybe<BitqueryFloatSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maxTxSetSize?: InputMaybe<BitqueryIntegerSelector>;
  protocolVersion?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  totalCoins?: InputMaybe<BitqueryFloatSelector>;
};


/** Block in Stellar blockchain */
export type BitqueryStellarBlockMaximumArgs = {
  get?: InputMaybe<BitqueryStellarBlockMeasurable>;
  of: BitqueryStellarBlockMeasurable;
};


/** Block in Stellar blockchain */
export type BitqueryStellarBlockMinimumArgs = {
  get?: InputMaybe<BitqueryStellarBlockMeasurable>;
  of: BitqueryStellarBlockMeasurable;
};


/** Block in Stellar blockchain */
export type BitqueryStellarBlockTotalCoinsArgs = {
  baseFee?: InputMaybe<BitqueryFloatSelector>;
  baseReserve?: InputMaybe<BitqueryFloatSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feePool?: InputMaybe<BitqueryFloatSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maxTxSetSize?: InputMaybe<BitqueryIntegerSelector>;
  protocolVersion?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  totalCoins?: InputMaybe<BitqueryFloatSelector>;
};

export type BitqueryStellarBlockFilter = {
  baseFee?: InputMaybe<BitqueryFloatSelector>;
  baseReserve?: InputMaybe<BitqueryFloatSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  feePool?: InputMaybe<BitqueryFloatSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maxTxSetSize?: InputMaybe<BitqueryIntegerSelector>;
  protocolVersion?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  totalCoins?: InputMaybe<BitqueryFloatSelector>;
};

export enum BitqueryStellarBlockMeasurable {
  /** Base fee */
  BaseFee = 'baseFee',
  /** Base reserve */
  BaseReserve = 'baseReserve',
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Fee pool */
  FeePool = 'feePool',
  /** Block hash */
  Hash = 'hash',
  /** Max tx set size */
  MaxTxSetSize = 'maxTxSetSize',
  /** Protocol version */
  ProtocolVersion = 'protocolVersion',
  /** Time */
  Time = 'time',
  /** Total coins */
  TotalCoins = 'totalCoins'
}

export enum BitqueryStellarBlockUniq {
  /** Uniq blocks count */
  Blocks = 'blocks',
  /** Uniq date count */
  Dates = 'dates',
  /** Uniq hashes count */
  Hashes = 'hashes',
  /** Uniq max tx set sizes count */
  MaxTxSetSizes = 'maxTxSetSizes',
  /** Uniq protocol versions */
  ProtocolVersions = 'protocolVersions'
}

/** Claimable balance effect in Stellar blockchain */
export type BitqueryStellarClaimableBalanceEffect = {
  __typename?: 'BitqueryStellarClaimableBalanceEffect';
  amount?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Balance */
  balanceId?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Claimant */
  claimant?: Maybe<BitqueryAddress>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Effect */
  effect?: Maybe<Scalars['String']['output']>;
  /** Effect index */
  effectIndex?: Maybe<Scalars['Int']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Issuer */
  issuer?: Maybe<BitqueryAddress>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<BitqueryOperationIndexedWithAccount>;
  /** Order */
  order?: Maybe<Scalars['Int']['output']>;
  /** Sponsor */
  sponsor?: Maybe<BitqueryAddress>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryStellarTransactionDimension>;
};


/** Claimable balance effect in Stellar blockchain */
export type BitqueryStellarClaimableBalanceEffectAmountArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  balanceId?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  claimant?: InputMaybe<BitqueryAddressSelector>;
  currencyName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  sponsor?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Claimable balance effect in Stellar blockchain */
export type BitqueryStellarClaimableBalanceEffectAnyArgs = {
  of: BitqueryStellarClaimableBalanceEffectMeasurable;
};


/** Claimable balance effect in Stellar blockchain */
export type BitqueryStellarClaimableBalanceEffectCountArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  balanceId?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  claimant?: InputMaybe<BitqueryAddressSelector>;
  currencyName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  sponsor?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarClaimableBalanceEffectUniq>;
};


/** Claimable balance effect in Stellar blockchain */
export type BitqueryStellarClaimableBalanceEffectCountBigIntArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  balanceId?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  claimant?: InputMaybe<BitqueryAddressSelector>;
  currencyName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  sponsor?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarClaimableBalanceEffectUniq>;
};


/** Claimable balance effect in Stellar blockchain */
export type BitqueryStellarClaimableBalanceEffectExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Claimable balance effect in Stellar blockchain */
export type BitqueryStellarClaimableBalanceEffectMaximumArgs = {
  get?: InputMaybe<BitqueryStellarClaimableBalanceEffectMeasurable>;
  of: BitqueryStellarClaimableBalanceEffectMeasurable;
};


/** Claimable balance effect in Stellar blockchain */
export type BitqueryStellarClaimableBalanceEffectMinimumArgs = {
  get?: InputMaybe<BitqueryStellarClaimableBalanceEffectMeasurable>;
  of: BitqueryStellarClaimableBalanceEffectMeasurable;
};

export type BitqueryStellarClaimableBalanceEffectFilter = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  balanceId?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  claimant?: InputMaybe<BitqueryAddressSelector>;
  currencyName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  sponsor?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};

export enum BitqueryStellarClaimableBalanceEffectMeasurable {
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Claimant */
  Claimant = 'claimant',
  /** Currency name */
  CurrencyName = 'currencyName',
  /** Currency symbol */
  CurrencySymbol = 'currencySymbol',
  /** Date */
  Date = 'date',
  /** Effect */
  Effect = 'effect',
  /** Effect index */
  EffectIndex = 'effectIndex',
  /** Issuer */
  Issuer = 'issuer',
  /** Operation index */
  OpIndex = 'opIndex',
  /** Operation source account */
  OpSourceAccount = 'opSourceAccount',
  /** Operation */
  Operation = 'operation',
  /** Order */
  Order = 'order',
  /** Sponsor */
  Sponsor = 'sponsor',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TransactionHash = 'transactionHash',
  /** Transaction index */
  TransactionIndex = 'transactionIndex',
  /** Transaction sender */
  TransactionSender = 'transactionSender'
}

export enum BitqueryStellarClaimableBalanceEffectUniq {
  /** Uniq blocks count */
  Blocks = 'blocks',
  /** Uniq claimants count */
  Claimants = 'claimants',
  /** Uniq currencies name count */
  CurrenciesName = 'currenciesName',
  /** Uniq currencies symbol count */
  CurrenciesSymbol = 'currenciesSymbol',
  /** Uniq dates count */
  Dates = 'dates',
  /** Uniq effect indices count */
  EffectIndices = 'effectIndices',
  /** Uniq effects count */
  Effects = 'effects',
  /** Uniq issuers count */
  Issuers = 'issuers',
  /** Uniq operaion indices count */
  OpIndices = 'opIndices',
  /** Uniq operation source accounts count */
  OpSourceAccounts = 'opSourceAccounts',
  /** Uniq operations count */
  Operations = 'operations',
  /** Uniq orders count */
  Orders = 'orders',
  /** Uniq sponsors count */
  Sponsors = 'sponsors',
  /** Uniq times count */
  Times = 'times',
  /** Uniq transaction hashes count */
  TransactionHashes = 'transactionHashes',
  /** Uniq transaction indices count */
  TransactionIndices = 'transactionIndices',
  /** Uniq transaction senders count */
  TransactionSenders = 'transactionSenders'
}

/** Stellar Coinpath */
export type BitqueryStellarCoinpath = {
  __typename?: 'BitqueryStellarCoinpath';
  /** Summary of transfered value from */
  amountFrom?: Maybe<Scalars['Float']['output']>;
  /** Summary of transfered value to */
  amountTo?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency From of transfer */
  currencyFrom?: Maybe<BitqueryCurrency>;
  /** Currency To of transfer */
  currencyTo?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryStellarCoinpathAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryStellarCoinpathAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<BitqueryStellarTransactionCoinpathDimension>;
};


/** Stellar Coinpath */
export type BitqueryStellarCoinpathAmountFromArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Stellar Coinpath */
export type BitqueryStellarCoinpathAmountToArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Stellar Coinpath */
export type BitqueryStellarCoinpathAnyArgs = {
  of: BitqueryStellarCoinpathMeasureable;
};


/** Stellar Coinpath */
export type BitqueryStellarCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryStellarCoinpathMeasureable>;
  of: BitqueryStellarCoinpathMeasureable;
};


/** Stellar Coinpath */
export type BitqueryStellarCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryStellarCoinpathMeasureable>;
  of: BitqueryStellarCoinpathMeasureable;
};

/** Address detailed information for Stellar network */
export type BitqueryStellarCoinpathAddress = {
  __typename?: 'BitqueryStellarCoinpathAddress';
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** First Tx At */
  firstTransferAt?: Maybe<BitqueryDateTime>;
  /** Last Tx At */
  lastTransferAt?: Maybe<BitqueryDateTime>;
  receiversCount?: Maybe<Scalars['Int']['output']>;
  sendersCount?: Maybe<Scalars['Int']['output']>;
};

export enum BitqueryStellarCoinpathMeasureable {
  /** Block */
  Block = 'block',
  /** Depth */
  Depth = 'depth',
  /** Receiver */
  Receiver = 'receiver',
  /** Sender */
  Sender = 'sender',
  /** Time */
  Time = 'time',
  /** Version */
  TxHash = 'tx_hash'
}

/** Effect in Stellar blockchain */
export type BitqueryStellarEffect = {
  __typename?: 'BitqueryStellarEffect';
  /** Address */
  address?: Maybe<BitqueryAddress>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Details */
  details?: Maybe<Scalars['String']['output']>;
  /** Effect */
  effect?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Effect index */
  index?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<BitqueryOperationIndexedWithAccount>;
  /** Order */
  order?: Maybe<Scalars['Int']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryStellarTransactionDimension>;
};


/** Effect in Stellar blockchain */
export type BitqueryStellarEffectAnyArgs = {
  of: BitqueryStellarEffectMeasurable;
};


/** Effect in Stellar blockchain */
export type BitqueryStellarEffectCountArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  details?: InputMaybe<BitqueryStringSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarEffectUniq>;
};


/** Effect in Stellar blockchain */
export type BitqueryStellarEffectCountBigIntArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  details?: InputMaybe<BitqueryStringSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarEffectUniq>;
};


/** Effect in Stellar blockchain */
export type BitqueryStellarEffectExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Effect in Stellar blockchain */
export type BitqueryStellarEffectMaximumArgs = {
  get?: InputMaybe<BitqueryStellarEffectMeasurable>;
  of: BitqueryStellarEffectMeasurable;
};


/** Effect in Stellar blockchain */
export type BitqueryStellarEffectMinimumArgs = {
  get?: InputMaybe<BitqueryStellarEffectMeasurable>;
  of: BitqueryStellarEffectMeasurable;
};

/** Effect argument in Stellar blockchain */
export type BitqueryStellarEffectArgument = {
  __typename?: 'BitqueryStellarEffectArgument';
  /** Address */
  address?: Maybe<BitqueryAddress>;
  any?: Maybe<Scalars['String']['output']>;
  /** Argname */
  argname?: Maybe<Scalars['String']['output']>;
  /** Argvalue */
  argvalue?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Effect */
  effect?: Maybe<Scalars['String']['output']>;
  /** Effect index */
  effectIndex?: Maybe<Scalars['Int']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<BitqueryOperationIndexedWithAccount>;
  /** Order */
  order?: Maybe<Scalars['Int']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryStellarTransactionDimension>;
};


/** Effect argument in Stellar blockchain */
export type BitqueryStellarEffectArgumentAnyArgs = {
  of: BitqueryStellarEffectArgumentMeasurable;
};


/** Effect argument in Stellar blockchain */
export type BitqueryStellarEffectArgumentCountArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  argname?: InputMaybe<BitqueryStringSelector>;
  argvalue?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarEffectArgumentUniq>;
};


/** Effect argument in Stellar blockchain */
export type BitqueryStellarEffectArgumentCountBigIntArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  argname?: InputMaybe<BitqueryStringSelector>;
  argvalue?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarEffectArgumentUniq>;
};


/** Effect argument in Stellar blockchain */
export type BitqueryStellarEffectArgumentExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Effect argument in Stellar blockchain */
export type BitqueryStellarEffectArgumentMaximumArgs = {
  get?: InputMaybe<BitqueryStellarEffectArgumentMeasurable>;
  of: BitqueryStellarEffectArgumentMeasurable;
};


/** Effect argument in Stellar blockchain */
export type BitqueryStellarEffectArgumentMinimumArgs = {
  get?: InputMaybe<BitqueryStellarEffectArgumentMeasurable>;
  of: BitqueryStellarEffectArgumentMeasurable;
};

export type BitqueryStellarEffectArgumentFilter = {
  address?: InputMaybe<BitqueryAddressSelector>;
  argname?: InputMaybe<BitqueryStringSelector>;
  argvalue?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};

export enum BitqueryStellarEffectArgumentMeasurable {
  /** Address */
  Address = 'address',
  /** Argname */
  Argname = 'argname',
  /** Argvalue */
  Argvalue = 'argvalue',
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Effect */
  Effect = 'effect',
  /** Effect index */
  EffectIndex = 'effectIndex',
  /** Operation index */
  OpIndex = 'opIndex',
  /** Operation source account */
  OpSourceAccount = 'opSourceAccount',
  /** Operation */
  Operation = 'operation',
  /** Order */
  Order = 'order',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TransactionHash = 'transactionHash',
  /** Transaction index */
  TransactionIndex = 'transactionIndex',
  /** Transaction sender */
  TransactionSender = 'transactionSender'
}

export enum BitqueryStellarEffectArgumentUniq {
  /** Uniq addresses count */
  Addresses = 'addresses',
  /** Uniq argnames count */
  Argnames = 'argnames',
  /** Uniq argvalues count */
  Argvalues = 'argvalues',
  /** Uniq blocks count */
  Blocks = 'blocks',
  /** Uniq dates count */
  Dates = 'dates',
  /** Uniq effect indices count */
  EffectIndices = 'effectIndices',
  /** Uniq effects count */
  Effects = 'effects',
  /** Uniq operation indices count */
  OpIndices = 'opIndices',
  /** Uniq operation source accounts count */
  OpSourceAccounts = 'opSourceAccounts',
  /** Uniq operations count */
  Operations = 'operations',
  /** Uniq orders count */
  Orders = 'orders',
  /** Uniq times count */
  Times = 'times',
  /** Uniq transaction hashes count */
  TransactionHashes = 'transactionHashes',
  /** Uniq transaction indices count */
  TransactionIndices = 'transactionIndices',
  /** Uniq transaction senders count */
  TransactionSenders = 'transactionSenders'
}

export type BitqueryStellarEffectFilter = {
  address?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  details?: InputMaybe<BitqueryStringSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};

export enum BitqueryStellarEffectMeasurable {
  /** Address */
  Address = 'address',
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Details */
  Details = 'details',
  /** Effect */
  Effect = 'effect',
  /** Effect index */
  EffectIndex = 'effectIndex',
  /** Operation index */
  OpIndex = 'opIndex',
  /** Operation source account */
  OpSourceAccount = 'opSourceAccount',
  /** Operation */
  Operation = 'operation',
  /** Order */
  Order = 'order',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TransactionHash = 'transactionHash',
  /** Transaction index */
  TransactionIndex = 'transactionIndex',
  /** Transaction sender */
  TransactionSender = 'transactionSender'
}

export enum BitqueryStellarEffectUniq {
  /** Uniq addresses count */
  Addresses = 'addresses',
  /** Uniq blocks count */
  Blocks = 'blocks',
  /** Uniq dates count */
  Dates = 'dates',
  /** Uniq details count */
  Details = 'details',
  /** Uniq effect indices count */
  EffectIndices = 'effectIndices',
  /** Uniq effects count */
  Effects = 'effects',
  /** Uniq operation indices count */
  OpIndices = 'opIndices',
  /** Uniq operation source accounts count */
  OpSourceAccounts = 'opSourceAccounts',
  /** Uniq operations count */
  Operations = 'operations',
  /** Uniq orders count */
  Orders = 'orders',
  /** Uniq times count */
  Times = 'times',
  /** Uniq transaction hashes count */
  TransactionHashes = 'transactionHashes',
  /** Uniq transaction indices count */
  TransactionIndices = 'transactionIndices',
  /** Uniq transaction senders count */
  TransactionSenders = 'transactionSenders'
}

/** Liquidity pool effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolEffect = {
  __typename?: 'BitqueryStellarLiquidityPoolEffect';
  amount?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Effect */
  effect?: Maybe<Scalars['String']['output']>;
  /** Effect index */
  effectIndex?: Maybe<Scalars['Int']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Issuer */
  issuer?: Maybe<BitqueryAddress>;
  /** Liquidity pool details */
  liquidityPoolDetails?: Maybe<Scalars['String']['output']>;
  /** Liquidity pool id bin */
  liquidityPoolId?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<BitqueryOperationIndexedWithAccount>;
  /** Order */
  order?: Maybe<Scalars['Int']['output']>;
  shares?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryStellarTransactionDimension>;
};


/** Liquidity pool effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolEffectAmountArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currencyName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  liquidityPoolDetails?: InputMaybe<BitqueryStringSelector>;
  liquidityPoolId?: InputMaybe<BitqueryStringSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  shares?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Liquidity pool effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolEffectAnyArgs = {
  of: BitqueryStellarLiquidityPoolEffectMeasurable;
};


/** Liquidity pool effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolEffectCountArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  currencyName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  liquidityPoolDetails?: InputMaybe<BitqueryStringSelector>;
  liquidityPoolId?: InputMaybe<BitqueryStringSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  shares?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarLiquidityPoolEffectUniq>;
};


/** Liquidity pool effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolEffectCountBigIntArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  currencyName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  liquidityPoolDetails?: InputMaybe<BitqueryStringSelector>;
  liquidityPoolId?: InputMaybe<BitqueryStringSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  shares?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarLiquidityPoolEffectUniq>;
};


/** Liquidity pool effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolEffectExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Liquidity pool effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolEffectMaximumArgs = {
  get?: InputMaybe<BitqueryStellarLiquidityPoolEffectMeasurable>;
  of: BitqueryStellarLiquidityPoolEffectMeasurable;
};


/** Liquidity pool effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolEffectMinimumArgs = {
  get?: InputMaybe<BitqueryStellarLiquidityPoolEffectMeasurable>;
  of: BitqueryStellarLiquidityPoolEffectMeasurable;
};


/** Liquidity pool effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolEffectSharesArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currencyName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  liquidityPoolDetails?: InputMaybe<BitqueryStringSelector>;
  liquidityPoolId?: InputMaybe<BitqueryStringSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  shares?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};

export type BitqueryStellarLiquidityPoolEffectFilter = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  currencyName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  liquidityPoolDetails?: InputMaybe<BitqueryStringSelector>;
  liquidityPoolId?: InputMaybe<BitqueryStringSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  shares?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};

export enum BitqueryStellarLiquidityPoolEffectMeasurable {
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Currency name */
  CurrencyName = 'currencyName',
  /** Currency symbol */
  CurrencySymbol = 'currencySymbol',
  /** Date */
  Date = 'date',
  /** Effect */
  Effect = 'effect',
  /** Effect index */
  EffectIndex = 'effectIndex',
  /** Issuer */
  Issuer = 'issuer',
  /** Liquidity pool details */
  LiquidityPoolDetails = 'liquidityPoolDetails',
  /** Liquidity pool id */
  LiquidityPoolId = 'liquidityPoolId',
  /** Operation index */
  OpIndex = 'opIndex',
  /** Operation source account */
  OpSourceAccount = 'opSourceAccount',
  /** Operation */
  Operation = 'operation',
  /** Order */
  Order = 'order',
  /** Shares */
  Shares = 'shares',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TransactionHash = 'transactionHash',
  /** Transaction index */
  TransactionIndex = 'transactionIndex',
  /** Transaction sender */
  TransactionSender = 'transactionSender'
}

export enum BitqueryStellarLiquidityPoolEffectUniq {
  /** Uniq blocks count */
  Blocks = 'blocks',
  /** Uniq currencies name count */
  CurrenciesName = 'currenciesName',
  /** Uniq currencies symbol count */
  CurrenciesSymbol = 'currenciesSymbol',
  /** Uniq dates count */
  Dates = 'dates',
  /** Uniq effect indices count */
  EffectIndices = 'effectIndices',
  /** Uniq effects count */
  Effects = 'effects',
  /** Uniq issuers count */
  Issuers = 'issuers',
  /** Uniq liquidity pool details count */
  LiquidityPoolDetails = 'liquidityPoolDetails',
  /** Uniq liquidity pool ids count */
  LiquidityPoolIds = 'liquidityPoolIds',
  /** Uniq operation indices count */
  OpIndices = 'opIndices',
  /** Uniq operation source accounts count */
  OpSourceAccounts = 'opSourceAccounts',
  /** Uniq operations count */
  Operations = 'operations',
  /** Uniq orders count */
  Orders = 'orders',
  /** Uniq times count */
  Times = 'times',
  /** Uniq transaction hashes count */
  TransactionHashes = 'transactionHashes',
  /** Uniq transaction indices count */
  TransactionIndices = 'transactionIndices',
  /** Uniq transaction senders count */
  TransactionSenders = 'transactionSenders'
}

/** Liquidity pool trade effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolTradeEffect = {
  __typename?: 'BitqueryStellarLiquidityPoolTradeEffect';
  /** Address */
  address?: Maybe<BitqueryAddress>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  buyAmount?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  /** Buy currency */
  buyCurrency?: Maybe<BitqueryCurrency>;
  /** Buy issuer */
  buyIssuer?: Maybe<BitqueryAddress>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Effect index */
  effectIndex?: Maybe<Scalars['Int']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Liquidity pool details */
  liquidityPoolDetails?: Maybe<Scalars['String']['output']>;
  /** Liquidity pool */
  liquidityPoolId?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<BitqueryOperationIndexedWithAccount>;
  /** Order */
  order?: Maybe<Scalars['Int']['output']>;
  sellAmount?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  /** Sell currency */
  sellCurrency?: Maybe<BitqueryCurrency>;
  /** Sell issuer */
  sellIssuer?: Maybe<BitqueryAddress>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryStellarTransactionDimension>;
};


/** Liquidity pool trade effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolTradeEffectAnyArgs = {
  of: BitqueryStellarLiquidityPoolTradeEffectMeasurable;
};


/** Liquidity pool trade effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolTradeEffectBuyAmountArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  buyAmount?: InputMaybe<BitqueryFloatSelector>;
  buyCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  buyIssuer?: InputMaybe<BitqueryAddressSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  liquidityPoolDetails?: InputMaybe<BitqueryStringSelector>;
  liquidityPoolId?: InputMaybe<BitqueryStringSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  sellAmount?: InputMaybe<BitqueryFloatSelector>;
  sellCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  sellIssuer?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Liquidity pool trade effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolTradeEffectCountArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  buyAmount?: InputMaybe<BitqueryFloatSelector>;
  buyCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  buyIssuer?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  liquidityPoolDetails?: InputMaybe<BitqueryStringSelector>;
  liquidityPoolId?: InputMaybe<BitqueryStringSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  sellAmount?: InputMaybe<BitqueryFloatSelector>;
  sellCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  sellIssuer?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarLiquidityPoolTradeEffectUniq>;
};


/** Liquidity pool trade effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolTradeEffectCountBigIntArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  buyAmount?: InputMaybe<BitqueryFloatSelector>;
  buyCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  buyIssuer?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  liquidityPoolDetails?: InputMaybe<BitqueryStringSelector>;
  liquidityPoolId?: InputMaybe<BitqueryStringSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  sellAmount?: InputMaybe<BitqueryFloatSelector>;
  sellCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  sellIssuer?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarLiquidityPoolTradeEffectUniq>;
};


/** Liquidity pool trade effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolTradeEffectExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Liquidity pool trade effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolTradeEffectMaximumArgs = {
  get?: InputMaybe<BitqueryStellarLiquidityPoolTradeEffectMeasurable>;
  of: BitqueryStellarLiquidityPoolTradeEffectMeasurable;
};


/** Liquidity pool trade effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolTradeEffectMinimumArgs = {
  get?: InputMaybe<BitqueryStellarLiquidityPoolTradeEffectMeasurable>;
  of: BitqueryStellarLiquidityPoolTradeEffectMeasurable;
};


/** Liquidity pool trade effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolTradeEffectSellAmountArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  buyAmount?: InputMaybe<BitqueryFloatSelector>;
  buyCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  buyIssuer?: InputMaybe<BitqueryAddressSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  liquidityPoolDetails?: InputMaybe<BitqueryStringSelector>;
  liquidityPoolId?: InputMaybe<BitqueryStringSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  sellAmount?: InputMaybe<BitqueryFloatSelector>;
  sellCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  sellIssuer?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};

export type BitqueryStellarLiquidityPoolTradeEffectFilter = {
  address?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  buyAmount?: InputMaybe<BitqueryFloatSelector>;
  buyCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  buyIssuer?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  liquidityPoolDetails?: InputMaybe<BitqueryStringSelector>;
  liquidityPoolId?: InputMaybe<BitqueryStringSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  sellAmount?: InputMaybe<BitqueryFloatSelector>;
  sellCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  sellIssuer?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};

export enum BitqueryStellarLiquidityPoolTradeEffectMeasurable {
  /** Address */
  Address = 'address',
  /** Block */
  Block = 'block',
  /** Buy amount */
  BuyAmount = 'buyAmount',
  /** Buy currency name */
  BuyCurrencyName = 'buyCurrencyName',
  /** Buy currency symbol */
  BuyCurrencySymbol = 'buyCurrencySymbol',
  /** Buy issuer */
  BuyIssuer = 'buyIssuer',
  /** Date */
  Date = 'date',
  /** Effect index */
  EffectIndex = 'effectIndex',
  /** Liquidity pool details */
  LiquidityPoolDetails = 'liquidityPoolDetails',
  /** Liquidity pool */
  LiquidityPoolId = 'liquidityPoolId',
  /** Operation index */
  OpIndex = 'opIndex',
  /** Opertation source account */
  OpSourceAccount = 'opSourceAccount',
  /** Operation */
  Operation = 'operation',
  /** Order */
  Order = 'order',
  /** Sell amount */
  SellAmount = 'sellAmount',
  /** Sell currency name */
  SellCurrencyName = 'sellCurrencyName',
  /** Sell currency symbol */
  SellCurrencySymbol = 'sellCurrencySymbol',
  /** Sell issuer */
  SellIssuer = 'sellIssuer',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TransactionHash = 'transactionHash',
  /** Transaction index */
  TransactionIndex = 'transactionIndex',
  /** Transaction sender */
  TransactionSender = 'transactionSender'
}

export enum BitqueryStellarLiquidityPoolTradeEffectUniq {
  /** Uniq addresses count */
  Addresses = 'addresses',
  /** Uniq blocks count */
  Blocks = 'blocks',
  /** Uniq buy currency names count */
  BuyCurrencyNames = 'buyCurrencyNames',
  /** Uniq buy currency symbols count */
  BuyCurrencySymbols = 'buyCurrencySymbols',
  /** Uniq buy issuers count */
  BuyIssuers = 'buyIssuers',
  /** Uniq dates count */
  Dates = 'dates',
  /** Uniq effect indices count */
  EffectIndices = 'effectIndices',
  /** Uniq liquidity pool details count */
  LiquidityPoolDetails = 'liquidityPoolDetails',
  /** Uniq liquidity pool ids count */
  LiquidityPoolIds = 'liquidityPoolIds',
  /** Uniq operation indices count */
  OpIndices = 'opIndices',
  /** Uniq operation source accounts count */
  OpSourceAccounts = 'opSourceAccounts',
  /** Uniq operations count */
  Operations = 'operations',
  /** Uniq orders count */
  Orders = 'orders',
  /** Uniq sell currency names count */
  SellCurrencyNames = 'sellCurrencyNames',
  /** Uniq sell currency symbols count */
  SellCurrencySymbols = 'sellCurrencySymbols',
  /** Uniq sell issuers count */
  SellIssuers = 'sellIssuers',
  /** Uniq times count */
  Times = 'times',
  /** Uniq transaction hashes count */
  TransactionHashes = 'transactionHashes',
  /** Uniq transaction indices count */
  TransactionIndices = 'transactionIndices',
  /** Uniq transaction senders count */
  TransactionSenders = 'transactionSenders'
}

export enum BitqueryStellarNetwork {
  /** The Stellar Ledger */
  Stellar = 'stellar'
}

/** Operation in Stellar blockchain */
export type BitqueryStellarOperation = {
  __typename?: 'BitqueryStellarOperation';
  any?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Details */
  details?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Operation index */
  index?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<Scalars['String']['output']>;
  /** Operation source account */
  sourceAccount?: Maybe<BitqueryAddress>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryStellarTransactionDimension>;
};


/** Operation in Stellar blockchain */
export type BitqueryStellarOperationAnyArgs = {
  of: BitqueryStellarOperationMeasurable;
};


/** Operation in Stellar blockchain */
export type BitqueryStellarOperationCountArgs = {
  block?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  details?: InputMaybe<BitqueryStringSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  sourceAccount?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarOperationUniq>;
};


/** Operation in Stellar blockchain */
export type BitqueryStellarOperationCountBigIntArgs = {
  block?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  details?: InputMaybe<BitqueryStringSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  sourceAccount?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarOperationUniq>;
};


/** Operation in Stellar blockchain */
export type BitqueryStellarOperationExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Operation in Stellar blockchain */
export type BitqueryStellarOperationMaximumArgs = {
  get?: InputMaybe<BitqueryStellarOperationMeasurable>;
  of: BitqueryStellarOperationMeasurable;
};


/** Operation in Stellar blockchain */
export type BitqueryStellarOperationMinimumArgs = {
  get?: InputMaybe<BitqueryStellarOperationMeasurable>;
  of: BitqueryStellarOperationMeasurable;
};

export type BitqueryStellarOperationFilter = {
  block?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  details?: InputMaybe<BitqueryStringSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  sourceAccount?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};

export enum BitqueryStellarOperationMeasurable {
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Details */
  Details = 'details',
  /** Operation index */
  Index = 'index',
  /** Operation */
  Operation = 'operation',
  /** Operation source account */
  SourceAccount = 'sourceAccount',
  /** Success */
  Success = 'success',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TransactionHash = 'transactionHash',
  /** Transaction index */
  TransactionIndex = 'transactionIndex',
  /** Transaction sender */
  TransactionSender = 'transactionSender'
}

export enum BitqueryStellarOperationUniq {
  /** Uniq blocks count */
  Blocks = 'blocks',
  /** Uniq dates count */
  Dates = 'dates',
  /** Uniq details count */
  Details = 'details',
  /** Uniq operations count */
  Operations = 'operations',
  /** Uniq op source accounts count */
  SourceAccounts = 'sourceAccounts',
  /** Uniq times count */
  Times = 'times',
  /** Uniq transaction hashes count */
  TransactionHashes = 'transactionHashes',
  /** Uniq transaction indices count */
  TransactionIndices = 'transactionIndices',
  /** Uniq transaction senders count */
  TransactionSenders = 'transactionSenders'
}

/** Payment in Stellar blockchain */
export type BitqueryStellarPayment = {
  __typename?: 'BitqueryStellarPayment';
  amountFrom?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  amountTo?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** The sequence number of the ledger */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  creditedToValue?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  /** Sender's currency */
  currencyFrom?: Maybe<BitqueryCurrency>;
  /** Receiver's currency */
  currencyTo?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  debitedFromValue?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Source issuer */
  issuerFrom?: Maybe<BitqueryAddress>;
  /** Issuer */
  issuerTo?: Maybe<BitqueryAddress>;
  maxValueFrom?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minValueTo?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<BitqueryOperationIndexedWithAccount>;
  /** Path */
  path?: Maybe<Scalars['String']['output']>;
  /** Payment receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Payment sender */
  sender?: Maybe<BitqueryAddress>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryStellarTransactionDimension>;
};


/** Payment in Stellar blockchain */
export type BitqueryStellarPaymentAmountFromArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  creditedToValue?: InputMaybe<BitqueryFloatSelector>;
  currencyFromName?: InputMaybe<BitqueryCurrencySelector>;
  currencyToName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  debitedFromValue?: InputMaybe<BitqueryFloatSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  issuerFrom?: InputMaybe<BitqueryAddressSelector>;
  issuerTo?: InputMaybe<BitqueryAddressSelector>;
  maxValueFrom?: InputMaybe<BitqueryFloatSelector>;
  minValueTo?: InputMaybe<BitqueryFloatSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  path?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Payment in Stellar blockchain */
export type BitqueryStellarPaymentAmountToArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  creditedToValue?: InputMaybe<BitqueryFloatSelector>;
  currencyFromName?: InputMaybe<BitqueryCurrencySelector>;
  currencyToName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  debitedFromValue?: InputMaybe<BitqueryFloatSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  issuerFrom?: InputMaybe<BitqueryAddressSelector>;
  issuerTo?: InputMaybe<BitqueryAddressSelector>;
  maxValueFrom?: InputMaybe<BitqueryFloatSelector>;
  minValueTo?: InputMaybe<BitqueryFloatSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  path?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Payment in Stellar blockchain */
export type BitqueryStellarPaymentAnyArgs = {
  of: BitqueryStellarPaymentMeasurable;
};


/** Payment in Stellar blockchain */
export type BitqueryStellarPaymentCountArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  creditedToValue?: InputMaybe<BitqueryFloatSelector>;
  currencyFromName?: InputMaybe<BitqueryCurrencySelector>;
  currencyToName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  debitedFromValue?: InputMaybe<BitqueryFloatSelector>;
  issuerFrom?: InputMaybe<BitqueryAddressSelector>;
  issuerTo?: InputMaybe<BitqueryAddressSelector>;
  maxValueFrom?: InputMaybe<BitqueryFloatSelector>;
  minValueTo?: InputMaybe<BitqueryFloatSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  path?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarPaymentUniq>;
};


/** Payment in Stellar blockchain */
export type BitqueryStellarPaymentCountBigIntArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  creditedToValue?: InputMaybe<BitqueryFloatSelector>;
  currencyFromName?: InputMaybe<BitqueryCurrencySelector>;
  currencyToName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  debitedFromValue?: InputMaybe<BitqueryFloatSelector>;
  issuerFrom?: InputMaybe<BitqueryAddressSelector>;
  issuerTo?: InputMaybe<BitqueryAddressSelector>;
  maxValueFrom?: InputMaybe<BitqueryFloatSelector>;
  minValueTo?: InputMaybe<BitqueryFloatSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  path?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarPaymentUniq>;
};


/** Payment in Stellar blockchain */
export type BitqueryStellarPaymentCreditedToValueArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  creditedToValue?: InputMaybe<BitqueryFloatSelector>;
  currencyFromName?: InputMaybe<BitqueryCurrencySelector>;
  currencyToName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  debitedFromValue?: InputMaybe<BitqueryFloatSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  issuerFrom?: InputMaybe<BitqueryAddressSelector>;
  issuerTo?: InputMaybe<BitqueryAddressSelector>;
  maxValueFrom?: InputMaybe<BitqueryFloatSelector>;
  minValueTo?: InputMaybe<BitqueryFloatSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  path?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Payment in Stellar blockchain */
export type BitqueryStellarPaymentDebitedFromValueArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  creditedToValue?: InputMaybe<BitqueryFloatSelector>;
  currencyFromName?: InputMaybe<BitqueryCurrencySelector>;
  currencyToName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  debitedFromValue?: InputMaybe<BitqueryFloatSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  issuerFrom?: InputMaybe<BitqueryAddressSelector>;
  issuerTo?: InputMaybe<BitqueryAddressSelector>;
  maxValueFrom?: InputMaybe<BitqueryFloatSelector>;
  minValueTo?: InputMaybe<BitqueryFloatSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  path?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Payment in Stellar blockchain */
export type BitqueryStellarPaymentExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Payment in Stellar blockchain */
export type BitqueryStellarPaymentMaxValueFromArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  creditedToValue?: InputMaybe<BitqueryFloatSelector>;
  currencyFromName?: InputMaybe<BitqueryCurrencySelector>;
  currencyToName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  debitedFromValue?: InputMaybe<BitqueryFloatSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  issuerFrom?: InputMaybe<BitqueryAddressSelector>;
  issuerTo?: InputMaybe<BitqueryAddressSelector>;
  maxValueFrom?: InputMaybe<BitqueryFloatSelector>;
  minValueTo?: InputMaybe<BitqueryFloatSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  path?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Payment in Stellar blockchain */
export type BitqueryStellarPaymentMaximumArgs = {
  get?: InputMaybe<BitqueryStellarPaymentMeasurable>;
  of: BitqueryStellarPaymentMeasurable;
};


/** Payment in Stellar blockchain */
export type BitqueryStellarPaymentMinValueToArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  creditedToValue?: InputMaybe<BitqueryFloatSelector>;
  currencyFromName?: InputMaybe<BitqueryCurrencySelector>;
  currencyToName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  debitedFromValue?: InputMaybe<BitqueryFloatSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  issuerFrom?: InputMaybe<BitqueryAddressSelector>;
  issuerTo?: InputMaybe<BitqueryAddressSelector>;
  maxValueFrom?: InputMaybe<BitqueryFloatSelector>;
  minValueTo?: InputMaybe<BitqueryFloatSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  path?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Payment in Stellar blockchain */
export type BitqueryStellarPaymentMinimumArgs = {
  get?: InputMaybe<BitqueryStellarPaymentMeasurable>;
  of: BitqueryStellarPaymentMeasurable;
};

export type BitqueryStellarPaymentFilter = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  creditedToValue?: InputMaybe<BitqueryFloatSelector>;
  currencyFromName?: InputMaybe<BitqueryCurrencySelector>;
  currencyToName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  debitedFromValue?: InputMaybe<BitqueryFloatSelector>;
  issuerFrom?: InputMaybe<BitqueryAddressSelector>;
  issuerTo?: InputMaybe<BitqueryAddressSelector>;
  maxValueFrom?: InputMaybe<BitqueryFloatSelector>;
  minValueTo?: InputMaybe<BitqueryFloatSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  path?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};

export enum BitqueryStellarPaymentMeasurable {
  /** Amount from */
  AmountFrom = 'amountFrom',
  /** Amount to */
  AmountTo = 'amountTo',
  /** Block */
  Block = 'block',
  /** Credited to value */
  CreditedToValue = 'creditedToValue',
  /** Currency from name */
  CurrencyFromName = 'currencyFromName',
  /** Currency from symbol */
  CurrencyFromSymbol = 'currencyFromSymbol',
  /** Currency to name */
  CurrencyToName = 'currencyToName',
  /** Currency to symbol */
  CurrencyToSymbol = 'currencyToSymbol',
  /** Date */
  Date = 'date',
  /** Debited from value */
  DebitedFromValue = 'debitedFromValue',
  /** Issuer from */
  IssuerFrom = 'issuerFrom',
  /** Issuer to */
  IssuerTo = 'issuerTo',
  /** Max value from */
  MaxValueFrom = 'maxValueFrom',
  /** Min value to */
  MinValueTo = 'minValueTo',
  /** Op index */
  OpIndex = 'opIndex',
  /** Operation source account */
  OpSourceAccount = 'opSourceAccount',
  /** Operation */
  Operation = 'operation',
  /** Path */
  Path = 'path',
  /** Receiver */
  Receiver = 'receiver',
  /** Sender */
  Sender = 'sender',
  /** Success */
  Success = 'success',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TransactionHash = 'transactionHash',
  /** Transaction index */
  TransactionIndex = 'transactionIndex',
  /** Transaction sender */
  TransactionSender = 'transactionSender'
}

export enum BitqueryStellarPaymentUniq {
  /** Uniq blocks count */
  Blocks = 'blocks',
  /** Uniq currencies from name count */
  CurrenciesFromName = 'currenciesFromName',
  /** Uniq currencies from symbol count */
  CurrenciesFromSymbol = 'currenciesFromSymbol',
  /** Uniq currencies to name count */
  CurrenciesToName = 'currenciesToName',
  /** Uniq currencies to symbol count */
  CurrenciesToSymbol = 'currenciesToSymbol',
  /** Uniq dates count */
  Dates = 'dates',
  /** Uniq issuers from count */
  IssuersFrom = 'issuersFrom',
  /** Uniq issuers to count */
  IssuersTo = 'issuersTo',
  /** Uniq operation source accounts count */
  OpSourceAccounts = 'opSourceAccounts',
  /** Uniq operations count */
  Operations = 'operations',
  /** Uniq paths count */
  Paths = 'paths',
  /** Uniq receivers count */
  Receivers = 'receivers',
  /** Uniq senders count */
  Senders = 'senders',
  /** Uniq times count */
  Times = 'times',
  /** Uniq transaction hashes count */
  TransactionHashes = 'transactionHashes',
  /** Uniq transaction indices count */
  TransactionIndices = 'transactionIndices',
  /** Uniq transaction senders count */
  TransactionSenders = 'transactionSenders'
}

/** Token Balance */
export type BitqueryStellarTokenBalances = {
  __typename?: 'BitqueryStellarTokenBalances';
  /** Asset code */
  assetCode?: Maybe<Scalars['String']['output']>;
  /** Asset issuer */
  assetIssuer?: Maybe<Scalars['String']['output']>;
  /** Asset type */
  assetType?: Maybe<Scalars['String']['output']>;
  /** Balance */
  balance?: Maybe<Scalars['Float']['output']>;
};

/** Trade effect in Stellar blockchain */
export type BitqueryStellarTradeEffect = {
  __typename?: 'BitqueryStellarTradeEffect';
  /** Address */
  address?: Maybe<BitqueryAddress>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  buyAmount?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  /** Buy currency */
  buyCurrency?: Maybe<BitqueryCurrency>;
  /** Buy issuer */
  buyIssuer?: Maybe<BitqueryAddress>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Effect index */
  effectIndex?: Maybe<Scalars['Int']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Offer */
  offerId?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Operation */
  operation?: Maybe<BitqueryOperationIndexedWithAccount>;
  /** Order */
  order?: Maybe<Scalars['Int']['output']>;
  sellAmount?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  /** Sell currency */
  sellCurrency?: Maybe<BitqueryCurrency>;
  /** Sell issuer */
  sellIssuer?: Maybe<BitqueryAddress>;
  /** Seller */
  seller?: Maybe<BitqueryAddress>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryStellarTransactionDimension>;
};


/** Trade effect in Stellar blockchain */
export type BitqueryStellarTradeEffectAnyArgs = {
  of: BitqueryStellarTradeEffectMeasurable;
};


/** Trade effect in Stellar blockchain */
export type BitqueryStellarTradeEffectBuyAmountArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  buyAmount?: InputMaybe<BitqueryFloatSelector>;
  buyCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  buyIssuer?: InputMaybe<BitqueryAddressSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  offerId?: InputMaybe<BitqueryIntegerSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  sellAmount?: InputMaybe<BitqueryFloatSelector>;
  sellCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  sellIssuer?: InputMaybe<BitqueryAddressSelector>;
  seller?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Trade effect in Stellar blockchain */
export type BitqueryStellarTradeEffectCountArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  buyAmount?: InputMaybe<BitqueryFloatSelector>;
  buyCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  buyIssuer?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  offerId?: InputMaybe<BitqueryIntegerSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  sellAmount?: InputMaybe<BitqueryFloatSelector>;
  sellCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  sellIssuer?: InputMaybe<BitqueryAddressSelector>;
  seller?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarTradeEffectUniq>;
};


/** Trade effect in Stellar blockchain */
export type BitqueryStellarTradeEffectCountBigIntArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  buyAmount?: InputMaybe<BitqueryFloatSelector>;
  buyCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  buyIssuer?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  offerId?: InputMaybe<BitqueryIntegerSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  sellAmount?: InputMaybe<BitqueryFloatSelector>;
  sellCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  sellIssuer?: InputMaybe<BitqueryAddressSelector>;
  seller?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarTradeEffectUniq>;
};


/** Trade effect in Stellar blockchain */
export type BitqueryStellarTradeEffectExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Trade effect in Stellar blockchain */
export type BitqueryStellarTradeEffectMaximumArgs = {
  get?: InputMaybe<BitqueryStellarTradeEffectMeasurable>;
  of: BitqueryStellarTradeEffectMeasurable;
};


/** Trade effect in Stellar blockchain */
export type BitqueryStellarTradeEffectMinimumArgs = {
  get?: InputMaybe<BitqueryStellarTradeEffectMeasurable>;
  of: BitqueryStellarTradeEffectMeasurable;
};


/** Trade effect in Stellar blockchain */
export type BitqueryStellarTradeEffectSellAmountArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  buyAmount?: InputMaybe<BitqueryFloatSelector>;
  buyCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  buyIssuer?: InputMaybe<BitqueryAddressSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  offerId?: InputMaybe<BitqueryIntegerSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  sellAmount?: InputMaybe<BitqueryFloatSelector>;
  sellCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  sellIssuer?: InputMaybe<BitqueryAddressSelector>;
  seller?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};

export type BitqueryStellarTradeEffectFilter = {
  address?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  buyAmount?: InputMaybe<BitqueryFloatSelector>;
  buyCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  buyIssuer?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  offerId?: InputMaybe<BitqueryIntegerSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  sellAmount?: InputMaybe<BitqueryFloatSelector>;
  sellCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  sellIssuer?: InputMaybe<BitqueryAddressSelector>;
  seller?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};

export enum BitqueryStellarTradeEffectMeasurable {
  /** Address */
  Address = 'address',
  /** Block */
  Block = 'block',
  /** Buy amount */
  BuyAmount = 'buyAmount',
  /** Buy currency name */
  BuyCurrencyName = 'buyCurrencyName',
  /** Buy currency symbol */
  BuyCurrencySymbol = 'buyCurrencySymbol',
  /** Buy issuer */
  BuyIssuer = 'buyIssuer',
  /** Date */
  Date = 'date',
  /** Effect index */
  EffectIndex = 'effectIndex',
  /** Offer */
  OfferId = 'offerId',
  /** Operation index */
  OpIndex = 'opIndex',
  /** Operation source account */
  OpSourceAccount = 'opSourceAccount',
  /** Operation */
  Operation = 'operation',
  /** Order */
  Order = 'order',
  /** Sell amount */
  SellAmount = 'sellAmount',
  /** Sell currency name */
  SellCurrencyName = 'sellCurrencyName',
  /** Sell currency symbol */
  SellCurrencySymbol = 'sellCurrencySymbol',
  /** Sell issuer */
  SellIssuer = 'sellIssuer',
  /** Seller */
  Seller = 'seller',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TransactionHash = 'transactionHash',
  /** Transaction index */
  TransactionIndex = 'transactionIndex',
  /** Transaction sender */
  TransactionSender = 'transactionSender'
}

export enum BitqueryStellarTradeEffectUniq {
  /** Uniq addresses count */
  Addresses = 'addresses',
  /** Uniq blocks count */
  Blocks = 'blocks',
  /** Uniq buy currency names count */
  BuyCurrencyNames = 'buyCurrencyNames',
  /** Uniq buy currency symbols count */
  BuyCurrencySymbols = 'buyCurrencySymbols',
  /** Uniq buy issuers count */
  BuyIssuers = 'buyIssuers',
  /** Uniq dates count */
  Dates = 'dates',
  /** Uniq effect indices count */
  EffectIndices = 'effectIndices',
  /** Uniq offer ids count */
  OfferIds = 'offerIds',
  /** Uniq operation indices count */
  OpIndices = 'opIndices',
  /** Uniq operation source accounts count */
  OpSourceAccounts = 'opSourceAccounts',
  /** Uniq operations count */
  Operations = 'operations',
  /** Uniq orders count */
  Orders = 'orders',
  /** Uniq sell currency names count */
  SellCurrencyNames = 'sellCurrencyNames',
  /** Uniq sell currency symbols count */
  SellCurrencySymbols = 'sellCurrencySymbols',
  /** Uniq sell issuers count */
  SellIssuers = 'sellIssuers',
  /** Uniq sellers count */
  Sellers = 'sellers',
  /** Uniq times count */
  Times = 'times',
  /** Uniq transaction hashes count */
  TransactionHashes = 'transactionHashes',
  /** Uniq transaction indices count */
  TransactionIndices = 'transactionIndices',
  /** Uniq transaction senders count */
  TransactionSenders = 'transactionSenders'
}

/** Transaction in Stellar blockchain */
export type BitqueryStellarTransaction = {
  __typename?: 'BitqueryStellarTransaction';
  any?: Maybe<Scalars['String']['output']>;
  /** The sequence number of the ledger that this transaction was included in */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  fee?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  /** Fee payer */
  feeAccount?: Maybe<BitqueryAddress>;
  /** Hash of this transaction */
  hash?: Maybe<Scalars['String']['output']>;
  /** Index of this transaction */
  index?: Maybe<Scalars['Int']['output']>;
  maxFee?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Memo type */
  memoType?: Maybe<Scalars['String']['output']>;
  /** Memos */
  memos?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Amout of operations */
  operationCount?: Maybe<Scalars['Int']['output']>;
  /** Sender of this transaction */
  sender?: Maybe<BitqueryAddress>;
  /** Sequence */
  sequence?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Time bounds */
  timeBounds?: Maybe<Scalars['String']['output']>;
  /** The time this transaction was created */
  timestamp?: Maybe<BitqueryDateTime>;
};


/** Transaction in Stellar blockchain */
export type BitqueryStellarTransactionAnyArgs = {
  of: BitqueryStellarTransactionMeasurable;
};


/** Transaction in Stellar blockchain */
export type BitqueryStellarTransactionCountArgs = {
  block?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  maxFee?: InputMaybe<BitqueryFloatSelector>;
  memoType?: InputMaybe<BitqueryStringSelector>;
  memos?: InputMaybe<BitqueryStringSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  sequence?: InputMaybe<BitqueryIntegerSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  timeBounds?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryStellarTransactionUniq>;
};


/** Transaction in Stellar blockchain */
export type BitqueryStellarTransactionCountBigIntArgs = {
  block?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  maxFee?: InputMaybe<BitqueryFloatSelector>;
  memoType?: InputMaybe<BitqueryStringSelector>;
  memos?: InputMaybe<BitqueryStringSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  sequence?: InputMaybe<BitqueryIntegerSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  timeBounds?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryStellarTransactionUniq>;
};


/** Transaction in Stellar blockchain */
export type BitqueryStellarTransactionExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transaction in Stellar blockchain */
export type BitqueryStellarTransactionFeeArgs = {
  block?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  maxFee?: InputMaybe<BitqueryFloatSelector>;
  memoType?: InputMaybe<BitqueryStringSelector>;
  memos?: InputMaybe<BitqueryStringSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  sequence?: InputMaybe<BitqueryIntegerSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  timeBounds?: InputMaybe<BitqueryStringSelector>;
};


/** Transaction in Stellar blockchain */
export type BitqueryStellarTransactionMaxFeeArgs = {
  block?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  maxFee?: InputMaybe<BitqueryFloatSelector>;
  memoType?: InputMaybe<BitqueryStringSelector>;
  memos?: InputMaybe<BitqueryStringSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  sequence?: InputMaybe<BitqueryIntegerSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  timeBounds?: InputMaybe<BitqueryStringSelector>;
};


/** Transaction in Stellar blockchain */
export type BitqueryStellarTransactionMaximumArgs = {
  get?: InputMaybe<BitqueryStellarTransactionMeasurable>;
  of: BitqueryStellarTransactionMeasurable;
};


/** Transaction in Stellar blockchain */
export type BitqueryStellarTransactionMinimumArgs = {
  get?: InputMaybe<BitqueryStellarTransactionMeasurable>;
  of: BitqueryStellarTransactionMeasurable;
};

/** Blockchain transaction Info */
export type BitqueryStellarTransactionCoinpathDimension = {
  __typename?: 'BitqueryStellarTransactionCoinpathDimension';
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction Index */
  index: Scalars['Int']['output'];
  /** Time */
  time?: Maybe<BitqueryDateTime>;
  /** Transaction Value From */
  valueFrom?: Maybe<Scalars['Float']['output']>;
  /** Transaction Value To */
  valueTo?: Maybe<Scalars['Float']['output']>;
};

/** Blockchain transaction */
export type BitqueryStellarTransactionDimension = {
  __typename?: 'BitqueryStellarTransactionDimension';
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction index in block */
  index: Scalars['Int']['output'];
  /** Transaction sender */
  sender?: Maybe<Scalars['String']['output']>;
};

export type BitqueryStellarTransactionFilter = {
  block?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  maxFee?: InputMaybe<BitqueryFloatSelector>;
  memoType?: InputMaybe<BitqueryStringSelector>;
  memos?: InputMaybe<BitqueryStringSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  sequence?: InputMaybe<BitqueryIntegerSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  timeBounds?: InputMaybe<BitqueryStringSelector>;
};

export enum BitqueryStellarTransactionMeasurable {
  /** Ledger */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** fee */
  Fee = 'fee',
  /** Transaction Hash */
  Hash = 'hash',
  /** Transaction Index */
  Index = 'index',
  /** Max fee */
  MaxFee = 'maxFee',
  /** Memo type */
  MemoType = 'memoType',
  /** Memos */
  Memos = 'memos',
  /** Transaction sender */
  Sender = 'sender',
  /** Sequence */
  Sequence = 'sequence',
  /** Success */
  Success = 'success',
  /** Time */
  Time = 'time',
  /** Time bounds */
  TimeBounds = 'timeBounds'
}

export enum BitqueryStellarTransactionUniq {
  /** Uniq blocks count */
  Blocks = 'blocks',
  /** Uniq date count */
  Dates = 'dates',
  /** Uniq transaction hashes count */
  Hashes = 'hashes',
  /** Uniq memo types count */
  MemoTypes = 'memoTypes',
  /** Uniq transaction senders */
  Senders = 'senders',
  /** Uniq sequences count */
  Sequences = 'sequences'
}

/** Transfer in Stellar blockchain */
export type BitqueryStellarTransfer = {
  __typename?: 'BitqueryStellarTransfer';
  amountFrom?: Maybe<Scalars['Float']['output']>;
  amountTo?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** The sequence number of the ledger that this transaction was included in */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency from of transfer */
  currencyFrom?: Maybe<BitqueryCurrency>;
  /** Currency to of transfer */
  currencyTo?: Maybe<BitqueryCurrency>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  /** Direction */
  direction?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<BitqueryOperationIndexed>;
  /** The account this transaction is been sent to */
  receiver?: Maybe<BitqueryAddress>;
  /** Sender */
  sender?: Maybe<BitqueryAddress>;
  /** The time this transaction was created */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryStellarTransactionDimension>;
};


/** Transfer in Stellar blockchain */
export type BitqueryStellarTransferAmountFromArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currencyFromName?: InputMaybe<BitqueryCurrencySelector>;
  currencyToName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  direction?: InputMaybe<BitqueryStringSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Transfer in Stellar blockchain */
export type BitqueryStellarTransferAmountToArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currencyFromName?: InputMaybe<BitqueryCurrencySelector>;
  currencyToName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  direction?: InputMaybe<BitqueryStringSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Transfer in Stellar blockchain */
export type BitqueryStellarTransferAnyArgs = {
  of: BitqueryStellarTransferMeasurable;
};


/** Transfer in Stellar blockchain */
export type BitqueryStellarTransferCountArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  currencyFromName?: InputMaybe<BitqueryCurrencySelector>;
  currencyToName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  direction?: InputMaybe<BitqueryStringSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarTransferUniq>;
};


/** Transfer in Stellar blockchain */
export type BitqueryStellarTransferCountBigIntArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  currencyFromName?: InputMaybe<BitqueryCurrencySelector>;
  currencyToName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  direction?: InputMaybe<BitqueryStringSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarTransferUniq>;
};


/** Transfer in Stellar blockchain */
export type BitqueryStellarTransferExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transfer in Stellar blockchain */
export type BitqueryStellarTransferMaximumArgs = {
  get?: InputMaybe<BitqueryStellarTransferMeasurable>;
  of: BitqueryStellarTransferMeasurable;
};


/** Transfer in Stellar blockchain */
export type BitqueryStellarTransferMinimumArgs = {
  get?: InputMaybe<BitqueryStellarTransferMeasurable>;
  of: BitqueryStellarTransferMeasurable;
};

export type BitqueryStellarTransferFilter = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  currencyFromName?: InputMaybe<BitqueryCurrencySelector>;
  currencyToName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  direction?: InputMaybe<BitqueryStringSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};

export enum BitqueryStellarTransferMeasurable {
  /** Amount from */
  AmountFrom = 'amountFrom',
  /** Amount to */
  AmountTo = 'amountTo',
  /** Ledger */
  Block = 'block',
  /** Currency from name */
  CurrencyFromName = 'currencyFromName',
  /** Currency from symbol */
  CurrencyFromSymbol = 'currencyFromSymbol',
  /** Currency to name */
  CurrencyToName = 'currencyToName',
  /** Currency to symbol */
  CurrencyToSymbol = 'currencyToSymbol',
  /** Date */
  Date = 'date',
  /** Direction */
  Direction = 'direction',
  /** Operation index */
  OpIndex = 'opIndex',
  /** Operation */
  Operation = 'operation',
  /** Transfer Receiver */
  Receiver = 'receiver',
  /** Transfer Sender */
  Sender = 'sender',
  /** Time */
  Time = 'time',
  /** Transaction Hash */
  TransactionHash = 'transactionHash',
  /** Transaction Index */
  TransactionIndex = 'transactionIndex',
  /** Transaction sender */
  TransactionSender = 'transactionSender'
}

export enum BitqueryStellarTransferUniq {
  /** Uniq currency from names */
  CurrenciesFromName = 'currenciesFromName',
  /** Uniq currency from symbols */
  CurrenciesFromSymbol = 'currenciesFromSymbol',
  /** Uniq currency to names */
  CurrenciesToName = 'currenciesToName',
  /** Uniq currency to symbols */
  CurrenciesToSymbol = 'currenciesToSymbol',
  /** Uniq dates count */
  Dates = 'dates',
  /** Uniq directions */
  Directions = 'directions',
  /** Uniq operation indices */
  OpIndices = 'opIndices',
  /** Uniq operations */
  Operations = 'operations',
  /** Uniq transfer receivers */
  Receivers = 'receivers',
  /** Uniq transfer senders */
  Senders = 'senders',
  /** Uniq times count */
  Times = 'times',
  /** Uniq transaction hashes */
  TransactionHashes = 'transactionHashes',
  /** Uniq transaction indices */
  TransactionIndices = 'transactionIndices',
  /** Uniq transaction senders */
  TransactionSenders = 'transactionSenders'
}

/** Select by ID */
export type BitqueryStringIdSelector = {
  /** ID in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** ID is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** ID not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** ID not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Select by string */
export type BitqueryStringSelector = {
  /** String in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** String is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** String not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** String not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Search result subject */
export type BitquerySubject = BitqueryAddress | BitqueryCurrency | BitqueryMessageHash | BitquerySmartContract | BitqueryTransactionHash;

/** Tezos Chain */
export type BitqueryTezos = {
  __typename?: 'BitqueryTezos';
  /** Basic information about address */
  address: Array<BitqueryTezosAddressInfoWithBalance>;
  /** Tezos Arguments */
  arguments?: Maybe<Array<BitqueryTezosArgument>>;
  /** Tezos Balance Updates */
  balanceUpdates?: Maybe<Array<BitqueryTezosBalanceUpdate>>;
  /** Tezos Blocks */
  blocks?: Maybe<Array<BitqueryTezosBlock>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryTezosCoinpath>>;
  /** Tezos Operations */
  operations?: Maybe<Array<BitqueryTezosOperation>>;
  /** Tezos Transactions */
  transactions?: Maybe<Array<BitqueryTezosTransaction>>;
  /** Tezos Transfers */
  transfers?: Maybe<Array<BitqueryTezosTransfer>>;
};


/** Tezos Chain */
export type BitqueryTezosAddressArgs = {
  address: Array<BitqueryAddressSelectorIn>;
};


/** Tezos Chain */
export type BitqueryTezosArgumentsArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  any?: InputMaybe<Array<BitqueryTezosArgumentFilter>>;
  argname?: InputMaybe<BitqueryStringSelector>;
  argvalue?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
};


/** Tezos Chain */
export type BitqueryTezosBalanceUpdatesArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  any?: InputMaybe<Array<BitqueryTezosBalanceUpdateFilter>>;
  attribute?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  category?: InputMaybe<BitqueryStringSelector>;
  change?: InputMaybe<BitqueryFloatSelector>;
  cycle?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  freezer?: InputMaybe<BitqueryBooleanSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  kind?: InputMaybe<BitqueryStringSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  source?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
};


/** Tezos Chain */
export type BitqueryTezosBlocksArgs = {
  any?: InputMaybe<Array<BitqueryTezosBlockFilter>>;
  baker?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Tezos Chain */
export type BitqueryTezosCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCoinpathOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Tezos Chain */
export type BitqueryTezosOperationsArgs = {
  any?: InputMaybe<Array<BitqueryTezosOperationFilter>>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  contents?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  kind?: InputMaybe<BitqueryStringSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  source?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
};


/** Tezos Chain */
export type BitqueryTezosTransactionsArgs = {
  allocatedDestinationContract?: InputMaybe<BitqueryBooleanSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  any?: InputMaybe<Array<BitqueryTezosTransactionFilter>>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  burnAmount?: InputMaybe<BitqueryFloatSelector>;
  consumedGas?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationContract?: InputMaybe<BitqueryBooleanSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  gasLimit?: InputMaybe<BitqueryBigIntIdSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  paidStorageAmount?: InputMaybe<BitqueryFloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BitqueryBigIntIdSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  source?: InputMaybe<BitqueryStringSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  storageSize?: InputMaybe<BitqueryBigIntIdSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Tezos Chain */
export type BitqueryTezosTransfersArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  any?: InputMaybe<Array<BitqueryTezosTransferFilter>>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationContract?: InputMaybe<BitqueryBooleanSelector>;
  direction?: InputMaybe<BitqueryStringSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  kind?: InputMaybe<BitqueryStringSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
};

/** Address detailed information for Tezos network */
export type BitqueryTezosAddressInfoWithBalance = {
  __typename?: 'BitqueryTezosAddressInfoWithBalance';
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Wallet balance */
  balance?: Maybe<Array<BitqueryTezosBalance>>;
};

/** Argument in Tezos blockchain */
export type BitqueryTezosArgument = {
  __typename?: 'BitqueryTezosArgument';
  amount?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Argname */
  argname?: Maybe<Scalars['String']['output']>;
  /** Argvalue */
  argvalue?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<BitqueryTezosBlockWithHashDimension>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Internal */
  internal?: Maybe<Scalars['Boolean']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Op path */
  opPath?: Maybe<Scalars['String']['output']>;
  /** Proto */
  proto?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Protocol */
  protocol?: Maybe<Scalars['String']['output']>;
  /** Receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Sender */
  sender?: Maybe<BitqueryAddress>;
  /** Status */
  status?: Maybe<Scalars['String']['output']>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryTezosTransactionWithSourceDimension>;
};


/** Argument in Tezos blockchain */
export type BitqueryTezosArgumentAmountArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  argname?: InputMaybe<BitqueryStringSelector>;
  argvalue?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
};


/** Argument in Tezos blockchain */
export type BitqueryTezosArgumentAnyArgs = {
  of: BitqueryTezosArgumentMeasurable;
};


/** Argument in Tezos blockchain */
export type BitqueryTezosArgumentCountArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  argname?: InputMaybe<BitqueryStringSelector>;
  argvalue?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryTezosArgumentUniq>;
};


/** Argument in Tezos blockchain */
export type BitqueryTezosArgumentCountBigIntArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  argname?: InputMaybe<BitqueryStringSelector>;
  argvalue?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryTezosArgumentUniq>;
};


/** Argument in Tezos blockchain */
export type BitqueryTezosArgumentExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Argument in Tezos blockchain */
export type BitqueryTezosArgumentMaximumArgs = {
  get?: InputMaybe<BitqueryTezosArgumentMeasurable>;
  of: BitqueryTezosArgumentMeasurable;
};


/** Argument in Tezos blockchain */
export type BitqueryTezosArgumentMinimumArgs = {
  get?: InputMaybe<BitqueryTezosArgumentMeasurable>;
  of: BitqueryTezosArgumentMeasurable;
};

export type BitqueryTezosArgumentFilter = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  argname?: InputMaybe<BitqueryStringSelector>;
  argvalue?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
};

export enum BitqueryTezosArgumentMeasurable {
  /** Amount */
  Amount = 'amount',
  /** Argname */
  Argname = 'argname',
  /** Argvalue */
  Argvalue = 'argvalue',
  /** Block */
  Block = 'block',
  /** Block hash */
  BlockHash = 'blockHash',
  /** Date */
  Date = 'date',
  /** Internal */
  Internal = 'internal',
  /** Op path */
  OpPath = 'opPath',
  /** Proto */
  Proto = 'proto',
  /** Protocol */
  Protocol = 'protocol',
  /** Receiver */
  Receiver = 'receiver',
  /** Sender */
  Sender = 'sender',
  /** Status */
  Status = 'status',
  /** Success */
  Success = 'success',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TransactionHash = 'transactionHash',
  /** Transaction source */
  TransactionSource = 'transactionSource'
}

export enum BitqueryTezosArgumentUniq {
  /** Uniq argnames count */
  Argnames = 'argnames',
  /** Uniq argvalues count */
  Argvalues = 'argvalues',
  /** Uniq block hashes count */
  BlockHashes = 'blockHashes',
  /** Uniq blocks count */
  Blocks = 'blocks',
  /** Uniq dates count */
  Dates = 'dates',
  /** Uniq op paths count */
  OpPaths = 'opPaths',
  /** Uniq protocols count */
  Protocols = 'protocols',
  /** Uniq protos count */
  Protos = 'protos',
  /** Uniq receivers count */
  Receivers = 'receivers',
  /** Uniq senders count */
  Senders = 'senders',
  /** Uniq statuses count */
  Statuses = 'statuses',
  /** Uniq times count */
  Times = 'times',
  /** Uniq transaction hashes count */
  TransactionHashes = 'transactionHashes',
  /** Uniq transaction sources count */
  TransactionSources = 'transactionSources'
}

/** XTZ Balance */
export type BitqueryTezosBalance = {
  __typename?: 'BitqueryTezosBalance';
  /** Spendable Balance */
  available?: Maybe<Scalars['Float']['output']>;
  /** Delegated Balance */
  delegated?: Maybe<Scalars['Float']['output']>;
  /** Frozen Deposit */
  frozenDeposit?: Maybe<Scalars['Float']['output']>;
  /** Staking Balance */
  staking?: Maybe<Scalars['Float']['output']>;
  /** Total Balance */
  total?: Maybe<Scalars['Float']['output']>;
};


/** XTZ Balance */
export type BitqueryTezosBalanceAvailableArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** XTZ Balance */
export type BitqueryTezosBalanceDelegatedArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** XTZ Balance */
export type BitqueryTezosBalanceFrozenDepositArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** XTZ Balance */
export type BitqueryTezosBalanceStakingArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** XTZ Balance */
export type BitqueryTezosBalanceTotalArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};

/** Balance update in Tezos blockchain */
export type BitqueryTezosBalanceUpdate = {
  __typename?: 'BitqueryTezosBalanceUpdate';
  /** Address */
  address?: Maybe<BitqueryAddress>;
  any?: Maybe<Scalars['String']['output']>;
  /** Attribute */
  attribute?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<BitqueryTezosBlockWithHashDimension>;
  /** Category */
  category?: Maybe<Scalars['String']['output']>;
  change?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Cycle */
  cycle?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Freezer */
  freezer?: Maybe<Scalars['Boolean']['output']>;
  /** Internal */
  internal?: Maybe<Scalars['Boolean']['output']>;
  /** Kind */
  kind?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Op path */
  opPath?: Maybe<Scalars['String']['output']>;
  /** Proto */
  proto?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Protocol */
  protocol?: Maybe<Scalars['String']['output']>;
  /** Source */
  source?: Maybe<BitqueryAddress>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryTezosTransactionWithSourceDimension>;
};


/** Balance update in Tezos blockchain */
export type BitqueryTezosBalanceUpdateAnyArgs = {
  of: BitqueryTezosBalanceUpdateMeasurable;
};


/** Balance update in Tezos blockchain */
export type BitqueryTezosBalanceUpdateChangeArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  attribute?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  category?: InputMaybe<BitqueryStringSelector>;
  change?: InputMaybe<BitqueryFloatSelector>;
  cycle?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  freezer?: InputMaybe<BitqueryBooleanSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  kind?: InputMaybe<BitqueryStringSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  source?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
};


/** Balance update in Tezos blockchain */
export type BitqueryTezosBalanceUpdateCountArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  attribute?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  category?: InputMaybe<BitqueryStringSelector>;
  change?: InputMaybe<BitqueryFloatSelector>;
  cycle?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  freezer?: InputMaybe<BitqueryBooleanSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  kind?: InputMaybe<BitqueryStringSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  source?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryTezosBalanceUpdateUniq>;
};


/** Balance update in Tezos blockchain */
export type BitqueryTezosBalanceUpdateCountBigIntArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  attribute?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  category?: InputMaybe<BitqueryStringSelector>;
  change?: InputMaybe<BitqueryFloatSelector>;
  cycle?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  freezer?: InputMaybe<BitqueryBooleanSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  kind?: InputMaybe<BitqueryStringSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  source?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryTezosBalanceUpdateUniq>;
};


/** Balance update in Tezos blockchain */
export type BitqueryTezosBalanceUpdateExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Balance update in Tezos blockchain */
export type BitqueryTezosBalanceUpdateMaximumArgs = {
  get?: InputMaybe<BitqueryTezosBalanceUpdateMeasurable>;
  of: BitqueryTezosBalanceUpdateMeasurable;
};


/** Balance update in Tezos blockchain */
export type BitqueryTezosBalanceUpdateMinimumArgs = {
  get?: InputMaybe<BitqueryTezosBalanceUpdateMeasurable>;
  of: BitqueryTezosBalanceUpdateMeasurable;
};

export type BitqueryTezosBalanceUpdateFilter = {
  address?: InputMaybe<BitqueryAddressSelector>;
  attribute?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  category?: InputMaybe<BitqueryStringSelector>;
  change?: InputMaybe<BitqueryFloatSelector>;
  cycle?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  freezer?: InputMaybe<BitqueryBooleanSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  kind?: InputMaybe<BitqueryStringSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  source?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
};

export enum BitqueryTezosBalanceUpdateMeasurable {
  /** Address */
  Address = 'address',
  /** Attribute */
  Attribute = 'attribute',
  /** Block */
  Block = 'block',
  /** Block hash */
  BlockHash = 'blockHash',
  /** Category */
  Category = 'category',
  /** Change */
  Change = 'change',
  /** Cycle */
  Cycle = 'cycle',
  /** Date */
  Date = 'date',
  /** Freezer */
  Freezer = 'freezer',
  /** Internal */
  Internal = 'internal',
  /** Kind */
  Kind = 'kind',
  /** Op path */
  OpPath = 'opPath',
  /** Proto */
  Proto = 'proto',
  /** Protocol */
  Protocol = 'protocol',
  /** Source */
  Source = 'source',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TransactionHash = 'transactionHash',
  /** Transaction source */
  TransactionSource = 'transactionSource'
}

export enum BitqueryTezosBalanceUpdateUniq {
  /** Uniq addresses count */
  Addresses = 'addresses',
  /** Uniq attributes count */
  Attributes = 'attributes',
  /** Uniq block hashes count */
  BlockHashes = 'blockHashes',
  /** Uniq blocks count */
  Blocks = 'blocks',
  /** Uniq categories count */
  Categories = 'categories',
  /** Uniq cycles count */
  Cycles = 'cycles',
  /** Uniq dates count */
  Dates = 'dates',
  /** Uniq kinds count */
  Kinds = 'kinds',
  /** Uniq op paths count */
  OpPaths = 'opPaths',
  /** Uniq protocols count */
  Protocols = 'protocols',
  /** Uniq protos count */
  Protos = 'protos',
  /** Uniq sources count */
  Sources = 'sources',
  /** Uniq times count */
  Times = 'times',
  /** Uniq transaction hashes count */
  TransactionHashes = 'transactionHashes',
  /** Uniq transaction sources count */
  TransactionSources = 'transactionSources'
}

/** Block in Tezos blockchain */
export type BitqueryTezosBlock = {
  __typename?: 'BitqueryTezosBlock';
  any?: Maybe<Scalars['String']['output']>;
  /** Baker */
  baker?: Maybe<BitqueryAddress>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Hash */
  hash?: Maybe<Scalars['String']['output']>;
  /** Header */
  header?: Maybe<Scalars['String']['output']>;
  /** Block number (height) in blockchain */
  height?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Metadata */
  metadata?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Proto */
  proto?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Protocol */
  protocol?: Maybe<Scalars['String']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
};


/** Block in Tezos blockchain */
export type BitqueryTezosBlockAnyArgs = {
  of: BitqueryTezosBlockMeasurable;
};


/** Block in Tezos blockchain */
export type BitqueryTezosBlockCountArgs = {
  baker?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryTezosBlockUniq>;
};


/** Block in Tezos blockchain */
export type BitqueryTezosBlockCountBigIntArgs = {
  baker?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryTezosBlockUniq>;
};


/** Block in Tezos blockchain */
export type BitqueryTezosBlockExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Block in Tezos blockchain */
export type BitqueryTezosBlockMaximumArgs = {
  get?: InputMaybe<BitqueryTezosBlockMeasurable>;
  of: BitqueryTezosBlockMeasurable;
};


/** Block in Tezos blockchain */
export type BitqueryTezosBlockMinimumArgs = {
  get?: InputMaybe<BitqueryTezosBlockMeasurable>;
  of: BitqueryTezosBlockMeasurable;
};

export type BitqueryTezosBlockFilter = {
  baker?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

export enum BitqueryTezosBlockMeasurable {
  /** Baker */
  Baker = 'baker',
  /** Date */
  Date = 'date',
  /** Hash */
  Hash = 'hash',
  /** Header */
  Header = 'header',
  /** Height */
  Height = 'height',
  /** Metadata */
  Metadata = 'metadata',
  /** Proto */
  Proto = 'proto',
  /** Protocol */
  Protocol = 'protocol',
  /** Time */
  Time = 'time'
}

export enum BitqueryTezosBlockUniq {
  /** Uniq bakers count */
  Bakers = 'bakers',
  /** Uniq dates count */
  Dates = 'dates',
  /** Uniq hashes count */
  Hashes = 'hashes',
  /** Uniq headers count */
  Headers = 'headers',
  /** Uniq heights count */
  Heights = 'heights',
  /** Uniq metadatas count */
  Metadatas = 'metadatas',
  /** Uniq protocols count */
  Protocols = 'protocols',
  /** Uniq protos count */
  Protos = 'protos',
  /** Uniq times count */
  Times = 'times'
}

/** Tezos block with hash */
export type BitqueryTezosBlockWithHashDimension = {
  __typename?: 'BitqueryTezosBlockWithHashDimension';
  /** Block hash */
  hash: Scalars['String']['output'];
  /** Block */
  height: Scalars['BitqueryBigInt']['output'];
};

/** Coinpath */
export type BitqueryTezosCoinpath = {
  __typename?: 'BitqueryTezosCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<BitqueryTransactionHashValue>;
};


/** Coinpath */
export type BitqueryTezosCoinpathAmountArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Coinpath */
export type BitqueryTezosCoinpathAnyArgs = {
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryTezosCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryTezosCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};

export enum BitqueryTezosNetwork {
  /** Tezos */
  Tezos = 'tezos'
}

/** Operation in Tezos blockchain */
export type BitqueryTezosOperation = {
  __typename?: 'BitqueryTezosOperation';
  any?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<BitqueryTezosBlockWithHashDimension>;
  /** Contents */
  contents?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Internal */
  internal?: Maybe<Scalars['Boolean']['output']>;
  /** Kind */
  kind?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Op path */
  opPath?: Maybe<Scalars['String']['output']>;
  /** Proto */
  proto?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Protocol */
  protocol?: Maybe<Scalars['String']['output']>;
  /** Source */
  source?: Maybe<Scalars['String']['output']>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryTezosTransactionWithSourceDimension>;
};


/** Operation in Tezos blockchain */
export type BitqueryTezosOperationAnyArgs = {
  of: BitqueryTezosOperationMeasurable;
};


/** Operation in Tezos blockchain */
export type BitqueryTezosOperationCountArgs = {
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  contents?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  kind?: InputMaybe<BitqueryStringSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  source?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryTezosOperationUniq>;
};


/** Operation in Tezos blockchain */
export type BitqueryTezosOperationCountBigIntArgs = {
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  contents?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  kind?: InputMaybe<BitqueryStringSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  source?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryTezosOperationUniq>;
};


/** Operation in Tezos blockchain */
export type BitqueryTezosOperationExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Operation in Tezos blockchain */
export type BitqueryTezosOperationMaximumArgs = {
  get?: InputMaybe<BitqueryTezosOperationMeasurable>;
  of: BitqueryTezosOperationMeasurable;
};


/** Operation in Tezos blockchain */
export type BitqueryTezosOperationMinimumArgs = {
  get?: InputMaybe<BitqueryTezosOperationMeasurable>;
  of: BitqueryTezosOperationMeasurable;
};

export type BitqueryTezosOperationFilter = {
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  contents?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  kind?: InputMaybe<BitqueryStringSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  source?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
};

export enum BitqueryTezosOperationMeasurable {
  /** Block */
  Block = 'block',
  /** Block hash */
  BlockHash = 'blockHash',
  /** Contents */
  Contents = 'contents',
  /** Date */
  Date = 'date',
  /** Internal */
  Internal = 'internal',
  /** Kind */
  Kind = 'kind',
  /** Op path */
  OpPath = 'opPath',
  /** Proto */
  Proto = 'proto',
  /** Protocol */
  Protocol = 'protocol',
  /** Source */
  Source = 'source',
  /** Success */
  Success = 'success',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TransactionHash = 'transactionHash',
  /** Transaction source */
  TransactionSource = 'transactionSource'
}

export enum BitqueryTezosOperationUniq {
  /** Uniq block hashes count */
  BlockHashes = 'blockHashes',
  /** Uniq blocks count */
  Blocks = 'blocks',
  /** Uniq contents count */
  Contents = 'contents',
  /** Uniq dates count */
  Dates = 'dates',
  /** Uniq kinds count */
  Kinds = 'kinds',
  /** Uniq op paths count */
  OpPaths = 'opPaths',
  /** Uniq protocols count */
  Protocols = 'protocols',
  /** Uniq protos count */
  Protos = 'protos',
  /** Uniq sources count */
  Sources = 'sources',
  /** Uniq times count */
  Times = 'times',
  /** Uniq transaction hashes count */
  TransactionHashes = 'transactionHashes',
  /** Uniq transaction sources count */
  TransactionSources = 'transactionSources'
}

/** Transaction in Tezos blockchain */
export type BitqueryTezosTransaction = {
  __typename?: 'BitqueryTezosTransaction';
  /** Allocated destination contract */
  allocatedDestinationContract?: Maybe<Scalars['Boolean']['output']>;
  amount?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<BitqueryTezosBlockWithHashDimension>;
  burnAmount?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  consumedGas?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Destination contract */
  destinationContract?: Maybe<Scalars['Boolean']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  fee?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  gasLimit?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Transaction hash */
  hash?: Maybe<Scalars['String']['output']>;
  /** Internal */
  internal?: Maybe<Scalars['Boolean']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Op path */
  opPath?: Maybe<Scalars['String']['output']>;
  paidStorageAmount?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  paidStorageSizeDiff?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Proto */
  proto?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Protocol */
  protocol?: Maybe<Scalars['String']['output']>;
  /** Receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Sender */
  sender?: Maybe<BitqueryAddress>;
  /** Transaction source */
  source?: Maybe<BitqueryAddress>;
  /** Status */
  status?: Maybe<Scalars['String']['output']>;
  storageSize?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
};


/** Transaction in Tezos blockchain */
export type BitqueryTezosTransactionAmountArgs = {
  allocatedDestinationContract?: InputMaybe<BitqueryBooleanSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  burnAmount?: InputMaybe<BitqueryFloatSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  consumedGas?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationContract?: InputMaybe<BitqueryBooleanSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  gasLimit?: InputMaybe<BitqueryBigIntIdSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  paidStorageAmount?: InputMaybe<BitqueryFloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BitqueryBigIntIdSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  source?: InputMaybe<BitqueryStringSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  storageSize?: InputMaybe<BitqueryBigIntIdSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transaction in Tezos blockchain */
export type BitqueryTezosTransactionAnyArgs = {
  of: BitqueryTezosTransactionMeasurable;
};


/** Transaction in Tezos blockchain */
export type BitqueryTezosTransactionBurnAmountArgs = {
  allocatedDestinationContract?: InputMaybe<BitqueryBooleanSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  burnAmount?: InputMaybe<BitqueryFloatSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  consumedGas?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationContract?: InputMaybe<BitqueryBooleanSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  gasLimit?: InputMaybe<BitqueryBigIntIdSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  paidStorageAmount?: InputMaybe<BitqueryFloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BitqueryBigIntIdSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  source?: InputMaybe<BitqueryStringSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  storageSize?: InputMaybe<BitqueryBigIntIdSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transaction in Tezos blockchain */
export type BitqueryTezosTransactionConsumedGasArgs = {
  allocatedDestinationContract?: InputMaybe<BitqueryBooleanSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  burnAmount?: InputMaybe<BitqueryFloatSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  consumedGas?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationContract?: InputMaybe<BitqueryBooleanSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  gasLimit?: InputMaybe<BitqueryBigIntIdSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  paidStorageAmount?: InputMaybe<BitqueryFloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BitqueryBigIntIdSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  source?: InputMaybe<BitqueryStringSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  storageSize?: InputMaybe<BitqueryBigIntIdSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transaction in Tezos blockchain */
export type BitqueryTezosTransactionCountArgs = {
  allocatedDestinationContract?: InputMaybe<BitqueryBooleanSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  burnAmount?: InputMaybe<BitqueryFloatSelector>;
  consumedGas?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationContract?: InputMaybe<BitqueryBooleanSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  gasLimit?: InputMaybe<BitqueryBigIntIdSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  paidStorageAmount?: InputMaybe<BitqueryFloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BitqueryBigIntIdSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  source?: InputMaybe<BitqueryStringSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  storageSize?: InputMaybe<BitqueryBigIntIdSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryTezosTransactionUniq>;
};


/** Transaction in Tezos blockchain */
export type BitqueryTezosTransactionCountBigIntArgs = {
  allocatedDestinationContract?: InputMaybe<BitqueryBooleanSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  burnAmount?: InputMaybe<BitqueryFloatSelector>;
  consumedGas?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationContract?: InputMaybe<BitqueryBooleanSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  gasLimit?: InputMaybe<BitqueryBigIntIdSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  paidStorageAmount?: InputMaybe<BitqueryFloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BitqueryBigIntIdSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  source?: InputMaybe<BitqueryStringSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  storageSize?: InputMaybe<BitqueryBigIntIdSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryTezosTransactionUniq>;
};


/** Transaction in Tezos blockchain */
export type BitqueryTezosTransactionExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transaction in Tezos blockchain */
export type BitqueryTezosTransactionFeeArgs = {
  allocatedDestinationContract?: InputMaybe<BitqueryBooleanSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  burnAmount?: InputMaybe<BitqueryFloatSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  consumedGas?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationContract?: InputMaybe<BitqueryBooleanSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  gasLimit?: InputMaybe<BitqueryBigIntIdSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  paidStorageAmount?: InputMaybe<BitqueryFloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BitqueryBigIntIdSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  source?: InputMaybe<BitqueryStringSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  storageSize?: InputMaybe<BitqueryBigIntIdSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transaction in Tezos blockchain */
export type BitqueryTezosTransactionGasLimitArgs = {
  allocatedDestinationContract?: InputMaybe<BitqueryBooleanSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  burnAmount?: InputMaybe<BitqueryFloatSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  consumedGas?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationContract?: InputMaybe<BitqueryBooleanSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  gasLimit?: InputMaybe<BitqueryBigIntIdSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  paidStorageAmount?: InputMaybe<BitqueryFloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BitqueryBigIntIdSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  source?: InputMaybe<BitqueryStringSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  storageSize?: InputMaybe<BitqueryBigIntIdSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transaction in Tezos blockchain */
export type BitqueryTezosTransactionMaximumArgs = {
  get?: InputMaybe<BitqueryTezosTransactionMeasurable>;
  of: BitqueryTezosTransactionMeasurable;
};


/** Transaction in Tezos blockchain */
export type BitqueryTezosTransactionMinimumArgs = {
  get?: InputMaybe<BitqueryTezosTransactionMeasurable>;
  of: BitqueryTezosTransactionMeasurable;
};


/** Transaction in Tezos blockchain */
export type BitqueryTezosTransactionPaidStorageAmountArgs = {
  allocatedDestinationContract?: InputMaybe<BitqueryBooleanSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  burnAmount?: InputMaybe<BitqueryFloatSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  consumedGas?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationContract?: InputMaybe<BitqueryBooleanSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  gasLimit?: InputMaybe<BitqueryBigIntIdSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  paidStorageAmount?: InputMaybe<BitqueryFloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BitqueryBigIntIdSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  source?: InputMaybe<BitqueryStringSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  storageSize?: InputMaybe<BitqueryBigIntIdSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transaction in Tezos blockchain */
export type BitqueryTezosTransactionPaidStorageSizeDiffArgs = {
  allocatedDestinationContract?: InputMaybe<BitqueryBooleanSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  burnAmount?: InputMaybe<BitqueryFloatSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  consumedGas?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationContract?: InputMaybe<BitqueryBooleanSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  gasLimit?: InputMaybe<BitqueryBigIntIdSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  paidStorageAmount?: InputMaybe<BitqueryFloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BitqueryBigIntIdSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  source?: InputMaybe<BitqueryStringSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  storageSize?: InputMaybe<BitqueryBigIntIdSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transaction in Tezos blockchain */
export type BitqueryTezosTransactionStorageSizeArgs = {
  allocatedDestinationContract?: InputMaybe<BitqueryBooleanSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  burnAmount?: InputMaybe<BitqueryFloatSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  consumedGas?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationContract?: InputMaybe<BitqueryBooleanSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  gasLimit?: InputMaybe<BitqueryBigIntIdSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  paidStorageAmount?: InputMaybe<BitqueryFloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BitqueryBigIntIdSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  source?: InputMaybe<BitqueryStringSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  storageSize?: InputMaybe<BitqueryBigIntIdSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

export type BitqueryTezosTransactionFilter = {
  allocatedDestinationContract?: InputMaybe<BitqueryBooleanSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  burnAmount?: InputMaybe<BitqueryFloatSelector>;
  consumedGas?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationContract?: InputMaybe<BitqueryBooleanSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  gasLimit?: InputMaybe<BitqueryBigIntIdSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  paidStorageAmount?: InputMaybe<BitqueryFloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BitqueryBigIntIdSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  source?: InputMaybe<BitqueryStringSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  storageSize?: InputMaybe<BitqueryBigIntIdSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

export enum BitqueryTezosTransactionMeasurable {
  /** Allocated destination contract */
  AllocatedDestinationContract = 'allocatedDestinationContract',
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Block hash */
  BlockHash = 'blockHash',
  /** Burn amount */
  BurnAmount = 'burnAmount',
  /** Consumed gas */
  ConsumedGas = 'consumedGas',
  /** Date */
  Date = 'date',
  /** Destination contract */
  DestinationContract = 'destinationContract',
  /** Fee */
  Fee = 'fee',
  /** Gas limit */
  GasLimit = 'gasLimit',
  /** Transaction hash */
  Hash = 'hash',
  /** Internal */
  Internal = 'internal',
  /** Op path */
  OpPath = 'opPath',
  /** Paid storage amount */
  PaidStorageAmount = 'paidStorageAmount',
  /** Paid storage size diff */
  PaidStorageSizeDiff = 'paid_storage_size_diff',
  /** Proto */
  Proto = 'proto',
  /** Protocol */
  Protocol = 'protocol',
  /** Receiver */
  Receiver = 'receiver',
  /** Sender */
  Sender = 'sender',
  /** Transaction source */
  Source = 'source',
  /** Status */
  Status = 'status',
  /** Storage size */
  StorageSize = 'storageSize',
  /** Success */
  Success = 'success',
  /** Time */
  Time = 'time'
}

export enum BitqueryTezosTransactionUniq {
  /** Uniq block hashes count */
  BlockHashes = 'blockHashes',
  /** Uniq blocks count */
  Blocks = 'blocks',
  /** Uniq dates count */
  Dates = 'dates',
  /** Uniq transaction hashes count */
  Hashes = 'hashes',
  /** Uniq op paths count */
  OpPaths = 'opPaths',
  /** Uniq protocols count */
  Protocols = 'protocols',
  /** Uniq protos count */
  Protos = 'protos',
  /** Uniq receivers count */
  Receivers = 'receivers',
  /** Uniq senders count */
  Senders = 'senders',
  /** Uniq transaction sources count */
  Sources = 'sources',
  /** Uniq statuses count */
  Statuses = 'statuses',
  /** Uniq times count */
  Times = 'times'
}

/** Tezos transaction with source */
export type BitqueryTezosTransactionWithSourceDimension = {
  __typename?: 'BitqueryTezosTransactionWithSourceDimension';
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction source */
  source?: Maybe<Scalars['String']['output']>;
};

/** Transfer in Tezos blockchain */
export type BitqueryTezosTransfer = {
  __typename?: 'BitqueryTezosTransfer';
  amount?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<BitqueryTezosBlockWithHashDimension>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Destination contract */
  destinationContract?: Maybe<Scalars['Boolean']['output']>;
  /** Direction */
  direction?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Internal */
  internal?: Maybe<Scalars['Boolean']['output']>;
  /** Kind */
  kind?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Op path */
  opPath?: Maybe<Scalars['String']['output']>;
  /** Proto */
  proto?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Protocol */
  protocol?: Maybe<Scalars['String']['output']>;
  /** Receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Sender */
  sender?: Maybe<BitqueryAddress>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryTezosTransactionWithSourceDimension>;
};


/** Transfer in Tezos blockchain */
export type BitqueryTezosTransferAmountArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationContract?: InputMaybe<BitqueryBooleanSelector>;
  direction?: InputMaybe<BitqueryStringSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  kind?: InputMaybe<BitqueryStringSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
};


/** Transfer in Tezos blockchain */
export type BitqueryTezosTransferAnyArgs = {
  of: BitqueryTezosTransferMeasurable;
};


/** Transfer in Tezos blockchain */
export type BitqueryTezosTransferCountArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationContract?: InputMaybe<BitqueryBooleanSelector>;
  direction?: InputMaybe<BitqueryStringSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  kind?: InputMaybe<BitqueryStringSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryTezosTransferUniq>;
};


/** Transfer in Tezos blockchain */
export type BitqueryTezosTransferCountBigIntArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationContract?: InputMaybe<BitqueryBooleanSelector>;
  direction?: InputMaybe<BitqueryStringSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  kind?: InputMaybe<BitqueryStringSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryTezosTransferUniq>;
};


/** Transfer in Tezos blockchain */
export type BitqueryTezosTransferExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transfer in Tezos blockchain */
export type BitqueryTezosTransferMaximumArgs = {
  get?: InputMaybe<BitqueryTezosTransferMeasurable>;
  of: BitqueryTezosTransferMeasurable;
};


/** Transfer in Tezos blockchain */
export type BitqueryTezosTransferMinimumArgs = {
  get?: InputMaybe<BitqueryTezosTransferMeasurable>;
  of: BitqueryTezosTransferMeasurable;
};

export type BitqueryTezosTransferFilter = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationContract?: InputMaybe<BitqueryBooleanSelector>;
  direction?: InputMaybe<BitqueryStringSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  kind?: InputMaybe<BitqueryStringSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
};

export enum BitqueryTezosTransferMeasurable {
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Block hash */
  BlockHash = 'blockHash',
  /** Currency name */
  CurrencyName = 'currencyName',
  /** Currency symbol */
  CurrencySymbol = 'currencySymbol',
  /** Date */
  Date = 'date',
  /** Destination contract */
  DestinationContract = 'destinationContract',
  /** Direction */
  Direction = 'direction',
  /** Internal */
  Internal = 'internal',
  /** Kind */
  Kind = 'kind',
  /** Op path */
  OpPath = 'opPath',
  /** Proto */
  Proto = 'proto',
  /** Protocol */
  Protocol = 'protocol',
  /** Receiver */
  Receiver = 'receiver',
  /** Sender */
  Sender = 'sender',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TransactionHash = 'transactionHash',
  /** Transaction source */
  TransactionSource = 'transactionSource'
}

export enum BitqueryTezosTransferUniq {
  /** Uniq block hashes count */
  BlockHashes = 'blockHashes',
  /** Uniq blocks count */
  Blocks = 'blocks',
  /** Uniq currency names count */
  CurrencyNames = 'currencyNames',
  /** Uniq currency symbols count */
  CurrencySymbols = 'currencySymbols',
  /** Uniq dates count */
  Dates = 'dates',
  /** Uniq destination contracts count */
  DestinationContracts = 'destinationContracts',
  /** Uniq directions count */
  Directions = 'directions',
  /** Uniq kinds count */
  Kinds = 'kinds',
  /** Uniq op paths count */
  OpPaths = 'opPaths',
  /** Uniq protocols count */
  Protocols = 'protocols',
  /** Uniq protos count */
  Protos = 'protos',
  /** Uniq receivers count */
  Receivers = 'receivers',
  /** Uniq senders count */
  Senders = 'senders',
  /** Uniq times count */
  Times = 'times',
  /** Uniq transaction hashes count */
  TransactionHashes = 'transactionHashes',
  /** Uniq transaction sources count */
  TransactionSources = 'transactionSources'
}

/** Time Interval */
export type BitqueryTimeInterval = {
  __typename?: 'BitqueryTimeInterval';
  day: Scalars['String']['output'];
  hour: Scalars['String']['output'];
  minute: Scalars['String']['output'];
  month: Scalars['String']['output'];
  second: Scalars['String']['output'];
  year: Scalars['String']['output'];
};


/** Time Interval */
export type BitqueryTimeIntervalDayArgs = {
  count?: InputMaybe<Scalars['Int']['input']>;
  format?: InputMaybe<Scalars['String']['input']>;
};


/** Time Interval */
export type BitqueryTimeIntervalHourArgs = {
  count?: InputMaybe<Scalars['Int']['input']>;
  format?: InputMaybe<Scalars['String']['input']>;
};


/** Time Interval */
export type BitqueryTimeIntervalMinuteArgs = {
  count?: InputMaybe<Scalars['Int']['input']>;
  format?: InputMaybe<Scalars['String']['input']>;
};


/** Time Interval */
export type BitqueryTimeIntervalMonthArgs = {
  count?: InputMaybe<Scalars['Int']['input']>;
  format?: InputMaybe<Scalars['String']['input']>;
};


/** Time Interval */
export type BitqueryTimeIntervalSecondArgs = {
  count?: InputMaybe<Scalars['Int']['input']>;
  format?: InputMaybe<Scalars['String']['input']>;
};


/** Time Interval */
export type BitqueryTimeIntervalYearArgs = {
  count?: InputMaybe<Scalars['Int']['input']>;
  format?: InputMaybe<Scalars['String']['input']>;
};

/** Timestamp */
export type BitqueryTimestamp = {
  __typename?: 'BitqueryTimestamp';
  /** Nanoseconds */
  nanoseconds: Scalars['BitqueryBigInt']['output'];
  time: Scalars['BitqueryISO8601Date']['output'];
};

/** Select trade by ID */
export type BitqueryTradeIdSelector = {
  /** Trade ID in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Trade ID is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Trade ID not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Trade ID not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export enum BitqueryTradeSide {
  /** Buy side */
  Buy = 'BUY',
  /** Sell side */
  Sell = 'SELL'
}

/** Information about transaction */
export type BitqueryTransactionElrond = {
  __typename?: 'BitqueryTransactionElrond';
  /** Shard number of sender */
  data?: Maybe<Scalars['String']['output']>;
  /** Shard number of sender */
  dataOperation?: Maybe<Scalars['String']['output']>;
  fee?: Maybe<Scalars['Float']['output']>;
  /** Shard number of sender */
  function?: Maybe<Scalars['String']['output']>;
  /** Transaction hash */
  hash?: Maybe<Scalars['String']['output']>;
  /** Transaction index */
  index?: Maybe<Scalars['Int']['output']>;
  /** Transaction nonce */
  nonce?: Maybe<Scalars['Int']['output']>;
  /** Hash of the receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Shard number of receiver */
  receiverShard?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Hash of the sender */
  sender?: Maybe<BitqueryAddress>;
  /** Shard number of sender */
  senderShard?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Shard number of sender */
  signature?: Maybe<Scalars['String']['output']>;
  /** Shard number of sender */
  status?: Maybe<Scalars['String']['output']>;
};


/** Information about transaction */
export type BitqueryTransactionElrondFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};

/** Blockchain transaction */
export type BitqueryTransactionHash = {
  __typename?: 'BitqueryTransactionHash';
  /** Hash hex representation */
  hash: Scalars['String']['output'];
};

/** Blockchain transaction */
export type BitqueryTransactionHashIndex = {
  __typename?: 'BitqueryTransactionHashIndex';
  /** Block of the Output Transaction for this input */
  block?: Maybe<Scalars['Int']['output']>;
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction index in block, 0-based */
  index: Scalars['String']['output'];
};

/** Blockchain transaction with value */
export type BitqueryTransactionHashValue = {
  __typename?: 'BitqueryTransactionHashValue';
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction value */
  value: Scalars['Float']['output'];
};

/** Blockchain transaction with value and time */
export type BitqueryTransactionHashValueTime = {
  __typename?: 'BitqueryTransactionHashValueTime';
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction time */
  time: BitqueryDateTime;
  /** Transaction value */
  value: Scalars['Float']['output'];
};

/** Transaction result */
export type BitqueryTransactionResult = {
  __typename?: 'BitqueryTransactionResult';
  /** Result ID */
  id: Scalars['Int']['output'];
  /** Result name */
  name: Scalars['String']['output'];
};

/** Identification of transaction source as client application */
export type BitqueryTransactionSource = {
  __typename?: 'BitqueryTransactionSource';
  /** ID numeric */
  code: Scalars['Int']['output'];
  /** Name */
  name: Scalars['String']['output'];
};

/** Select by type of transfer */
export type BitqueryTransferTypeSelector = {
  /** Transfer Type in the list */
  in?: InputMaybe<Array<BitqueryFilecoinTransferType>>;
  /** Transfer Type is */
  is?: InputMaybe<BitqueryFilecoinTransferType>;
  /** Transfer Type not */
  not?: InputMaybe<BitqueryFilecoinTransferType>;
  /** Transfer Type not in the list */
  notIn?: InputMaybe<Array<BitqueryFilecoinTransferType>>;
};

export enum BitqueryTransfersUniq {
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique currencies */
  Currencies = 'currencies',
  /** Unique date count */
  Dates = 'dates',
  /** Unique receivers count */
  Receivers = 'receivers',
  /** Unique senders count */
  Senders = 'senders',
  /** Transfers */
  Transfers = 'transfers',
  /** Unique transactions count */
  Txs = 'txs'
}

/** Tron Chain */
export type BitqueryTron = {
  __typename?: 'BitqueryTron';
  /** Basic information about address ( or smart contract ) */
  address: Array<BitqueryTronAddressInfoWithBalance>;
  /** Blockchain Arguments */
  arguments?: Maybe<Array<BitqueryTronArguments>>;
  /** Blockchain Blocks */
  blocks?: Maybe<Array<BitqueryTronBlocks>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryTronCoinpath>>;
  /** Blockchain Embedded Contracts */
  contracts?: Maybe<Array<BitqueryTronSmartContracts>>;
  /** Trades on Ethereum DEX Smart Contracts */
  dexTrades?: Maybe<Array<BitqueryTronDexTrades>>;
  /** Smart Contract Calls */
  smartContractCalls?: Maybe<Array<BitqueryTronSmartContractCalls>>;
  /** Smart Contract Events */
  smartContractEvents?: Maybe<Array<BitqueryTronSmartContractEvents>>;
  /** Blockchain Embedded Contracts */
  trades?: Maybe<Array<BitqueryTronTrades>>;
  /** Blockchain Transactions */
  transactions?: Maybe<Array<BitqueryTronTransactions>>;
  /** Currency Transfers */
  transfers?: Maybe<Array<BitqueryTronTransfers>>;
};


/** Tron Chain */
export type BitqueryTronAddressArgs = {
  address: Array<BitqueryAddressSelectorIn>;
};


/** Tron Chain */
export type BitqueryTronArgumentsArgs = {
  any?: InputMaybe<Array<BitqueryTronArgumentFilter>>;
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<BitqueryArgumentTypeSelector>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  owner?: InputMaybe<BitqueryAddressSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  reference?: InputMaybe<BitqueryAddressSelector>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Tron Chain */
export type BitqueryTronBlocksArgs = {
  any?: InputMaybe<Array<BitqueryTronBlockFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  parentBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
  witness?: InputMaybe<BitqueryAddressSelector>;
};


/** Tron Chain */
export type BitqueryTronCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCoinpathOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Tron Chain */
export type BitqueryTronContractsArgs = {
  any?: InputMaybe<Array<BitqueryTronContractFilter>>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txOwner?: InputMaybe<BitqueryAddressSelector>;
};


/** Tron Chain */
export type BitqueryTronDexTradesArgs = {
  any?: InputMaybe<Array<BitqueryTronDexTradeFilter>>;
  baseCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryAddressSelector>>;
  options?: InputMaybe<BitqueryQueryOptions>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Tron Chain */
export type BitqueryTronSmartContractCallsArgs = {
  any?: InputMaybe<Array<BitqueryTronSmartContractCallFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Tron Chain */
export type BitqueryTronSmartContractEventsArgs = {
  any?: InputMaybe<Array<BitqueryTronSmartContractEventFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Tron Chain */
export type BitqueryTronTradesArgs = {
  amountBuy?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountSell?: InputMaybe<Array<BitqueryAmountSelector>>;
  any?: InputMaybe<Array<BitqueryTronTradeFilter>>;
  buyCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  buyer?: InputMaybe<BitqueryAddressSelector>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeId?: InputMaybe<BitqueryIntIdSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  sellCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  seller?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Tron Chain */
export type BitqueryTronTransactionsArgs = {
  any?: InputMaybe<Array<BitqueryTronTransactionFilter>>;
  contractAddress?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  refBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
};


/** Tron Chain */
export type BitqueryTronTransfersArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  any?: InputMaybe<Array<BitqueryTronTransferFilter>>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};

/** Address detailed information for Tron network */
export type BitqueryTronAddressInfo = {
  __typename?: 'BitqueryTronAddressInfo';
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<BitqueryTronSmartContractInfo>;
};

/** Blockchain address */
export type BitqueryTronAddressInfoWithBalance = {
  __typename?: 'BitqueryTronAddressInfoWithBalance';
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Current address balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** Balances by currencies for the address */
  balances?: Maybe<Array<BitqueryTronBalance>>;
  /** Rewards that a witness or a user has not yet withdrawn */
  claimableRewards?: Maybe<Scalars['Float']['output']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<BitqueryTronSmartContractInfo>;
};


/** Blockchain address */
export type BitqueryTronAddressInfoWithBalanceBalanceArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Blockchain address */
export type BitqueryTronAddressInfoWithBalanceBalancesArgs = {
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelectorRange>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Blockchain address */
export type BitqueryTronAddressInfoWithBalanceClaimableRewardsArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};

export type BitqueryTronArgumentFilter = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<BitqueryArgumentTypeSelector>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  owner?: InputMaybe<BitqueryAddressSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  reference?: InputMaybe<BitqueryAddressSelector>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};

export enum BitqueryTronArgumentUniq {
  /** Unique Number of block in the blockchains */
  BlockHeight = 'block_height',
  /** Calls */
  Calls = 'calls',
  /** Unique date count */
  Dates = 'dates',
  /** Unique Owners */
  Owners = 'owners',
  /** Unique Receivers */
  Receivers = 'receivers',
  /** Unique Transaction Hash */
  Signature = 'signature',
  /** Unique number of arguments */
  SmartContracts = 'smart_contracts',
  /** Unique time */
  Times = 'times',
  /** Unique Transactions */
  Txs = 'txs',
  /** Unique Values */
  Values = 'values'
}

/** Arguments of Smart Contract Calls and Events */
export type BitqueryTronArguments = {
  __typename?: 'BitqueryTronArguments';
  any?: Maybe<Scalars['String']['output']>;
  /** Method or event argument */
  argument?: Maybe<BitqueryArgumentName>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callDepth?: Maybe<Scalars['String']['output']>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']['output']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** External call executed explicitly by tx sender. Internal calls executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']['output']>;
  /** Sequential index of value in array ( multi-dimensional) */
  index: Scalars['String']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  number?: Maybe<Scalars['Float']['output']>;
  /** Owner address */
  owner?: Maybe<BitqueryTronAddressInfo>;
  /** Transaction receiver */
  receiver?: Maybe<BitqueryTronAddressInfo>;
  /** Address value of method or event argument */
  reference?: Maybe<BitqueryTronAddressInfo>;
  /** Smart contract being called */
  smartContract?: Maybe<BitqueryTronSmartContract>;
  /** Contract method or event */
  smartContractSignature?: Maybe<BitquerySignature>;
  /** Transaction Hash */
  txHash?: Maybe<Scalars['String']['output']>;
  /** Transaction Index */
  txIndex?: Maybe<Scalars['Int']['output']>;
  /** The Value of method or event argument */
  value?: Maybe<BitqueryArgumentValue>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryTronArgumentsAnyArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<BitqueryArgumentTypeSelector>;
  as?: InputMaybe<BitqueryTronArgumentsConvertable>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  of: BitqueryTronArgumentsMeasureable;
  owner?: InputMaybe<BitqueryAddressSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  reference?: InputMaybe<BitqueryAddressSelector>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryTronArgumentsArgumentArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Scalars['String']['input']>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryTronArgumentsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryTronArgumentsCountArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<BitqueryArgumentTypeSelector>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  owner?: InputMaybe<BitqueryAddressSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  reference?: InputMaybe<BitqueryAddressSelector>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryTronArgumentUniq>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryTronArgumentsCountBigIntArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<BitqueryArgumentTypeSelector>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  owner?: InputMaybe<BitqueryAddressSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  reference?: InputMaybe<BitqueryAddressSelector>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryTronArgumentUniq>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryTronArgumentsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryTronArgumentsMaximumArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<BitqueryArgumentTypeSelector>;
  as?: InputMaybe<BitqueryTronArgumentsConvertable>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  get?: InputMaybe<BitqueryTronArgumentsMeasureable>;
  height?: InputMaybe<BitqueryBlockSelector>;
  of: BitqueryTronArgumentsMeasureable;
  owner?: InputMaybe<BitqueryAddressSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  reference?: InputMaybe<BitqueryAddressSelector>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryTronArgumentsMinimumArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<BitqueryArgumentTypeSelector>;
  as?: InputMaybe<BitqueryTronArgumentsConvertable>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  get?: InputMaybe<BitqueryTronArgumentsMeasureable>;
  height?: InputMaybe<BitqueryBlockSelector>;
  of: BitqueryTronArgumentsMeasureable;
  owner?: InputMaybe<BitqueryAddressSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  reference?: InputMaybe<BitqueryAddressSelector>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryTronArgumentsNumberArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<BitqueryArgumentTypeSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  owner?: InputMaybe<BitqueryAddressSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  reference?: InputMaybe<BitqueryAddressSelector>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryTronArgumentsSmartContractSignatureArgs = {
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryTronArgumentsValueArgs = {
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};

export enum BitqueryTronArgumentsConvertable {
  /** Token name */
  TokenName = 'token_name',
  /** Token symbol */
  TokenSymbol = 'token_symbol'
}

export enum BitqueryTronArgumentsMeasureable {
  /** Argument */
  Argument = 'argument',
  /** Argument index */
  ArgumentIndex = 'argument_index',
  /** Argument type */
  ArgumentType = 'argument_type',
  /** Argument value */
  ArgumentValue = 'argument_value',
  /** Block */
  Block = 'block',
  /** Call depth */
  CallDepth = 'call_depth',
  /** Date */
  Date = 'date',
  /** Owner */
  Owner = 'owner',
  /** Receiver */
  Receiver = 'receiver',
  /** Smart Contract Method Signature */
  Signature = 'signature',
  /** Smart Contract Method Signature Hash */
  SignatureHash = 'signature_hash',
  /** Smart Contract Method Name */
  SignatureName = 'signature_name',
  /** Smart Contract Method Signature */
  SignatureType = 'signature_type',
  /** Smart Contract */
  SmartContract = 'smart_contract',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Transaction Index */
  TxIndex = 'tx_index'
}

/** Balance in a currency */
export type BitqueryTronBalance = {
  __typename?: 'BitqueryTronBalance';
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** History of balance changes by currencies for the address */
  history?: Maybe<Array<BitqueryTronBalanceChange>>;
  value?: Maybe<Scalars['Float']['output']>;
};


/** Balance in a currency */
export type BitqueryTronBalanceValueArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};

/** Change of balance in a currency */
export type BitqueryTronBalanceChange = {
  __typename?: 'BitqueryTronBalanceChange';
  /** Block number (height) in blockchain */
  block: Scalars['Int']['output'];
  /** Block timestamp */
  timestamp?: Maybe<Scalars['BitqueryISO8601DateTime']['output']>;
  /** Transfer amount ( positive inbound, negative outbound) */
  transferAmount?: Maybe<Scalars['Float']['output']>;
  value?: Maybe<Scalars['Float']['output']>;
};

export type BitqueryTronBlockFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  parentBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
  witness?: InputMaybe<BitqueryAddressSelector>;
};

/** Blocks in Tron blockchain */
export type BitqueryTronBlocks = {
  __typename?: 'BitqueryTronBlocks';
  any?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Block hash */
  hash: Scalars['String']['output'];
  /** Block number (height) in blockchain */
  height: Scalars['Int']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Parent block hash */
  parentBlockHash: Scalars['String']['output'];
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** TX Trie Root Hash */
  txTrieRoot: Scalars['String']['output'];
  /** Block version */
  version?: Maybe<Scalars['Int']['output']>;
  /** Block witness */
  witness?: Maybe<BitqueryAddress>;
  /** Witness signature */
  witnessSignature: Scalars['String']['output'];
};


/** Blocks in Tron blockchain */
export type BitqueryTronBlocksAnyArgs = {
  of: BitqueryTronBlocksMeasureable;
};


/** Blocks in Tron blockchain */
export type BitqueryTronBlocksCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  parentBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryTronBlocksUniq>;
  version?: InputMaybe<BitqueryIntegerSelector>;
  witness?: InputMaybe<BitqueryAddressSelector>;
};


/** Blocks in Tron blockchain */
export type BitqueryTronBlocksCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  parentBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryTronBlocksUniq>;
  version?: InputMaybe<BitqueryIntegerSelector>;
  witness?: InputMaybe<BitqueryAddressSelector>;
};


/** Blocks in Tron blockchain */
export type BitqueryTronBlocksExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Blocks in Tron blockchain */
export type BitqueryTronBlocksHashArgs = {
  blockHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Blocks in Tron blockchain */
export type BitqueryTronBlocksHeightArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Blocks in Tron blockchain */
export type BitqueryTronBlocksMaximumArgs = {
  get?: InputMaybe<BitqueryTronBlocksMeasureable>;
  of: BitqueryTronBlocksMeasureable;
};


/** Blocks in Tron blockchain */
export type BitqueryTronBlocksMinimumArgs = {
  get?: InputMaybe<BitqueryTronBlocksMeasureable>;
  of: BitqueryTronBlocksMeasureable;
};


/** Blocks in Tron blockchain */
export type BitqueryTronBlocksParentBlockHashArgs = {
  parentBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Blocks in Tron blockchain */
export type BitqueryTronBlocksTimestampArgs = {
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Blocks in Tron blockchain */
export type BitqueryTronBlocksVersionArgs = {
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Blocks in Tron blockchain */
export type BitqueryTronBlocksWitnessArgs = {
  witness?: InputMaybe<BitqueryAddressSelector>;
};

export enum BitqueryTronBlocksMeasureable {
  /** Block */
  Block = 'block',
  /** Block hash */
  BlockHash = 'block_hash',
  /** Date */
  Date = 'date',
  /** Time */
  Time = 'time',
  /** Block Version */
  Version = 'version',
  /** Block Witness address */
  Witness = 'witness'
}

export enum BitqueryTronBlocksUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique witness count */
  Witnesses = 'witnesses'
}

export enum BitqueryTronCallsMeasureable {
  /** Block */
  Block = 'block',
  /** Call depth */
  CallDepth = 'call_depth',
  /** Date */
  Date = 'date',
  /** Smart Contract Method Signature */
  Signature = 'signature',
  /** Smart Contract Method Signature Hash */
  SignatureHash = 'signature_hash',
  /** Smart Contract Method Name */
  SignatureName = 'signature_name',
  /** Smart Contract */
  SmartContract = 'smart_contract',
  /** Time */
  Time = 'time',
  /** Action From */
  TxFrom = 'tx_from',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Action To */
  TxTo = 'tx_to'
}

/** Coinpath */
export type BitqueryTronCoinpath = {
  __typename?: 'BitqueryTronCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryTronCoinpathAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryTronCoinpathAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<BitqueryTransactionHashValueTime>;
};


/** Coinpath */
export type BitqueryTronCoinpathAmountArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Coinpath */
export type BitqueryTronCoinpathAnyArgs = {
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryTronCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryTronCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};

/** Address detailed information for Ethereum network */
export type BitqueryTronCoinpathAddress = {
  __typename?: 'BitqueryTronCoinpathAddress';
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  amountIn?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  amountOut?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  balance?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Smart Contract if exists on the address */
  firstTxAt?: Maybe<BitqueryDateTime>;
  /** Smart Contract if exists on the address */
  lastTxAt?: Maybe<BitqueryDateTime>;
  receiversCount?: Maybe<Scalars['Int']['output']>;
  sendersCount?: Maybe<Scalars['Int']['output']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<BitqueryTronSmartContractInfo>;
  /** Address type */
  type?: Maybe<Scalars['String']['output']>;
};

export type BitqueryTronContractFilter = {
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txOwner?: InputMaybe<BitqueryAddressSelector>;
};

/** Select contract type(s) */
export type BitqueryTronContractTypeSelector = {
  /** Contract type in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Contract type is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Contract type not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Contract type not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export enum BitqueryTronContractsMeasureable {
  /** Block */
  Block = 'block',
  /** Contract */
  ContractType = 'contract_type',
  /** Date */
  Date = 'date',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Transaction owner */
  TxOwner = 'tx_owner'
}

/**
 * Currency selector in Tron blockchain.
 * Token identified by address of contract for TRC20 tokens and token name (or numeric token ID )  for TRC10
 */
export type BitqueryTronCurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Currency not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Tron DEX attributes */
export type BitqueryTronDex = {
  __typename?: 'BitqueryTronDex';
  /** Address for DEX exchange identification */
  address: BitqueryAddress;
  /** Full name ( name for known, Protocol for unknown ) */
  fullName: Scalars['String']['output'];
  /** Full name ( name for known, Protocol / address for unknown ) */
  fullNameWithId: Scalars['String']['output'];
  /** Name for known exchanges */
  name?: Maybe<Scalars['String']['output']>;
};

export type BitqueryTronDexTradeFilter = {
  baseCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryAddressSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};

/** Trades on DEX smart contracts */
export type BitqueryTronDexTrades = {
  __typename?: 'BitqueryTronDexTrades';
  /** Trader (maker or taker) */
  address?: Maybe<BitqueryTronAddressInfo>;
  any?: Maybe<Scalars['String']['output']>;
  baseAmount?: Maybe<Scalars['Float']['output']>;
  /** Base currency */
  baseCurrency?: Maybe<BitqueryCurrency>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlockExtended>;
  buyAmount?: Maybe<Scalars['Float']['output']>;
  /** Maker buys this currency */
  buyCurrency?: Maybe<BitqueryCurrency>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  energyFee?: Maybe<Scalars['Float']['output']>;
  energyUsageTotal?: Maybe<Scalars['Float']['output']>;
  /** Identification of admin / manager / factory of smart contract, executing trades */
  exchange?: Maybe<BitqueryTronDex>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  fee?: Maybe<Scalars['Float']['output']>;
  internalTransactionsCount?: Maybe<Scalars['Int']['output']>;
  internalTransactionsCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  logsCount?: Maybe<Scalars['Int']['output']>;
  logsCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Trade 'maker' side */
  maker?: Maybe<BitqueryTronAddressInfo>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  netFee?: Maybe<Scalars['Float']['output']>;
  netUsage?: Maybe<Scalars['Float']['output']>;
  price?: Maybe<Scalars['Float']['output']>;
  /** Protocol name of the smart contract */
  protocol?: Maybe<Scalars['String']['output']>;
  quoteAmount?: Maybe<Scalars['Float']['output']>;
  /** Quote currency */
  quoteCurrency?: Maybe<BitqueryCurrency>;
  quotePrice?: Maybe<Scalars['Float']['output']>;
  sellAmount?: Maybe<Scalars['Float']['output']>;
  /** Maker sells this currency */
  sellCurrency?: Maybe<BitqueryCurrency>;
  /** Side of trade ( SELL / BUY ) */
  side?: Maybe<BitqueryTradeSide>;
  /** Smart contract being called */
  smartContract?: Maybe<BitqueryTronSmartContract>;
  /** Trade 'taker' side */
  taker?: Maybe<BitqueryTronAddressInfo>;
  /** Time interval */
  timeInterval?: Maybe<BitqueryTimeInterval>;
  tradeAmount?: Maybe<Scalars['Float']['output']>;
  /** Index of trade in transaction, used to separate trades in transaction */
  tradeIndex?: Maybe<Scalars['String']['output']>;
  /** Transaction of DexTrade */
  transaction?: Maybe<BitqueryTronTransactionInfoExtended>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesAddressArgs = {
  makerOrTaker?: InputMaybe<Array<BitqueryAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesAnyArgs = {
  of: BitqueryTronDexTradesMeasureable;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesBaseAmountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesBaseCurrencyArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesBuyAmountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesBuyCurrencyArgs = {
  buyCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesCountArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryAddressSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryTronDexTradesUniq>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesCountBigIntArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryAddressSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryTronDexTradesUniq>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesEnergyFeeArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  maker?: InputMaybe<Array<BitqueryAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryAddressSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesEnergyUsageTotalArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryAddressSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesExchangeArgs = {
  exchangeAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesFeeArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  maker?: InputMaybe<Array<BitqueryAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryAddressSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesInternalTransactionsCountArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryAddressSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesInternalTransactionsCountBigIntArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryAddressSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesLogsCountArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryAddressSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesLogsCountBigIntArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryAddressSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesMakerArgs = {
  maker?: InputMaybe<Array<BitqueryAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesMaximumArgs = {
  get?: InputMaybe<BitqueryTronDexTradesMeasureable>;
  of: BitqueryTronDexTradesMeasureable;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesMinimumArgs = {
  get?: InputMaybe<BitqueryTronDexTradesMeasureable>;
  of: BitqueryTronDexTradesMeasureable;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesNetFeeArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  maker?: InputMaybe<Array<BitqueryAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryAddressSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesNetUsageArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryAddressSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesPriceArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  calculate?: InputMaybe<BitqueryPriceAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryAddressSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesProtocolArgs = {
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesQuoteAmountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesQuoteCurrencyArgs = {
  quoteCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesQuotePriceArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  calculate?: InputMaybe<BitqueryPriceAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryAddressSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesSellAmountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesSellCurrencyArgs = {
  sellCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesSmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesTakerArgs = {
  taker?: InputMaybe<Array<BitqueryAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesTradeAmountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  in: BitqueryBaseCurrencyEnum;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesTradeIndexArgs = {
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesTransactionArgs = {
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};

export enum BitqueryTronDexTradesMeasureable {
  /** Block */
  Block = 'block',
  /** Buy Amount */
  BuyAmount = 'buy_amount',
  /** Buy Token address */
  BuyCurrencyAddress = 'buy_currency_address',
  /** Buy Currency symbol */
  BuyCurrencySymbol = 'buy_currency_symbol',
  /** Date */
  Date = 'date',
  /** Maker */
  Maker = 'maker',
  /** Price */
  Price = 'price',
  /** Quote Price */
  QuotePrice = 'quote_price',
  /** Sell Amount */
  SellAmount = 'sell_amount',
  /** Sell Token address */
  SellCurrencyAddress = 'sell_currency_address',
  /** Sell Currency symbol */
  SellCurrencySymbol = 'sell_currency_symbol',
  /** Taker */
  Taker = 'taker',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

export enum BitqueryTronDexTradesUniq {
  /** Unique makers & takers count */
  Address = 'address',
  /** Base currencies count */
  BaseCurrency = 'base_currency',
  /** Unique blocks */
  Blocks = 'blocks',
  /** Buy currencies count */
  BuyCurrency = 'buy_currency',
  /** Unique date count */
  Dates = 'dates',
  /** Unique makers count */
  Makers = 'makers',
  /** Unique protocols count */
  Protocols = 'protocols',
  /** Quote currencies count */
  QuoteCurrency = 'quote_currency',
  /** Sell currencies count */
  SellCurrency = 'sell_currency',
  /** Unique smart contract count */
  SmartContracts = 'smart_contracts',
  /** Unique makers count */
  Takers = 'takers',
  /** Unique transactions count */
  Txs = 'txs'
}

export enum BitqueryTronEventsMeasureable {
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Smart Contract Method Signature */
  Signature = 'signature',
  /** Smart Contract Method Signature Hash */
  SignatureHash = 'signature_hash',
  /** Smart Contract Method Name */
  SignatureName = 'signature_name',
  /** Smart Contract */
  SmartContract = 'smart_contract',
  /** Time */
  Time = 'time',
  /** Action From */
  TxFrom = 'tx_from',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Action To */
  TxTo = 'tx_to'
}

export enum BitqueryTronNetwork {
  /** TRON mainnet */
  Tron = 'tron'
}

/** Tron smart contract */
export type BitqueryTronSmartContract = {
  __typename?: 'BitqueryTronSmartContract';
  /** Smart Contract Address */
  address: BitqueryAddress;
  /** Smart Contract Type */
  contractType?: Maybe<BitquerySmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<BitqueryScCurrency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']['output']>;
};

export type BitqueryTronSmartContractCallFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};

/** Smart Contract Calls */
export type BitqueryTronSmartContractCalls = {
  __typename?: 'BitqueryTronSmartContractCalls';
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Call arguments */
  arguments?: Maybe<Array<BitqueryArgumentNameValue>>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callDepth?: Maybe<Scalars['String']['output']>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']['output']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  energyUsageTotal?: Maybe<Scalars['Float']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** External call executed explicitly by caller. Internal calls executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']['output']>;
  fee?: Maybe<Scalars['Float']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  netUsage?: Maybe<Scalars['Float']['output']>;
  /** Smart contract being called */
  smartContract?: Maybe<BitqueryTronSmartContract>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<BitqueryMethod>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Action from address */
  txFrom?: Maybe<BitqueryAddress>;
  /** Transaction hash where transfer happened */
  txHash?: Maybe<Scalars['String']['output']>;
  /** Action to address */
  txTo?: Maybe<BitqueryAddress>;
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsAmountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsAnyArgs = {
  of: BitqueryTronCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsEnergyUsageTotalArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsMaximumArgs = {
  get?: InputMaybe<BitqueryTronCallsMeasureable>;
  of: BitqueryTronCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsMinimumArgs = {
  get?: InputMaybe<BitqueryTronCallsMeasureable>;
  of: BitqueryTronCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsNetUsageArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsSmartContractArgs = {
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsSmartContractMethodArgs = {
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsSuccessArgs = {
  success?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsTxFromArgs = {
  txFrom?: InputMaybe<BitqueryAddressSelector>;
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsTxHashArgs = {
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsTxToArgs = {
  txTo?: InputMaybe<BitqueryAddressSelector>;
};

export type BitqueryTronSmartContractEventFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};

/** Smart Contract Events */
export type BitqueryTronSmartContractEvents = {
  __typename?: 'BitqueryTronSmartContractEvents';
  any?: Maybe<Scalars['String']['output']>;
  /** Call arguments */
  arguments?: Maybe<Array<BitqueryArgumentNameValue>>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']['output']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Smart contract being Evented */
  smartContract?: Maybe<BitqueryTronSmartContract>;
  /** Contract method invoked */
  smartContractEvent?: Maybe<BitqueryEvent>;
  /** Action from address */
  txFrom?: Maybe<BitqueryAddress>;
  /** Transaction hash where transfer happened */
  txHash?: Maybe<Scalars['String']['output']>;
  /** Action to address */
  txTo?: Maybe<BitqueryAddress>;
};


/** Smart Contract Events */
export type BitqueryTronSmartContractEventsAnyArgs = {
  of: BitqueryTronEventsMeasureable;
};


/** Smart Contract Events */
export type BitqueryTronSmartContractEventsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Smart Contract Events */
export type BitqueryTronSmartContractEventsCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Smart Contract Events */
export type BitqueryTronSmartContractEventsCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Smart Contract Events */
export type BitqueryTronSmartContractEventsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Smart Contract Events */
export type BitqueryTronSmartContractEventsMaximumArgs = {
  get?: InputMaybe<BitqueryTronEventsMeasureable>;
  of: BitqueryTronEventsMeasureable;
};


/** Smart Contract Events */
export type BitqueryTronSmartContractEventsMinimumArgs = {
  get?: InputMaybe<BitqueryTronEventsMeasureable>;
  of: BitqueryTronEventsMeasureable;
};


/** Smart Contract Events */
export type BitqueryTronSmartContractEventsSmartContractArgs = {
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
};


/** Smart Contract Events */
export type BitqueryTronSmartContractEventsSmartContractEventArgs = {
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
};


/** Smart Contract Events */
export type BitqueryTronSmartContractEventsTxFromArgs = {
  txFrom?: InputMaybe<BitqueryAddressSelector>;
};


/** Smart Contract Events */
export type BitqueryTronSmartContractEventsTxHashArgs = {
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Smart Contract Events */
export type BitqueryTronSmartContractEventsTxToArgs = {
  txTo?: InputMaybe<BitqueryAddressSelector>;
};

/** Blockchain smart contract */
export type BitqueryTronSmartContractInfo = {
  __typename?: 'BitqueryTronSmartContractInfo';
  /** Smart Contract Type */
  contractType?: Maybe<BitquerySmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<BitqueryScCurrency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']['output']>;
};

/** Contracts */
export type BitqueryTronSmartContracts = {
  __typename?: 'BitqueryTronSmartContracts';
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Contract type */
  contractType?: Maybe<Scalars['String']['output']>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']['output']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  energyUsageTotal?: Maybe<Scalars['Float']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  fee?: Maybe<Scalars['Float']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  netUsage?: Maybe<Scalars['Float']['output']>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction hash where transfer happened */
  txHash?: Maybe<Scalars['String']['output']>;
  /** Transactio owner from address */
  txOwner?: Maybe<BitqueryAddress>;
};


/** Contracts */
export type BitqueryTronSmartContractsAmountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txOwner?: InputMaybe<BitqueryAddressSelector>;
};


/** Contracts */
export type BitqueryTronSmartContractsAnyArgs = {
  of: BitqueryTronContractsMeasureable;
};


/** Contracts */
export type BitqueryTronSmartContractsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Contracts */
export type BitqueryTronSmartContractsContractTypeArgs = {
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
};


/** Contracts */
export type BitqueryTronSmartContractsCountArgs = {
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txOwner?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Contracts */
export type BitqueryTronSmartContractsCountBigIntArgs = {
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txOwner?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Contracts */
export type BitqueryTronSmartContractsCurrencyArgs = {
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
};


/** Contracts */
export type BitqueryTronSmartContractsEnergyUsageTotalArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txOwner?: InputMaybe<BitqueryAddressSelector>;
};


/** Contracts */
export type BitqueryTronSmartContractsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Contracts */
export type BitqueryTronSmartContractsFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txOwner?: InputMaybe<BitqueryAddressSelector>;
};


/** Contracts */
export type BitqueryTronSmartContractsMaximumArgs = {
  get?: InputMaybe<BitqueryTronContractsMeasureable>;
  of: BitqueryTronContractsMeasureable;
};


/** Contracts */
export type BitqueryTronSmartContractsMinimumArgs = {
  get?: InputMaybe<BitqueryTronContractsMeasureable>;
  of: BitqueryTronContractsMeasureable;
};


/** Contracts */
export type BitqueryTronSmartContractsNetUsageArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txOwner?: InputMaybe<BitqueryAddressSelector>;
};


/** Contracts */
export type BitqueryTronSmartContractsSuccessArgs = {
  success?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};


/** Contracts */
export type BitqueryTronSmartContractsTxHashArgs = {
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Contracts */
export type BitqueryTronSmartContractsTxOwnerArgs = {
  txOwner?: InputMaybe<BitqueryAddressSelector>;
};

export type BitqueryTronTradeFilter = {
  amountBuy?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountSell?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  buyer?: InputMaybe<BitqueryAddressSelector>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeId?: InputMaybe<BitqueryIntIdSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  sellCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  seller?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};

/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTrades = {
  __typename?: 'BitqueryTronTrades';
  amountBuy?: Maybe<Scalars['Float']['output']>;
  amountSell?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where Trade transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Buy Currency of Trade */
  buyCurrency?: Maybe<BitqueryCurrency>;
  /** Trade buyer */
  buyer?: Maybe<BitqueryAddress>;
  /** Contract type */
  contractType?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  energyUsageTotal?: Maybe<Scalars['Float']['output']>;
  /** exchange_id */
  exchangeId?: Maybe<Scalars['Int']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  fee?: Maybe<Scalars['Float']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  netUsage?: Maybe<Scalars['Float']['output']>;
  /** Sell Currency of Trade */
  sellCurrency?: Maybe<BitqueryCurrency>;
  /** Trade seller */
  seller?: Maybe<BitqueryAddress>;
  /** Transfer succeeded */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction hash where Trade happened */
  txHash?: Maybe<Scalars['String']['output']>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesAmountBuyArgs = {
  amountBuy?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountSell?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  buyer?: InputMaybe<BitqueryAddressSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeId?: InputMaybe<BitqueryIntIdSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  sellCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  seller?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesAmountSellArgs = {
  amountBuy?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountSell?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  buyer?: InputMaybe<BitqueryAddressSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeId?: InputMaybe<BitqueryIntIdSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  sellCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  seller?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesAnyArgs = {
  of: BitqueryTronTradesMeasureable;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesBuyCurrencyArgs = {
  buyCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesBuyerArgs = {
  buyer?: InputMaybe<BitqueryAddressSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesContractTypeArgs = {
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesCountArgs = {
  amountBuy?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountSell?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  buyer?: InputMaybe<BitqueryAddressSelector>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeId?: InputMaybe<BitqueryIntIdSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  sellCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  seller?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryTronTradesUniq>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesCountBigIntArgs = {
  amountBuy?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountSell?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  buyer?: InputMaybe<BitqueryAddressSelector>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeId?: InputMaybe<BitqueryIntIdSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  sellCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  seller?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryTronTradesUniq>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesEnergyUsageTotalArgs = {
  amountBuy?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountSell?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  buyer?: InputMaybe<BitqueryAddressSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeId?: InputMaybe<BitqueryIntIdSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  sellCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  seller?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesExchangeIdArgs = {
  exchangeId?: InputMaybe<BitqueryIntIdSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesFeeArgs = {
  amountBuy?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountSell?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  buyer?: InputMaybe<BitqueryAddressSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeId?: InputMaybe<BitqueryIntIdSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  sellCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  seller?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesMaximumArgs = {
  get?: InputMaybe<BitqueryTronTradesMeasureable>;
  of: BitqueryTronTradesMeasureable;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesMinimumArgs = {
  get?: InputMaybe<BitqueryTronTradesMeasureable>;
  of: BitqueryTronTradesMeasureable;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesNetUsageArgs = {
  amountBuy?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountSell?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  buyer?: InputMaybe<BitqueryAddressSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeId?: InputMaybe<BitqueryIntIdSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  sellCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  seller?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesSellCurrencyArgs = {
  sellCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesSellerArgs = {
  seller?: InputMaybe<BitqueryAddressSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesTxHashArgs = {
  txHash?: InputMaybe<BitqueryHashSelector>;
};

export enum BitqueryTronTradesMeasureable {
  /** Amount Sell */
  AmountBuy = 'amount_buy',
  /** Amount Sell */
  AmountSell = 'amount_sell',
  /** Block */
  Block = 'block',
  /** Buy Token address */
  BuyCurrencyAddress = 'buy_currency_address',
  /** Buy Currency name */
  BuyCurrencyName = 'buy_currency_name',
  /** Buy Currency symbol */
  BuyCurrencySymbol = 'buy_currency_symbol',
  /** Buy Token address */
  BuyTokenId = 'buy_token_id',
  /** Buy Token type */
  BuyTokenType = 'buy_token_type',
  /** Buyer */
  Buyer = 'buyer',
  /** Contract Type */
  ContractType = 'contract_type',
  /** Date */
  Date = 'date',
  /** Exchange ID */
  ExchangeId = 'exchange_id',
  /** Buy Token address */
  SellCurrencyAddress = 'sell_currency_address',
  /** Buy Currency name */
  SellCurrencyName = 'sell_currency_name',
  /** Buy Currency symbol */
  SellCurrencySymbol = 'sell_currency_symbol',
  /** Buy Token address */
  SellTokenId = 'sell_token_id',
  /** Buy Token type */
  SellTokenType = 'sell_token_type',
  /** Seller */
  Seller = 'seller',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

export enum BitqueryTronTradesUniq {
  /** Unique blocks */
  Blocks = 'blocks',
  /** Buy currencies */
  BuyCurrencies = 'buy_currencies',
  /** Buyers count */
  Buyers = 'buyers',
  /** Unique date count */
  Dates = 'dates',
  /** Exchange IDs */
  Exchanges = 'exchanges',
  /** Sell currencies */
  SellCurrencies = 'sell_currencies',
  /** Sellers count */
  Sellers = 'sellers',
  /** Unique transactions count */
  Txs = 'txs'
}

export type BitqueryTronTransactionFilter = {
  contractAddress?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  refBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
};

/** Blockchain Transaction Extended info */
export type BitqueryTronTransactionInfoExtended = {
  __typename?: 'BitqueryTronTransactionInfoExtended';
  /** Contract Address */
  contractAddress?: Maybe<BitqueryAddress>;
  /** Expiration */
  expiration: Scalars['BitqueryBigInt']['output'];
  /** Fee Limit */
  feeLimit: Scalars['Int']['output'];
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction index in block, 0 based */
  index?: Maybe<Scalars['Int']['output']>;
  /** Ref block Hash hex representation */
  refBlockHash: Scalars['String']['output'];
  /** Result message */
  result?: Maybe<Scalars['String']['output']>;
  /** Signatures */
  signatures: Scalars['String']['output'];
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
};

/** Transactions in Tron blockchain */
export type BitqueryTronTransactions = {
  __typename?: 'BitqueryTronTransactions';
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Contract Address */
  contractAddress?: Maybe<BitqueryAddress>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  energyFee?: Maybe<Scalars['Float']['output']>;
  energyUsageTotal?: Maybe<Scalars['Float']['output']>;
  /** Expiration */
  expiration: Scalars['Int']['output'];
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  fee?: Maybe<Scalars['Float']['output']>;
  /** Fee Limit */
  feeLimit: Scalars['Int']['output'];
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction index in block, 0 based */
  index?: Maybe<Scalars['Int']['output']>;
  internalTransactionsCount?: Maybe<Scalars['Int']['output']>;
  internalTransactionsCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  logsCount?: Maybe<Scalars['Int']['output']>;
  logsCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  netFee?: Maybe<Scalars['Float']['output']>;
  netUsage?: Maybe<Scalars['Float']['output']>;
  /** Ref block Hash hex representation */
  refBlockHash: Scalars['String']['output'];
  /** Result message */
  result?: Maybe<Scalars['String']['output']>;
  /** Signatures */
  signatures: Scalars['String']['output'];
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsAnyArgs = {
  of: BitqueryTronTransactionsMeasureable;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsContractAddressArgs = {
  contractAddress?: InputMaybe<BitqueryAddressSelector>;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsCountArgs = {
  contractAddress?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  refBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  uniq?: InputMaybe<BitqueryTronTransactionsUniq>;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsCountBigIntArgs = {
  contractAddress?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  refBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  uniq?: InputMaybe<BitqueryTronTransactionsUniq>;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsEnergyFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractAddress?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  refBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsEnergyUsageTotalArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractAddress?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  refBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractAddress?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  refBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsHashArgs = {
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsIndexArgs = {
  txIndex?: InputMaybe<Array<BitqueryTxIndexSelector>>;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsInternalTransactionsCountArgs = {
  contractAddress?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  refBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsInternalTransactionsCountBigIntArgs = {
  contractAddress?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  refBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsLogsCountArgs = {
  contractAddress?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  refBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsLogsCountBigIntArgs = {
  contractAddress?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  refBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsMaximumArgs = {
  get?: InputMaybe<BitqueryTronTransactionsMeasureable>;
  of: BitqueryTronTransactionsMeasureable;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsMinimumArgs = {
  get?: InputMaybe<BitqueryTronTransactionsMeasureable>;
  of: BitqueryTronTransactionsMeasureable;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsNetFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractAddress?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  refBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsNetUsageArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractAddress?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  refBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsRefBlockHashArgs = {
  refBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum BitqueryTronTransactionsMeasureable {
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Energy Fee */
  EnergyFee = 'energy_fee',
  /** Fee */
  Fee = 'fee',
  /** Fee Limit */
  FeeLimit = 'fee_limit',
  /** Internal transactions count */
  InternalTransactionsCount = 'internal_transactions_count',
  /** Net usage */
  NetUsage = 'net_usage',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

export enum BitqueryTronTransactionsUniq {
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates'
}

export type BitqueryTronTransferFilter = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};

/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfers = {
  __typename?: 'BitqueryTronTransfers';
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Contract type */
  contractType?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  energyUsageTotal?: Maybe<Scalars['Float']['output']>;
  /** Entity identifier ( for ERC-721 NFT tokens ) */
  entityId?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']['output']>;
  fee?: Maybe<Scalars['Float']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  netUsage?: Maybe<Scalars['Float']['output']>;
  /** Transfer receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Transfer sender */
  sender?: Maybe<BitqueryAddress>;
  /** Transfer succeeded */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Action from address */
  txFrom?: Maybe<BitqueryAddress>;
  /** Transaction hash where transfer happened */
  txHash?: Maybe<Scalars['String']['output']>;
  /** Action to address */
  txTo?: Maybe<BitqueryAddress>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersAmountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersAnyArgs = {
  of: BitqueryTronTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersContractTypeArgs = {
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersCountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryTransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersCountBigIntArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryTransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersCurrencyArgs = {
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersEnergyUsageTotalArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersEntityIdArgs = {
  entityId?: InputMaybe<BitqueryEntitySelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersFeeArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersMaximumArgs = {
  get?: InputMaybe<BitqueryTronTransfersMeasureable>;
  of: BitqueryTronTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersMinimumArgs = {
  get?: InputMaybe<BitqueryTronTransfersMeasureable>;
  of: BitqueryTronTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersNetUsageArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersReceiverArgs = {
  receiver?: InputMaybe<BitqueryAddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersSenderArgs = {
  sender?: InputMaybe<BitqueryAddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersTxFromArgs = {
  txFrom?: InputMaybe<BitqueryAddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersTxHashArgs = {
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersTxToArgs = {
  txTo?: InputMaybe<BitqueryAddressSelector>;
};

export enum BitqueryTronTransfersMeasureable {
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Token address */
  CurrencyAddress = 'currency_address',
  /** Currency symbol */
  CurrencySymbol = 'currency_symbol',
  /** Date */
  Date = 'date',
  /** Receiver */
  Receiver = 'receiver',
  /** Sender */
  Sender = 'sender',
  /** Time */
  Time = 'time',
  /** Token ID */
  TokenId = 'token_id',
  /** Token type */
  TokenType = 'token_type',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

/** Selector of index of transaction in block */
export type BitqueryTxIndexSelector = {
  /** Tx index in the list */
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Tx index is */
  is?: InputMaybe<Scalars['Int']['input']>;
  /** Tx index not */
  not?: InputMaybe<Scalars['Int']['input']>;
  /** Tx index not in the list */
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** Select transactions by subtype */
export type BitqueryTxSubtypeSelector = {
  /** Transaction SubType in the list */
  in?: InputMaybe<Array<BitqueryAlgorandTxSubType>>;
  /** Transaction SubType is */
  is?: InputMaybe<BitqueryAlgorandTxSubType>;
  /** Transaction SubType not */
  not?: InputMaybe<BitqueryAlgorandTxSubType>;
  /** Transaction SubType not in the list */
  notIn?: InputMaybe<Array<BitqueryAlgorandTxSubType>>;
};

/** Select transactions by type */
export type BitqueryTxTypeSelector = {
  /** Transaction Type in the list */
  in?: InputMaybe<Array<BitqueryAlgorandTxType>>;
  /** Transaction Type is */
  is?: InputMaybe<BitqueryAlgorandTxType>;
  /** Transaction Type not */
  not?: InputMaybe<BitqueryAlgorandTxType>;
  /** Transaction Type not in the list */
  notIn?: InputMaybe<Array<BitqueryAlgorandTxType>>;
};

/** Utilities */
export type BitqueryUtilities = {
  __typename?: 'BitqueryUtilities';
  /** Active period */
  activePeriod?: Maybe<BitqueryActivePeriod>;
  /** Query metrics */
  metrics?: Maybe<BitqueryMetrics>;
};


/** Utilities */
export type BitqueryUtilitiesActivePeriodArgs = {
  apiKey: Scalars['String']['input'];
  options?: InputMaybe<BitquerySeedOptions>;
};


/** Utilities */
export type BitqueryUtilitiesMetricsArgs = {
  options?: InputMaybe<BitquerySeedOptions>;
  queryId: Scalars['String']['input'];
};

/** UtilitiesDate */
export type BitqueryUtilitiesDate = {
  __typename?: 'BitqueryUtilitiesDate';
  /** String date representation with default format as YYYY-MM-DD */
  date: Scalars['String']['output'];
  /** Day of month (1-31) */
  dayOfMonth: Scalars['Int']['output'];
  /** Day of week  (Monday is 1, and Sunday is 7) */
  dayOfWeek: Scalars['Int']['output'];
  /** Month number (1-12) */
  month: Scalars['Int']['output'];
  /** Year number */
  year: Scalars['Int']['output'];
};

export type CoinapiModelVwap24RefRate = {
  __typename?: 'CoinapiModelVWAP24RefRate';
  asset?: Maybe<Scalars['String']['output']>;
  rate?: Maybe<Scalars['Float']['output']>;
  time?: Maybe<Scalars['String']['output']>;
  volume?: Maybe<Scalars['Float']['output']>;
};

export type CoinapiModelsExchangeTimeseriesItem = {
  __typename?: 'CoinapiModelsExchangeTimeseriesItem';
  priceClose?: Maybe<Scalars['Float']['output']>;
  priceHigh?: Maybe<Scalars['Float']['output']>;
  priceLow?: Maybe<Scalars['Float']['output']>;
  priceOpen?: Maybe<Scalars['Float']['output']>;
  symbolIdCoinapi?: Maybe<Scalars['String']['output']>;
  symbolIdExchange?: Maybe<Scalars['String']['output']>;
  timeClose?: Maybe<Scalars['String']['output']>;
  timeOpen?: Maybe<Scalars['String']['output']>;
  timePeriodEnd?: Maybe<Scalars['String']['output']>;
  timePeriodStart?: Maybe<Scalars['String']['output']>;
  tradesCount?: Maybe<Scalars['Int']['output']>;
  volumeTraded?: Maybe<Scalars['Float']['output']>;
};

export type CoinapiMutation = {
  __typename?: 'CoinapiMutation';
};

export type CoinapiQuery = {
  __typename?: 'CoinapiQuery';
  modelsExchangeTimeseriesItems?: Maybe<Array<CoinapiModelsExchangeTimeseriesItem>>;
  v1ExchangeRate?: Maybe<CoinapiV1ExchangeRate>;
  v1ExchangeRatesRates?: Maybe<Array<CoinapiV1ExchangeRatesRate>>;
  v1ExchangeRatesTimeseriesItems?: Maybe<Array<CoinapiV1ExchangeRatesTimeseriesItem>>;
  v1IndexData?: Maybe<CoinapiV1IndexData>;
  v1IndexValues?: Maybe<Array<CoinapiV1IndexValue>>;
  v1Indexes?: Maybe<Array<CoinapiV1Index>>;
  v1Metrics?: Maybe<Array<CoinapiV1Metric>>;
  v1OrderBookBases?: Maybe<Array<CoinapiV1OrderBookBase>>;
  v1OrderBookDepth?: Maybe<CoinapiV1OrderBookDepth>;
  v1QuoteTrade?: Maybe<CoinapiV1QuoteTrade>;
  v1QuoteTrades?: Maybe<Array<CoinapiV1QuoteTrade>>;
  v1SymbolMappings?: Maybe<Array<CoinapiV1SymbolMapping>>;
};


export type CoinapiQueryModelsExchangeTimeseriesItemsArgs = {
  exchangeId: Scalars['String']['input'];
  periodId: Scalars['String']['input'];
  timeEnd: Scalars['String']['input'];
  timeStart: Scalars['String']['input'];
};


export type CoinapiQueryV1ExchangeRateArgs = {
  assetIdBase: Scalars['String']['input'];
  assetIdQuote: Scalars['String']['input'];
  time?: InputMaybe<Scalars['String']['input']>;
};


export type CoinapiQueryV1ExchangeRatesRatesArgs = {
  assetIdBase: Scalars['String']['input'];
  filterAssetId?: InputMaybe<Scalars['String']['input']>;
  invert?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<Scalars['String']['input']>;
};


export type CoinapiQueryV1ExchangeRatesTimeseriesItemsArgs = {
  assetIdBase: Scalars['String']['input'];
  assetIdQuote: Scalars['String']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  periodId?: InputMaybe<Scalars['String']['input']>;
  timeEnd?: InputMaybe<Scalars['String']['input']>;
  timeStart?: InputMaybe<Scalars['String']['input']>;
};


export type CoinapiQueryV1IndexDataArgs = {
  indexId: Scalars['String']['input'];
};


export type CoinapiQueryV1IndexValuesArgs = {
  indexId: Scalars['String']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeEnd?: InputMaybe<Scalars['String']['input']>;
  timeStart?: InputMaybe<Scalars['String']['input']>;
};


export type CoinapiQueryV1OrderBookBasesArgs = {
  filterSymbolId?: InputMaybe<Scalars['String']['input']>;
  limitLevels?: InputMaybe<Scalars['Int']['input']>;
};


export type CoinapiQueryV1OrderBookDepthArgs = {
  limitLevels?: InputMaybe<Scalars['Int']['input']>;
  symbolId: Scalars['String']['input'];
};


export type CoinapiQueryV1QuoteTradeArgs = {
  symbolId: Scalars['String']['input'];
};


export type CoinapiQueryV1QuoteTradesArgs = {
  filterSymbolId?: InputMaybe<Scalars['String']['input']>;
};


export type CoinapiQueryV1SymbolMappingsArgs = {
  exchangeId: Scalars['String']['input'];
};

export type CoinapiV1ExchangeRate = {
  __typename?: 'CoinapiV1ExchangeRate';
  assetIdBase?: Maybe<Scalars['String']['output']>;
  assetIdQuote?: Maybe<Scalars['String']['output']>;
  rate?: Maybe<Scalars['Float']['output']>;
  srcSideBase?: Maybe<Array<CoinapiModelVwap24RefRate>>;
  srcSideQuote?: Maybe<Array<CoinapiModelVwap24RefRate>>;
  time?: Maybe<Scalars['String']['output']>;
};

export type CoinapiV1ExchangeRatesRate = {
  __typename?: 'CoinapiV1ExchangeRatesRate';
  assetIdQuote?: Maybe<Scalars['String']['output']>;
  rate?: Maybe<Scalars['Float']['output']>;
  time?: Maybe<Scalars['String']['output']>;
};

export type CoinapiV1ExchangeRatesTimeseriesItem = {
  __typename?: 'CoinapiV1ExchangeRatesTimeseriesItem';
  rateClose?: Maybe<Scalars['Float']['output']>;
  rateHigh?: Maybe<Scalars['Float']['output']>;
  rateLow?: Maybe<Scalars['Float']['output']>;
  rateOpen?: Maybe<Scalars['Float']['output']>;
  timeClose?: Maybe<Scalars['String']['output']>;
  timeOpen?: Maybe<Scalars['String']['output']>;
  timePeriodEnd?: Maybe<Scalars['String']['output']>;
  timePeriodStart?: Maybe<Scalars['String']['output']>;
};

export type CoinapiV1Index = {
  __typename?: 'CoinapiV1Index';
  description?: Maybe<Scalars['String']['output']>;
  indexId?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

export type CoinapiV1IndexData = {
  __typename?: 'CoinapiV1IndexData';
  components?: Maybe<Array<CoinapiV1IndexDataComponent>>;
  description?: Maybe<Scalars['String']['output']>;
  indexId?: Maybe<Scalars['String']['output']>;
  indexMethod?: Maybe<Scalars['String']['output']>;
  indexMethodParameters?: Maybe<Scalars['JSON']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  notifyEmails?: Maybe<Scalars['String']['output']>;
  periodRecalculation?: Maybe<Scalars['String']['output']>;
  visibilityPublic?: Maybe<Scalars['Boolean']['output']>;
};

export type CoinapiV1IndexDataComponent = {
  __typename?: 'CoinapiV1IndexDataComponent';
  componentId?: Maybe<Scalars['String']['output']>;
  evaluationMethod?: Maybe<Scalars['String']['output']>;
  evaluationMethodParameters?: Maybe<Scalars['JSON']['output']>;
};

export type CoinapiV1IndexValue = {
  __typename?: 'CoinapiV1IndexValue';
  composition?: Maybe<Array<CoinapiV1IndexValueComponent>>;
  timestamp?: Maybe<Scalars['String']['output']>;
  value?: Maybe<Scalars['Float']['output']>;
};

export type CoinapiV1IndexValueComponent = {
  __typename?: 'CoinapiV1IndexValueComponent';
  componentId?: Maybe<Scalars['String']['output']>;
  componentValue?: Maybe<Scalars['Float']['output']>;
};

export type CoinapiV1LastTrade = {
  __typename?: 'CoinapiV1LastTrade';
  price?: Maybe<Scalars['Float']['output']>;
  size?: Maybe<Scalars['Float']['output']>;
  takerSide?: Maybe<Scalars['String']['output']>;
  timeCoinapi?: Maybe<Scalars['String']['output']>;
  timeExchange?: Maybe<Scalars['String']['output']>;
  uuid?: Maybe<Scalars['String']['output']>;
};

export type CoinapiV1Metric = {
  __typename?: 'CoinapiV1Metric';
  description?: Maybe<Scalars['String']['output']>;
  metricId?: Maybe<Scalars['String']['output']>;
};

export type CoinapiV1OrderBookBase = {
  __typename?: 'CoinapiV1OrderBookBase';
  symbolId?: Maybe<Scalars['String']['output']>;
  timeCoinapi?: Maybe<Scalars['String']['output']>;
  timeExchange?: Maybe<Scalars['String']['output']>;
};

export type CoinapiV1OrderBookDepth = {
  __typename?: 'CoinapiV1OrderBookDepth';
  askDepth?: Maybe<Scalars['Float']['output']>;
  askLevels?: Maybe<Scalars['Int']['output']>;
  bidDepth?: Maybe<Scalars['Float']['output']>;
  bidLevels?: Maybe<Scalars['Int']['output']>;
  symbolId?: Maybe<Scalars['String']['output']>;
  timeCoinapi?: Maybe<Scalars['String']['output']>;
  timeExchange?: Maybe<Scalars['String']['output']>;
};

export type CoinapiV1QuoteTrade = {
  __typename?: 'CoinapiV1QuoteTrade';
  askPrice?: Maybe<Scalars['Float']['output']>;
  askSize?: Maybe<Scalars['Float']['output']>;
  bidPrice?: Maybe<Scalars['Float']['output']>;
  bidSize?: Maybe<Scalars['Float']['output']>;
  lastTrade?: Maybe<CoinapiV1LastTrade>;
  symbolId?: Maybe<Scalars['String']['output']>;
  timeCoinapi?: Maybe<Scalars['String']['output']>;
  timeExchange?: Maybe<Scalars['String']['output']>;
};

export type CoinapiV1SymbolMapping = {
  __typename?: 'CoinapiV1SymbolMapping';
  assetIdBase?: Maybe<Scalars['String']['output']>;
  assetIdBaseExchange?: Maybe<Scalars['String']['output']>;
  assetIdQuote?: Maybe<Scalars['String']['output']>;
  assetIdQuoteExchange?: Maybe<Scalars['String']['output']>;
  pricePrecision?: Maybe<Scalars['Float']['output']>;
  sizePrecision?: Maybe<Scalars['Float']['output']>;
  symbolId?: Maybe<Scalars['String']['output']>;
  symbolIdExchange?: Maybe<Scalars['String']['output']>;
};

export type Mutation = {
  __typename?: 'Mutation';
  coinapi: CoinapiMutation;
};

export type Query = {
  __typename?: 'Query';
  /** Access to embedded bitquery API. */
  bitquery: BitqueryQuery;
  coinapi: CoinapiQuery;
};
